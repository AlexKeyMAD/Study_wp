<head>
    <link rel="stylesheet" href="../../../css/books_style.css">
</head>

<body>
    <div>
        <p><a href="./00_01.html">&lArr;SQLite за 5 минут или меньше</a></p>
        <h1>Введение в интерфейс SQLite C/C++</h1>
        <h2>Этот документ знакомит с C/C++ API. Пользователи должны прочитать этот документ перед Справочным руководством по C/C++ API, ссылка на который приведена ниже.</h2>
        <br>
        <h2>1. Резюме</h2>
        <p>Следующие два объекта и восемь методов составляют основные элементы интерфейса SQLite:</p>
        <ul>
            <li><span class="font-bold">sqlite3</span> → Объект подключения к базе данных. Создано sqlite3_open() и уничтожено sqlite3_close().</li>
            <li><span class="font-bold">qlite3_stmt</span> → Подготовленный объект оператора. Создано sqlite3_prepare() и уничтожено sqlite3_finalize().</li>
            <li><span class="font-bold">sqlite3_open()</span> → Открыть соединение с новой или существующей базой данных SQLite. Конструктор для sqlite3.</li>
            <li><span class="font-bold">sqlite3_prepare()</span> → Скомпилируйте текст SQL в байт-код, который будет выполнять работу по запросу или обновлению базы данных. Конструктор sqlite3_stmt.</li>
            <li><span class="font-bold">sqlite3_bind()</span> → Сохраните данные приложения в параметрах исходного SQL. </li>
            <li><span class="font-bold">sqlite3_step()</span> → Переместите sqlite3_stmt к следующей строке результата или к завершению. </li>
            <li><span class="font-bold">sqlite3_column()</span> → Значения столбца в строке текущего результата для sqlite3_stmt. </li>
            <li><span class="font-bold">sqlite3_finalize()</span> → Деструктор для sqlite3_stmt. </li>
            <li><span class="font-bold">sqlite3_close()</span> → Деструктор для sqlite3. </li>
            <li><span class="font-bold">sqlite3_exec()</span> → Функция-оболочка, которая выполняет sqlite3_prepare(), sqlite3_step(), sqlite3_column() и sqlite3_finalize() для строки из одного или нескольких операторов SQL.</li>
        </ul>
        <h2>2. Введение</h2>
        <p>SQLite имеет более 225 API. Однако большинство API являются необязательными и очень специализированными, и новички могут их игнорировать. Базовый API небольшой, простой и легкий в освоении. В этой статье дается краткое описание основного API.</p>
        <p>В отдельном документе, Интерфейс SQLite C/C++, представлены подробные спецификации для всех API C/C++ для SQLite. Как только читатель поймет основные принципы работы SQLite, этот документ следует использовать в качестве справочного руководства.
            Эта статья предназначена только для ознакомления и не является ни полным, ни авторитетным справочником по SQLite API. </p>
        <h2>3. Основные объекты и интерфейсы</h2>
        <p>Основная задача механизма базы данных SQL - оценивать SQL-операторы SQL. Для этого разработчику нужны два объекта:</p>
        <ul>
            <li>Объект подключения к базе данных: sqlite3 </li>
            <li>Подготовленный объект оператора: sqlite3_stmt</li>
        </ul>
        <p>Строго говоря, подготовленный объект оператора не требуется, поскольку можно использовать удобные интерфейсы оболочки, sqlite3_exec или sqlite3_get_table, и эти удобные оболочки инкапсулируют и скрывают подготовленный объект оператора. Тем не
            менее, понимание подготовленных операторов необходимо для полноценного использования SQLite.</p>
        <p>Объекты подключения к базе данных и подготовленных операторов управляются небольшим набором процедур интерфейса C/C++, перечисленных ниже. </p>
        <ul>
            <li>sqlite3_open()</li>
            <li>sqlite3_prepare()</li>
            <li>sqlite3_step()</li>
            <li>sqlite3_column()</li>
            <li>sqlite3_finalize()</li>
            <li>sqlite3_close()</li>
        </ul>
        <p>Обратите внимание, что приведенный выше список процедур является скорее концептуальным, чем фактическим. Многие из этих подпрограмм имеют несколько версий. Например, в приведенном выше списке показана одна процедура с именем sqlite3_open(), хотя
            на самом деле есть три отдельные процедуры, которые выполняют одно и то же несколько разными способами: sqlite3_open(), sqlite3_open16() и sqlite3_open_v2(). В списке упоминается sqlite3_column(), хотя на самом деле такой процедуры не существует.
            Показанный в списке «sqlite3_column()» является заполнителем для всего семейства подпрограмм, которые добавляют данные столбца в различные типы данных. </p>
        <p>Here is a summary of what the core interfaces do:</p>
        <ul>
            <li class="font-bold">sqlite3_open()</li>
            <p>Эта процедура открывает соединение с файлом базы данных SQLite и возвращает объект соединения с базой данных. Часто это первый вызов API-интерфейса SQLite, выполняемый приложением, и он является необходимым условием для большинства других
                API-интерфейсов SQLite. Для многих интерфейсов SQLite в качестве первого параметра требуется указатель на объект подключения к базе данных, и их можно рассматривать как методы объекта подключения к базе данных. Эта процедура является конструктором
                объекта подключения к базе данных. </p>
            <li class="font-bold">sqlite3_prepare()</li>
            <p>Эта процедура преобразует текст SQL в подготовленный объект оператора и возвращает указатель на этот объект. Этот интерфейс требует указателя соединения с базой данных, созданного предыдущим вызовом sqlite3_open(), и текстовой строки, содержащей
                инструкцию SQL, которую нужно подготовить. Этот API фактически не оценивает инструкцию SQL. Он просто подготавливает инструкцию SQL для оценки.</p>
            <p>Думайте о каждом операторе SQL как о небольшой компьютерной программе. Цель sqlite3_prepare() - скомпилировать эту программу в объектный код. Подготовленный оператор - это объектный код. Затем интерфейс sqlite3_step() запускает объектный код
                для получения результата.</p>
            <p>Новые приложения всегда должны вызывать sqlite3_prepare_v2() вместо sqlite3_prepare(). Более старый sqlite3_prepare() сохранен для обратной совместимости. Но sqlite3_prepare_v2() предоставляет гораздо лучший интерфейс. </p>
            <li class="font-bold">sqlite3_step()</li>
            <p>Эта процедура используется для оценки подготовленного оператора, который был ранее создан интерфейсом sqlite3_prepare(). Оператор оценивается до момента, когда становится доступна первая строка результатов. Чтобы перейти ко второй строке результатов,
                снова вызовите sqlite3_step(). Продолжайте вызывать sqlite3_step (), пока оператор не будет завершен. Операторы, которые не возвращают результатов (например, операторы INSERT, UPDATE или DELETE), выполняются до завершения при одном вызове
                sqlite3_step(). </p>
            <li class="font-bold">sqlite3_column()</li>
            <p>Эта процедура возвращает единственный столбец из текущей строки набора результатов для подготовленного оператора, который оценивается sqlite3_step(). Каждый раз, когда sqlite3_step() останавливается с новой строкой набора результатов, эту
                процедуру можно вызывать несколько раз, чтобы найти значения всех столбцов в этой строке.</p>
            <p>Как отмечалось выше, в API SQLite действительно нет такой вещи, как функция sqlite3_column(). Вместо этого то, что мы здесь называем «sqlite3_column()», является заполнителем для всего семейства функций, которые возвращают значение из набора
                результатов в различных типах данных. В этом семействе также есть подпрограммы, которые возвращают размер результата (если это строка или большой двоичный объект) и количество столбцов в наборе результатов. </p>
            <ul>
                <li>sqlite3_column_blob()</li>
                <li>sqlite3_column_bytes()</li>
                <li>sqlite3_column_bytes16()</li>
                <li>sqlite3_column_count()</li>
                <li>sqlite3_column_double()</li>
                <li>sqlite3_column_int()</li>
                <li>sqlite3_column_int64()</li>
                <li>sqlite3_column_text()</li>
                <li>sqlite3_column_text16()</li>
                <li>sqlite3_column_type()</li>
                <li>sqlite3_column_value()</li>
            </ul>
            <li class="font-bold">sqlite3_finalize()</li>
            <p>Эта процедура уничтожает подготовленный оператор, созданный предыдущим вызовом sqlite3_prepare(). Каждый подготовленный оператор должен быть уничтожен с помощью вызова этой подпрограммы, чтобы избежать утечки памяти. </p>
            <p>Эта процедура закрывает соединение с базой данных, ранее открытое вызовом sqlite3_open(). Все подготовленные операторы, связанные с подключением, должны быть завершены до закрытия подключения. </p>
            <li class="font-bold">sqlite3_close()</li>
        </ul>
        <h2>4. Типичное использование основных процедур и объектов</h2>
        <p>Приложение обычно использует sqlite3_open() для создания единственного соединения с базой данных во время инициализации. Обратите внимание, что sqlite3_open() может использоваться либо для открытия существующих файлов базы данных, либо для создания
            и открытия новых файлов базы данных. Хотя многие приложения используют только одно соединение с базой данных, нет причин, по которым приложение не может вызывать sqlite3_open() несколько раз, чтобы открыть несколько соединений с базой данных
            - либо к одной, либо к разным базам данных. Иногда многопоточное приложение создает отдельные подключения к базе данных для каждого потока. Обратите внимание, что одно соединение с базой данных может получить доступ к двум или более базам
            данных с помощью команды ATTACH SQL, поэтому нет необходимости иметь отдельное соединение с базой данных для каждого файла базы данных.</p>
        <p>Многие приложения разрушают свои соединения с базой данных, используя вызовы sqlite3_close() при завершении работы. Или, например, приложение, использующее SQLite в качестве формата файла приложения, может открывать соединения с базой данных в
            ответ на действие меню «Файл / Открыть», а затем разрушать соответствующее соединение с базой данных в ответ на меню «Файл / Закрыть».</p>
        <p>Чтобы запустить инструкцию SQL, приложение выполняет следующие действия: </p>
        <ol>
            <li>Создайте подготовленный оператор с помощью sqlite3_prepare().</li>
            <li>Оцените подготовленный оператор, вызвав sqlite3_step() один или несколько раз.</li>
            <li>Для запросов извлекайте результаты, вызывая sqlite3_column() между двумя вызовами sqlite3_step().</li>
            <li>Уничтожьте подготовленный оператор с помощью sqlite3_finalize(). </li>
        </ol>
        <p>Вышесказанное - это все, что действительно нужно знать для эффективного использования SQLite. Все остальное - оптимизация и детализация.</p>
        <h2>5. Удобные оболочки вокруг основных подпрограмм </h2>
        <p>Интерфейс sqlite3_exec() - это удобная оболочка, которая выполняет все четыре вышеуказанных шага за один вызов функции. Функция обратного вызова, переданная в sqlite3_exec(), используется для обработки каждой строки набора результатов. Sqlite3_get_table()
            - еще одна удобная оболочка, которая выполняет все четыре шага выше. Интерфейс sqlite3_get_table() отличается от sqlite3_exec() тем, что он сохраняет результаты запросов в динамической памяти, а не вызывает обратный вызов.</p>
        <p>Важно понимать, что ни sqlite3_exec(), ни sqlite3_get_table() не делают ничего, что не может быть выполнено с помощью основных подпрограмм. Фактически, эти оболочки реализованы исключительно в терминах основных подпрограмм. </p>
        <h2>6. Параметры привязки и повторное использование подготовленных операторов</h2>
        <p>В предыдущем обсуждении предполагалось, что каждый оператор SQL готовится один раз, оценивается, а затем уничтожается. Однако SQLite позволяет выполнять многократную оценку одного и того же подготовленного оператора. Это достигается с помощью
            следующих процедур:</p>
        <ul>
            <li>sqlite3_reset()</li>
            <li>sqlite3_bind()</li>
        </ul>
        <p>После того, как подготовленный оператор был оценен одним или несколькими вызовами sqlite3_step(), его можно сбросить, чтобы снова оценить его вызовом sqlite3_reset(). Подумайте о sqlite3_reset() как о перемотке подготовленной программы операторов
            к началу. Использование sqlite3_reset() для существующего подготовленного оператора вместо создания нового подготовленного оператора позволяет избежать ненужных вызовов sqlite3_prepare(). Для многих операторов SQL время, необходимое для запуска
            sqlite3_prepare(), равно или превышает время, необходимое для sqlite3_step(). Таким образом, отказ от вызовов sqlite3_prepare() может дать значительное улучшение производительности.</p>
        <p>Обычно нецелесообразно оценивать один и тот же оператор SQL более одного раза. Чаще хочется оценить похожие утверждения. Например, вы можете захотеть оценить оператор INSERT несколько раз с разными значениями. Или вы можете захотеть оценить один
            и тот же запрос несколько раз, используя другой ключ в предложении WHERE. Чтобы приспособиться к этому, SQLite позволяет операторам SQL содержать параметры, которые «привязаны» к значениям до их оценки. Эти значения могут быть позже изменены,
            и тот же подготовленный оператор может быть оценен во второй раз с использованием новых значений.</p>
        <p>SQLite позволяет использовать параметр везде, где разрешены строковый литерал, числовая константа или NULL. (Параметры нельзя использовать для имен столбцов или таблиц.) Параметр принимает одну из следующих форм: </p>
        <ul>
            <li>?</li>
            <li>?NNN</li>
            <li>:AAA</li>
            <li>$AAA</li>
            <li>@AAA</li>
        </ul>
        <p>В приведенных выше примерах NNN - это целое число, а AAA - идентификатор. Первоначально параметр имеет значение NULL. Перед вызовом sqlite3_step() в первый раз или сразу после sqlite3_reset() приложение может вызывать интерфейсы sqlite3_bind()
            для присоединения значений к параметрам. Каждый вызов sqlite3_bind() переопределяет предыдущие привязки одного и того же параметра.</p>
        <p>Приложению разрешено заранее подготовить несколько операторов SQL и оценить их по мере необходимости. Не существует произвольного ограничения на количество ожидающих выполнения подготовленных отчетов. Некоторые приложения вызывают sqlite3_prepare()
            несколько раз при запуске, чтобы создать все подготовленные операторы, которые им когда-либо понадобятся. Другие приложения хранят кеш последних использованных подготовленных операторов, а затем повторно используют подготовленные операторы
            из кеша, когда они доступны. Другой подход - повторно использовать подготовленные операторы только тогда, когда они находятся внутри цикла. </p>
        <h2>7. Настройка SQLite </h2>
        <p>Конфигурация по умолчанию для SQLite отлично подходит для большинства приложений. Но иногда разработчики хотят настроить настройку, чтобы попытаться выжать немного больше производительности или воспользоваться какой-то малоизвестной функцией.</p>
        <p>Интерфейс sqlite3_config() используется для внесения глобальных изменений конфигурации всего процесса для SQLite. Интерфейс sqlite3_config() должен быть вызван до создания любых соединений с базой данных. Интерфейс sqlite3_config() позволяет программисту
            делать такие вещи, как: </p>
        <ul>
            <li>Настройте способ выделения памяти в SQLite, включая настройку альтернативных распределителей памяти, подходящих для критически важных для безопасности встраиваемых систем реального времени и определяемых приложением распределителей памяти.</li>
            <li>Настройте журнал ошибок всего процесса.</li>
            <li>Укажите определяемый приложением кеш страницы.</li>
            <li>Отрегулируйте использование мьютексов, чтобы они подходили для различных моделей потоков, или замените систему мьютексов, определяемую приложением. </li>
        </ul>
        <p>После завершения настройки всего процесса и создания подключений к базе данных отдельные подключения к базе данных можно настроить с помощью вызовов sqlite3_limit() и sqlite3_db_config(). </p>
        <h2>8. Расширение SQLite </h2>
        <p>SQLite включает интерфейсы, которые можно использовать для расширения его функциональности. Такие процедуры включают: </p>
        <ul>
            <li>sqlite3_create_collation()</li>
            <li>sqlite3_create_function()</li>
            <li>sqlite3_create_module()</li>
            <li>sqlite3_vfs_register()</li>
        </ul>
        <p>Интерфейс sqlite3_create_collation() используется для создания новых последовательностей сортировки для сортировки текста. Интерфейс sqlite3_create_module() используется для регистрации новых реализаций виртуальных таблиц. Интерфейс sqlite3_vfs_register()
            создает новые виртуальные файловые системы.</p>
        <p>Интерфейс sqlite3_create_function() создает новые функции SQL - скалярные или агрегатные. В новой реализации функции обычно используются следующие дополнительные интерфейсы: </p>
        <ul>
            <li>sqlite3_aggregate_context()</li>
            <li>sqlite3_result()</li>
            <li>sqlite3_user_data()</li>
            <li>sqlite3_value()</li>
        </ul>
        <p>Все встроенные функции SQL SQLite создаются с использованием точно таких же интерфейсов. За примерами обратитесь к исходному коду SQLite и, в частности, к исходным файлам date.c и func.c.</p>
        <p>Общие библиотеки или DLL могут использоваться как загружаемые расширения SQLite. </p>
        <h2>9. Другие интерфейсы </h2>
        <p>В этой статье упоминаются только самые важные и наиболее часто используемые интерфейсы SQLite. Библиотека SQLite включает в себя множество других API, реализующих полезные функции, которые здесь не описаны. Полный список функций, которые образуют
            интерфейс прикладного программирования SQLite, можно найти в Спецификации интерфейса C/C++. Обратитесь к этому документу для получения полной и достоверной информации обо всех интерфейсах SQLite. </p>
        <p><a href="./00_03.html">Как компилировать SQLite&rArr;</a></p>
    </div>
</body>