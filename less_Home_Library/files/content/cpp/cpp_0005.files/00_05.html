<head>
    <link rel="stylesheet" href="../../../css/books_style.css">
</head>

<body>
    <div>
        <p><a href="./00_04.html">&lArr;Справочник по C/C++ API SQLite</a></p>
        <h1>Коды результатов и ошибок</h1>
        <h2>Описание значений числовых кодов результатов, возвращаемых различными интерфейсами C/C++.</h2>
        <hr>
        <h2>Обзор</h2>
        <p>Многие подпрограммы в интерфейсе на языке C SQLite возвращают числовые коды результатов, указывающие либо успех, либо неудачу, а в случае сбоя - некоторое представление о причине сбоя. Этот документ пытается объяснить, что означает каждый из этих
            числовых кодов результатов. </p>
        <h2>1. Коды результатов в сравнении с кодами ошибок </h2>
        <p>«Коды ошибок» - это подмножество «результирующих кодов», которые указывают на то, что что-то пошло не так. Есть только несколько кодов результатов без ошибок: SQLITE_OK, SQLITE_ROW и SQLITE_DONE. Термин «код ошибки» означает любой код результата,
            кроме этих трех. </p>
        <h2>2. Основные коды результатов по сравнению с кодами расширенных результатов </h2>
        <p>Коды результатов представляют собой 32-битные целые числа со знаком. Младшие 8 битов результирующего кода определяют широкую категорию и называются «первичным результирующим кодом». Более значимые биты предоставляют более подробную информацию
            об ошибке и называются «расширенным кодом результата».</p>
        <p>Обратите внимание, что основной код результата всегда является частью расширенного кода результата. Учитывая полный 32-битный расширенный код результата, приложение всегда может найти соответствующий первичный код результата, просто извлекая 8
            младших битов расширенного кода результата.</p>
        <p>Все расширенные коды результатов также являются кодами ошибок. Следовательно, термины «расширенный код результата» и «расширенный код ошибки» взаимозаменяемы.</p>
        <p>Для исторической совместимости интерфейсы на языке C по умолчанию возвращают первичные коды результатов. Расширенный код результата для самой последней ошибки можно получить с помощью интерфейса sqlite3_extended_errcode(). Интерфейс sqlite3_extended_result_codes()
            можно использовать для перевода соединения с базой данных в режим, в котором он возвращает расширенные коды результатов вместо основных кодов результатов. </p>
        <h2>3. Определения</h2>
        <p>Все коды результатов являются целыми числами. Символические имена для всех результирующих кодов создаются с помощью макроса «#define» в заголовочном файле sqlite3.h. В заголовочном файле sqlite3.h есть отдельные разделы для определений кода результата
            и расширенных определений кода результата.</p>
        <p>Символьные имена первичного кода результата имеют форму «SQLITE_XXXXXX», где XXXXXX - это последовательность букв в верхнем регистре. Имена расширенных кодов результатов имеют форму «SQLITE_XXXXXX_YYYYYYY», где часть XXXXXX - это соответствующий
            первичный код результата, а YYYYYYY - это расширение, которое дополнительно классифицирует код результата.</p>
        <p>Имена и числовые значения для существующих кодов результатов являются фиксированными и неизменными. Однако новые коды результатов и особенно новые расширенные коды результатов могут появиться в будущих выпусках SQLite. </p>
        <h2>4. Список первичных кодов результатов</h2>
        <p>31 код результата определены в sqlite3.h и перечислены в алфавитном порядке ниже:</p>
        <table>
            <tr>
                <td class="table-w-30per">
                    <ul>
                        <li>SQLITE_ABORT <span><a href="#er_SQLITE_ABORT">(4)</a></span></li>
                        <li>SQLITE_AUTH <span><a href="#er_SQLITE_AUTH">(23)</a></span></li>
                        <li>SQLITE_BUSY <span><a href="#er_SQLITE_BUSY">(5)</a></span></li>
                        <li>SQLITE_CANTOPEN <span><a href="#er_SQLITE_CANTOPEN">(14)</a></span></li>
                        <li>SQLITE_CONSTRAINT <span><a href="#er_SQLITE_CONSTRAINT">(19)</a></span></li>
                        <li>SQLITE_CORRUPT <span><a href="#er_SQLITE_CORRUPT">(11)</a></span></li>
                        <li>SQLITE_DONE <span><a href="#er_SQLITE_DONE">(101)</a></span></li>
                        <li>SQLITE_EMPTY <span><a href="#er_SQLITE_EMPTY">(16)</a></span></li>
                        <li>SQLITE_ERROR <span><a href="#er_SQLITE_ERROR">(1)</a></span></li>
                        <li>SQLITE_FORMAT <span><a href="#er_SQLITE_FORMAT">(24)</a></span></li>
                        <li>SQLITE_FULL <span><a href="#er_SQLITE_FULL">(13)</a></span></li>
                    </ul>
                </td>
                <td class="table-w-30per">
                    <ul>
                        <li>SQLITE_INTERNAL <span><a href="#er_SQLITE_INTERNAL">(2)</a></span></li>
                        <li>SQLITE_INTERRUPT <span><a href="#er_SQLITE_INTERRUPT">(9)</a></span></li>
                        <li>SQLITE_IOERR <span><a href="#er_SQLITE_IOERR">(10)</a></span></li>
                        <li>SQLITE_LOCKED <span><a href="#er_SQLITE_LOCKED">(6)</a></span></li>
                        <li>SQLITE_MISMATCH <span><a href="#er_SQLITE_MISMATCH">(20)</a></span></li>
                        <li>SQLITE_MISUSE <span><a href="#er_SQLITE_MISUSE">(21)</a></span></li>
                        <li>SQLITE_NOLFS <span><a href="#er_SQLITE_NOLFS">(22)</a></span></li>
                        <li>SQLITE_NOMEM <span><a href="#er_SQLITE_NOMEM">(7)</a></span></li>
                        <li>SQLITE_NOTADB <span><a href="#er_SQLITE_NOTADB">(26)</a></span></li>
                        <li>SQLITE_NOTFOUND <span><a href="#er_SQLITE_NOTFOUND">(12)</a></span></li>
                        <li>SQLITE_NOTICE <span><a href="#er_SQLITE_NOTICE">(27)</a></span></li>
                    </ul>
                </td>
                <td class="table-w-30per">
                    <ul>
                        <li>SQLITE_OK <span><a href="#er_SQLITE_OK">(0)</a></span></li>
                        <li>SQLITE_PERM <span><a href="#er_SQLITE_PERM">(3)</a></span></li>
                        <li>SQLITE_PROTOCOL <span><a href="#er_SQLITE_PROTOCOL">(15)</a></span></li>
                        <li>SQLITE_RANGE <span><a href="#er_SQLITE_RANGE">(25)</a></span></li>
                        <li>SQLITE_READONLY <span><a href="#er_SQLITE_READONLY">(8)</a></span></li>
                        <li>SQLITE_ROW <span><a href="#er_SQLITE_ROW">(100)</a></span></li>
                        <li>SQLITE_SCHEMA <span><a href="#er_SQLITE_SCHEMA">(17)</a></span></li>
                        <li>SQLITE_TOOBIG <span><a href="#er_SQLITE_TOOBIG">(18)</a></span></li>
                        <li>SQLITE_WARNING <span><a href="#er_SQLITE_WARNING">(28)</a></span></li>
                    </ul>
                </td>
            </tr>
        </table>
        <h2>5. Расширенный список кодов результатов </h2>
        <p>71 расширенный код результата определены в sqlite3.h и перечислены в алфавитном порядке ниже: </p>
        <table>
            <tr>
                <td class="table-en-ru">
                    <ul>
                        <li>SQLITE_ABORT_ROLLBACK <span><a href="#er_">()</a></span>(516)</li>
                        <li>SQLITE_BUSY_RECOVERY <span><a href="#er_">()</a></span>(261)</li>
                        <li>SQLITE_BUSY_SNAPSHOT <span><a href="#er_">()</a></span>(517)</li>
                        <li>SQLITE_BUSY_TIMEOUT <span><a href="#er_">()</a></span>(773)</li>
                        <li>SQLITE_CANTOPEN_CONVPATH <span><a href="#er_">()</a></span>(1038)</li>
                        <li>SQLITE_CANTOPEN_DIRTYWAL <span><a href="#er_">()</a></span>(1294)</li>
                        <li>SQLITE_CANTOPEN_FULLPATH <span><a href="#er_">()</a></span>(782)</li>
                        <li>SQLITE_CANTOPEN_ISDIR <span><a href="#er_">()</a></span>(526)</li>
                        <li>SQLITE_CANTOPEN_NOTEMPDIR <span><a href="#er_">()</a></span>(270)</li>
                        <li>SQLITE_CANTOPEN_SYMLINK <span><a href="#er_">()</a></span>(1550)</li>
                        <li>SQLITE_CONSTRAINT_CHECK <span><a href="#er_">()</a></span>(275)</li>
                        <li>SQLITE_CONSTRAINT_COMMITHOOK <span><a href="#er_">()</a></span>(531)</li>
                        <li>SQLITE_CONSTRAINT_FOREIGNKEY <span><a href="#er_">()</a></span>(787)</li>
                        <li>SQLITE_CONSTRAINT_FUNCTION <span><a href="#er_">()</a></span>(1043)</li>
                        <li>SQLITE_CONSTRAINT_NOTNULL <span><a href="#er_">()</a></span>(1299)</li>
                        <li>SQLITE_CONSTRAINT_PINNED <span><a href="#er_">()</a></span>(2835)</li>
                        <li>SQLITE_CONSTRAINT_PRIMARYKEY <span><a href="#er_">()</a></span>(1555)</li>
                        <li>SQLITE_CONSTRAINT_ROWID <span><a href="#er_">()</a></span>(2579)</li>
                        <li>SQLITE_CONSTRAINT_TRIGGER <span><a href="#er_">()</a></span>(1811)</li>
                        <li>SQLITE_CONSTRAINT_UNIQUE <span><a href="#er_">()</a></span>(2067)</li>
                        <li>SQLITE_CONSTRAINT_VTAB <span><a href="#er_">()</a></span>(2323)</li>
                        <li>SQLITE_CORRUPT_INDEX <span><a href="#er_">()</a></span>(779)</li>
                        <li>SQLITE_CORRUPT_SEQUENCE <span><a href="#er_">()</a></span>(523)</li>
                        <li>SQLITE_CORRUPT_VTAB <span><a href="#er_">()</a></span>(267)</li>
                        <li>SQLITE_ERROR_MISSING_COLLSEQ <span><a href="#er_">()</a></span>(257)</li>
                        <li>SQLITE_ERROR_RETRY <span><a href="#er_">()</a></span>(513)</li>
                        <li>SQLITE_ERROR_SNAPSHOT <span><a href="#er_">()</a></span>(769)</li>
                        <li>SQLITE_IOERR_ACCESS <span><a href="#er_">()</a></span>(3338)</li>
                        <li>SQLITE_IOERR_AUTH <span><a href="#er_">()</a></span>(7178)</li>
                        <li>SQLITE_IOERR_BEGIN_ATOMIC <span><a href="#er_">()</a></span>(7434)</li>
                        <li>SQLITE_IOERR_BLOCKED <span><a href="#er_">()</a></span>(2826)</li>
                        <li>SQLITE_IOERR_CHECKRESERVEDLOCK <span><a href="#er_">()</a></span>(3594)</li>
                        <li>SQLITE_IOERR_CLOSE <span><a href="#er_">()</a></span>(4106)</li>
                        <li>SQLITE_IOERR_COMMIT_ATOMIC <span><a href="#er_">()</a></span>(7690)</li>
                        <li>SQLITE_IOERR_CONVPATH <span><a href="#er_">()</a></span>(6666)</li>
                        <li>SQLITE_IOERR_DATA <span><a href="#er_">()</a></span>(8202)</li>
                    </ul>
                </td>
                <td class="table-en-ru">
                    <ul>
                        <li>SQLITE_IOERR_DELETE <span><a href="#er_">()</a></span>(2570)</li>
                        <li>SQLITE_IOERR_DELETE_NOENT <span><a href="#er_">()</a></span>(5898)</li>
                        <li>SQLITE_IOERR_DIR_CLOSE <span><a href="#er_">()</a></span>(4362)</li>
                        <li>SQLITE_IOERR_DIR_FSYNC <span><a href="#er_">()</a></span>(1290)</li>
                        <li>SQLITE_IOERR_FSTAT <span><a href="#er_">()</a></span>(1802)</li>
                        <li>SQLITE_IOERR_FSYNC <span><a href="#er_">()</a></span>(1034)</li>
                        <li>SQLITE_IOERR_GETTEMPPATH <span><a href="#er_">()</a></span>(6410)</li>
                        <li>SQLITE_IOERR_LOCK <span><a href="#er_">()</a></span>(3850)</li>
                        <li>SQLITE_IOERR_MMAP <span><a href="#er_">()</a></span>(6154)</li>
                        <li>SQLITE_IOERR_NOMEM <span><a href="#er_">()</a></span>(3082)</li>
                        <li>SQLITE_IOERR_RDLOCK <span><a href="#er_">()</a></span>(2314)</li>
                        <li>SQLITE_IOERR_READ <span><a href="#er_">()</a></span>(266)</li>
                        <li>SQLITE_IOERR_ROLLBACK_ATOMIC <span><a href="#er_">()</a></span>(7946)</li>
                        <li>SQLITE_IOERR_SEEK <span><a href="#er_">()</a></span>(5642)</li>
                        <li>SQLITE_IOERR_SHMLOCK <span><a href="#er_">()</a></span>(5130)</li>
                        <li>SQLITE_IOERR_SHMMAP <span><a href="#er_">()</a></span>(5386)</li>
                        <li>SQLITE_IOERR_SHMOPEN <span><a href="#er_">()</a></span>(4618)</li>
                        <li>SQLITE_IOERR_SHMSIZE <span><a href="#er_">()</a></span>(4874)</li>
                        <li>SQLITE_IOERR_SHORT_READ <span><a href="#er_">()</a></span>(522)</li>
                        <li>SQLITE_IOERR_TRUNCATE <span><a href="#er_">()</a></span>(1546)</li>
                        <li>SQLITE_IOERR_UNLOCK <span><a href="#er_">()</a></span>(2058)</li>
                        <li>SQLITE_IOERR_VNODE <span><a href="#er_">()</a></span>(6922)</li>
                        <li>SQLITE_IOERR_WRITE <span><a href="#er_">()</a></span>(778)</li>
                        <li>SQLITE_LOCKED_SHAREDCACHE <span><a href="#er_">()</a></span>(262)</li>
                        <li>SQLITE_LOCKED_VTAB <span><a href="#er_">()</a></span>(518)</li>
                        <li>SQLITE_NOTICE_RECOVER_ROLLBACK <span><a href="#er_">()</a></span>(539)</li>
                        <li>SQLITE_NOTICE_RECOVER_WAL <span><a href="#er_">()</a></span>(283)</li>
                        <li>SQLITE_OK_LOAD_PERMANENTLY <span><a href="#er_">()</a></span>(256)</li>
                        <li>SQLITE_READONLY_CANTINIT <span><a href="#er_">()</a></span>(1288)</li>
                        <li>SQLITE_READONLY_CANTLOCK <span><a href="#er_">()</a></span>(520)</li>
                        <li>SQLITE_READONLY_DBMOVED <span><a href="#er_">()</a></span>(1032)</li>
                        <li>SQLITE_READONLY_DIRECTORY <span><a href="#er_">()</a></span>(1544)</li>
                        <li>SQLITE_READONLY_RECOVERY <span><a href="#er_">()</a></span>(264)</li>
                        <li>SQLITE_READONLY_ROLLBACK <span><a href="#er_">()</a></span>(776)</li>
                        <li>SQLITE_WARNING_AUTOINDEX <span><a href="#er_">()</a></span>(284)</li>
                    </ul>
                </td>
            </tr>
        </table>
        <h2>6. Значение кода результата</h2>
        <p>Значения для всех 102 значений кода результата показаны ниже в числовом порядке. </p>
        <table>
            <tr>
                <th class="table-w-5per">Числовой код</th>
                <th class="table-w-20per">Символьный код</th>
                <th class="table-w-80per">Расшифровка</th>
            </tr>
            <tr>
                <td id="er_SQLITE_OK">0</td>
                <td>SQLITE_OK</td>
                <td>Операция прошла успешно и ошибок не было. Большинство других кодов результатов указывают на ошибку. </td>
            </tr>
            <tr>
                <td id="er_SQLITE_ERROR">1</td>
                <td>SQLITE_ERROR</td>
                <td>Это общий код ошибки, который используется, когда другой более конкретный код ошибки недоступен. </td>
            </tr>
            <tr>
                <td id="er_SQLITE_INTERNAL">2</td>
                <td>SQLITE_INTERNAL</td>
                <td>
                    <p>Указывает на внутреннюю неисправность. В рабочей версии SQLite приложение никогда не должно видеть этот код результата. Если приложение обнаруживает этот результирующий код, это означает, что в ядре базы данных есть ошибка.</p>
                    <p>SQLite в настоящее время не генерирует этот код результата. Однако определяемые приложением функции SQL или виртуальные таблицы, виртуальные файловые системы или другие расширения могут привести к возврату этого кода результата.</p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_PERM">3</td>
                <td>SQLITE_PERM</td>
                <td>Указывает, что запрошенный режим доступа для вновь созданной базы данных не может быть предоставлен. </td>
            </tr>
            <tr>
                <td id="er_SQLITE_ABORT">4</td>
                <td>SQLITE_ABORT</td>
                <td>
                    <p>Указывает, что операция была прервана до завершения, обычно это запрос приложения. См. Также: SQLITE_INTERRUPT.</p>
                    <p>Если функция обратного вызова sqlite3_exec() возвращает ненулевое значение, тогда sqlite3_exec() вернет SQLITE_ABORT.</p>
                    <p>Если операция ROLLBACK происходит в том же соединении с базой данных, что и ожидающее чтение или запись, то ожидающее чтение или запись может завершиться ошибкой SQLITE_ABORT или SQLITE_ABORT_ROLLBACK.</p>
                    <p>Помимо кода результата, значение SQLITE_ABORT также используется в качестве режима разрешения конфликтов, возвращаемого интерфейсом sqlite3_vtab_on_conflict().</p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_BUSY">5</td>
                <td>SQLITE_BUSY</td>
                <td>
                    <p>Указывает, что файл базы данных не может быть записан (или в некоторых случаях прочитан) из-за одновременной активности какого-либо другого соединения с базой данных, обычно соединения с базой данных в отдельном процессе.
                    </p>
                    <p>Например, если процесс A находится в середине большой транзакции записи и в то же время процесс B пытается начать новую транзакцию записи, процесс B вернет результат SQLITE_BUSY, потому что SQLite поддерживает только одну запись за
                        раз. Процессу B нужно будет дождаться, пока процесс A завершит свою транзакцию, прежде чем начинать новую транзакцию. Интерфейсы sqlite3_busy_timeout () и sqlite3_busy_handler () и прагма busy_timeout доступны для процесса B, чтобы
                        помочь ему справиться с ошибками SQLITE_BUSY.</p>
                    <p>Ошибка SQLITE_BUSY может возникнуть в любой момент транзакции: при первом запуске транзакции, во время любых операций записи или обновления или при фиксации транзакции. Чтобы избежать ошибок SQLITE_BUSY в середине транзакции, приложение
                        может использовать BEGIN IMMEDIATE вместо просто BEGIN для запуска транзакции. Команда BEGIN IMMEDIATE может сама вернуть SQLITE_BUSY, но в случае успеха SQLite гарантирует, что никакие последующие операции с той же базой данных
                        через следующий COMMIT не вернут SQLITE_BUSY.</p>
                    <p>См. Также: <span><a href="er_SQLITE_BUSY_RECOVERY">SQLITE_BUSY_RECOVERY</a></span> и <span><a href="er_SQLITE_BUSY_RECOVERY">SQLITE_BUSY_SNAPSHOT</a></span>. </p>
                    <p>Код результата SQLITE_BUSY отличается от <span><a href="er_SQLITE_LOCKED">SQLITE_LOCKED</a></span> тем, что SQLITE_BUSY указывает на конфликт с отдельным соединением с базой данных, вероятно, в отдельном процессе, тогда как <span><a href="er_SQLITE_LOCKED">SQLITE_LOCKED</a></span>                        указывает на конфликт внутри того же соединения с базой данных (или иногда соединения с базой данных с общим кешем). </p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_LOCKED">6</td>
                <td>SQLITE_LOCKED</td>
                <td>
                    <p>Указывает, что операция записи не может быть продолжена из-за конфликта внутри того же соединения с базой данных или конфликта с другим соединением с базой данных, которое использует общий кэш.</p>
                    <p>Например, оператор DROP TABLE не может быть запущен, пока другой поток читает из этой таблицы в том же соединении с базой данных, потому что удаление таблицы приведет к удалению таблицы из-под одновременного чтения.</p>
                    <p>Код результата SQLITE_LOCKED отличается от <span><a href="er_SQLITE_BUSY">SQLITE_BUSY</a></span> тем, что SQLITE_LOCKED указывает на конфликт в том же соединении с базой данных (или в соединении с общим кешем), тогда как <span><a href="er_SQLITE_BUSY">SQLITE_BUSY</a></span>                        указывает на конфликт с другим соединением с базой данных, возможно, в другом процессе. </p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_NOMEM">7</td>
                <td>SQLITE_NOMEM</td>
                <td>
                    <p>Указывает, что SQLite не смог выделить всю память, необходимую для завершения операции. Другими словами, внутренний вызов sqlite3_malloc () или sqlite3_realloc () завершился неудачно в случае, когда выделяемая память требовалась для
                        продолжения операции. </p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_READONLY">8</td>
                <td>SQLITE_READONLY</td>
                <td>
                    <p>Возвращается, когда делается попытка изменить некоторые данные, для которых текущее соединение с базой данных не имеет разрешения на запись. </p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_INTERRUPT">9</td>
                <td>SQLITE_INTERRUPT</td>
                <td>
                    <p>Указывает, что операция была прервана интерфейсом sqlite3_interrupt(). См. Также: <span><a href="er_SQLITE_ABORT">SQLITE_ABORT</a></span></p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_IOERR">10</td>
                <td>SQLITE_IOERR</td>
                <td>
                    <p>Сообщает, что операция не может быть завершена, поскольку операционная система сообщила об ошибке ввода-вывода.</p>
                    <p>Полный диск обычно дает ошибку <span><a href="er_SQLITE_FULL">SQLITE_FULL</a></span>, а не ошибку SQLITE_IOERR.</p>
                    <p>Существует множество различных расширенных кодов результатов для ошибок ввода-вывода, которые идентифицируют конкретную операцию ввода-вывода, в которой произошел сбой. </p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_CORRUPT">11</td>
                <td>SQLITE_CORRUPT</td>
                <td>
                    <p>Указывает, что файл базы данных был поврежден. См. Раздел «Как повредить файлы базы данных» для дальнейшего обсуждения того, как может произойти повреждение. </p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_NOTFOUND">12</td>
                <td>SQLITE_NOTFOUND</td>
                <td>
                    <p>Используется в двух контекстах. SQLITE_NOTFOUND может быть возвращен интерфейсом sqlite3_file_control(), чтобы указать, что код операции управления файлом, переданный в качестве третьего аргумента, не был распознан базовой VFS. SQLITE_NOTFOUND
                        также может быть возвращен методом xSetSystemCall() объекта sqlite3_vfs.</p>
                    <p>Код результата SQLITE_NOTFOUND также используется внутри реализации SQLite, но это внутреннее использование не предоставляется приложению. </p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_FULL">13</td>
                <td>SQLITE_FULL</td>
                <td>
                    <p>Указывает, что запись не может быть завершена из-за переполнения диска. Обратите внимание, что эта ошибка может возникать при попытке записать информацию в основной файл базы данных или при записи во временные файлы на диске.</p>
                    <p>Иногда приложения сталкиваются с этой ошибкой, даже если первичного дискового пространства достаточно, поскольку ошибка возникает при записи во временные файлы на диске в системе, где временные файлы хранятся в отдельном разделе с
                        гораздо меньшим пространством, чем на первичном диске. </p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_CANTOPEN">14</td>
                <td>SQLITE_CANTOPEN</td>
                <td>
                    <p>Указывает, что SQLite не удалось открыть файл. Рассматриваемый файл может быть первичным файлом базы данных или одним из нескольких временных файлов на диске. </p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_PROTOCOL">15</td>
                <td>SQLITE_PROTOCOL</td>
                <td>
                    <p>Указывает на проблему с протоколом блокировки файлов, используемым SQLite. Ошибка SQLITE_PROTOCOL в настоящее время возвращается только при использовании режима WAL и попытке начать новую транзакцию. Когда два отдельных соединения
                        с базой данных пытаются одновременно запустить транзакцию в режиме WAL, возникает состояние гонки. Проигравший в гонке отступает и пытается снова после небольшой задержки. Если одно и то же соединение десятки раз проигрывает в
                        гонке блокировок в течение нескольких секунд, оно в конечном итоге откажется и вернет SQLITE_PROTOCOL. Ошибка SQLITE_PROTOCOL должна появляться на практике очень, очень редко и только тогда, когда существует множество отдельных
                        процессов, все из которых активно конкурируют за запись в одну и ту же базу данных. </p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_EMPTY">16</td>
                <td>SQLITE_EMPTY</td>
                <td>
                    <p>В настоящее время не используется.</p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_SCHEMA">17</td>
                <td>SQLITE_SCHEMA</td>
                <td>
                    <p>указывает, что схема базы данных изменилась. Этот код результата может быть возвращен из sqlite3_step() для подготовленного оператора, который был сгенерирован с помощью sqlite3_prepare() или sqlite3_prepare16(). Если схема базы данных
                        была изменена каким-либо другим процессом между временем подготовки оператора и временем его выполнения, может возникнуть эта ошибка.</p>
                    <p>Если подготовленный оператор генерируется из sqlite3_prepare_v2(), тогда оператор автоматически повторно готовится, если схема изменяется, до SQLITE_MAX_SCHEMA_RETRY раз (по умолчанию: 50). Интерфейс sqlite3_step() будет возвращать
                        SQLITE_SCHEMA обратно в приложение только в том случае, если сбой сохраняется после этих многочисленных попыток. </p>
                    <p></p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_TOOBIG">18</td>
                <td>SQLITE_TOOBIG</td>
                <td>
                    <p>Указывает, что строка или большой двоичный объект слишком большой. По умолчанию максимальная длина строки или большого двоичного объекта в SQLite составляет 1 000 000 000 байт. Эту максимальную длину можно изменить во время компиляции
                        с помощью параметра времени компиляции SQLITE_MAX_LENGTH или во время выполнения с помощью интерфейса sqlite3_limit(db, SQLITE_LIMIT_LENGTH, ...). Ошибка SQLITE_TOOBIG возникает, когда SQLite встречает строку или большой двоичный
                        объект, превышающий предел времени компиляции или времени выполнения.</p>
                    <p>Код ошибки SQLITE_TOOBIG также может возникать, когда оператор SQL слишком большого размера передается в один из интерфейсов sqlite3_prepare_v2(). По умолчанию максимальная длина оператора SQL намного меньше - 1000000 байтов. Максимальную
                        длину оператора SQL можно установить во время компиляции с помощью SQLITE_MAX_SQL_LENGTH или во время выполнения с помощью sqlite3_limit(db, SQLITE_LIMIT_SQL_LENGTH, ...). </p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_CONSTRAINT">19</td>
                <td>SQLITE_CONSTRAINT</td>
                <td>
                    <p>Означает, что при попытке обработать инструкцию SQL произошло нарушение ограничения SQL. Дополнительную информацию о невыполненном ограничении можно найти в сопроводительном сообщении об ошибке (возвращенном через sqlite3_errmsg()
                        или sqlite3_errmsg16()) или просмотрев расширенный код ошибки.</p>
                    <p>Код SQLITE_CONSTRAINT также может использоваться как возвращаемое значение из метода xBestIndex() реализации виртуальной таблицы. Когда xBestIndex() возвращает SQLITE_CONSTRAINT, это указывает на то, что конкретная комбинация входных
                        данных, отправленных в xBestIndex(), не может привести к пригодному для использования плану запроса и не должна рассматриваться в дальнейшем. </p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_MISMATCH">20</td>
                <td>SQLITE_MISMATCH</td>
                <td>
                    <p>Указывает на несоответствие типа данных.</p>
                    <p>SQLite обычно очень снисходительно относится к несоответствиям между типом значения и объявленным типом контейнера, в котором это значение должно храниться. Например, SQLite позволяет приложению хранить большой BLOB в столбце с объявленным
                        типом BOOLEAN. Но в некоторых случаях SQLite строго относится к типам. Ошибка SQLITE_MISMATCH возвращается в тех немногих случаях, когда типы не совпадают.</p>
                    <p>Идентификатор строки таблицы должен быть целым числом. Попытка установить для rowid любое значение, кроме целого (или NULL, которое будет автоматически преобразовано в следующий доступный целочисленный rowid), приводит к ошибке SQLITE_MISMATCH.</p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_MISUSE">21</td>
                <td>SQLITE_MISUSE</td>
                <td>
                    <p>Может быть возвращен, если приложение использует какой-либо интерфейс SQLite способом, который не определен или не поддерживается. Например, использование подготовленного оператора после того, как этот подготовленный оператор был завершен,
                        может привести к ошибке SQLITE_MISUSE.</p>
                    <p>SQLite пытается обнаружить неправильное использование и сообщить о неправильном использовании, используя этот код результата. Однако нет никакой гарантии, что обнаружение неправомерного использования будет успешным. Обнаружение злоупотреблений
                        является вероятностным. Приложения никогда не должны зависеть от возвращаемого значения SQLITE_MISUSE.</p>
                    <p>Если SQLite когда-либо возвращает SQLITE_MISUSE из любого интерфейса, это означает, что приложение неправильно закодировано и его необходимо исправить. Не отправляйте приложение, которое иногда возвращает SQLITE_MISUSE из стандартного
                        интерфейса SQLite, потому что это приложение содержит потенциально серьезные ошибки. </p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_NOLFS">22</td>
                <td>SQLITE_NOLFS</td>
                <td>
                    <p>Может возвращаться в системах, которые не поддерживают большие файлы, когда база данных становится больше, чем может обрабатывать файловая система. «NOLFS» означает «ОТСУТСТВИЕ поддержки больших файлов». </p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_AUTH">23</td>
                <td>SQLITE_AUTH</td>
                <td>
                    <p>Возвращается, когда обратный вызов авторизатора указывает, что подготавливаемый оператор SQL не авторизован.</p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_FORMAT">24</td>
                <td>SQLITE_FORMAT</td>
                <td>
                    <p>В настоящее время не используется SQLite. </p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_RANGE">25</td>
                <td>SQLITE_RANGE</td>
                <td>
                    <p>Указывает, что аргумент номера параметра для одной из подпрограмм sqlite3_bind или номер столбца в одной из подпрограмм sqlite3_column выходит за пределы допустимого диапазона. </p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_NOTADB">26</td>
                <td>SQLITE_NOTADB</td>
                <td>
                    <p>При попытке открыть файл ошибка SQLITE_NOTADB указывает, что открываемый файл не является файлом базы данных SQLite. </p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_NOTICE">27</td>
                <td>SQLITE_NOTICE</td>
                <td>
                    <p>Не возвращается ни одним интерфейсом C/C++. Однако SQLITE_NOTICE (или, скорее, один из его расширенных кодов ошибок) иногда используется в качестве первого аргумента в обратном вызове sqlite3_log(), чтобы указать, что происходит необычная
                        операция.
                    </p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_WARNING">28</td>
                <td>SQLITE_WARNING</td>
                <td>
                    <p>Не возвращается ни одним интерфейсом C/C++. Однако SQLITE_WARNING (или, скорее, один из его расширенных кодов ошибок) иногда используется в качестве первого аргумента в обратном вызове sqlite3_log(), чтобы указать, что имеет место
                        необычная и, возможно, непродуманная операция. </p>
                </td>
            </tr>
            <tr>
                <td id="er_"></td>
                <td></td>
                <td>
                    <p></p>
                    <p></p>
                </td>
            </tr>
            <tr>
                <td id="er_"></td>
                <td></td>
                <td>
                    <p></p>
                    <p></p>
                </td>
            </tr>
            <tr>
                <td id="er_"></td>
                <td></td>
                <td>
                    <p></p>
                    <p></p>
                </td>
            </tr>
            <tr>
                <td id="er_"></td>
                <td></td>
                <td>
                    <p></p>
                    <p></p>
                </td>
            </tr>
            <tr>
                <td id="er_"></td>
                <td></td>
                <td>
                    <p></p>
                    <p></p>
                </td>
            </tr>
            <tr>
                <td id="er_"></td>
                <td></td>
                <td>
                    <p></p>
                    <p></p>
                </td>
            </tr>
            <tr>
                <td id="er_"></td>
                <td></td>
                <td>
                    <p></p>
                    <p></p>
                </td>
            </tr>
            <tr>
                <td id="er_"></td>
                <td></td>
                <td>
                    <p></p>
                    <p></p>
                </td>
            </tr>
            <tr>
                <td id="er_"></td>
                <td></td>
                <td>
                    <p></p>
                    <p></p>
                </td>
            </tr>
            <tr>
                <td id="er_"></td>
                <td></td>
                <td>
                    <p></p>
                    <p></p>
                </td>
            </tr>
            <tr>
                <td id="er_"></td>
                <td></td>
                <td>
                    <p></p>
                    <p></p>
                </td>
            </tr>
            <tr>
                <td id="er_"></td>
                <td></td>
                <td>
                    <p></p>
                    <p></p>
                </td>
            </tr>
            <tr>
                <td id="er_"></td>
                <td></td>
                <td>
                    <p></p>
                    <p></p>
                </td>
            </tr>
            <tr>
                <td id="er_"></td>
                <td></td>
                <td>
                    <p></p>
                    <p></p>
                </td>
            </tr>
            <tr>
                <td id="er_"></td>
                <td></td>
                <td>
                    <p></p>
                    <p></p>
                </td>
            </tr>
            <tr>
                <td id="er_"></td>
                <td></td>
                <td>
                    <p></p>
                    <p></p>
                </td>
            </tr>
            <tr>
                <td id="er_"></td>
                <td></td>
                <td>
                    <p></p>
                    <p></p>
                </td>
            </tr>
            <tr>
                <td id="er_"></td>
                <td></td>
                <td>
                    <p></p>
                    <p></p>
                </td>
            </tr>
            <tr>
                <td id="er_"></td>
                <td></td>
                <td>
                    <p></p>
                    <p></p>
                </td>
            </tr>
            <tr>
                <td id="er_"></td>
                <td></td>
                <td>
                    <p></p>
                    <p></p>
                </td>
            </tr>
            <tr>
                <td id="er_"></td>
                <td></td>
                <td>
                    <p></p>
                    <p></p>
                </td>
            </tr>
            <tr>
                <td id="er_"></td>
                <td></td>
                <td>
                    <p></p>
                    <p></p>
                </td>
            </tr>
            <tr>
                <td id="er_"></td>
                <td></td>
                <td>
                    <p></p>
                    <p></p>
                </td>
            </tr>
            <tr>
                <td id="er_"></td>
                <td></td>
                <td>
                    <p></p>
                    <p></p>
                </td>
            </tr>
            <tr>
                <td id="er_"></td>
                <td></td>
                <td>
                    <p></p>
                    <p></p>
                </td>
            </tr>
            <tr>
                <td id="er_"></td>
                <td></td>
                <td>
                    <p></p>
                    <p></p>
                </td>
            </tr>
            <tr>
                <td id="er_"></td>
                <td></td>
                <td>
                    <p></p>
                    <p></p>
                </td>
            </tr>
            <tr>
                <td id="er_"></td>
                <td></td>
                <td>
                    <p></p>
                    <p></p>
                </td>
            </tr>
            <tr>
                <td id="er_"></td>
                <td></td>
                <td>
                    <p></p>
                    <p></p>
                </td>
            </tr>
            <tr>
                <td id="er_"></td>
                <td></td>
                <td>
                    <p></p>
                    <p></p>
                </td>
            </tr>
            <tr>
                <td id="er_"></td>
                <td></td>
                <td>
                    <p></p>
                    <p></p>
                </td>
            </tr>
            <tr>
                <td id="er_"></td>
                <td></td>
                <td>
                    <p></p>
                    <p></p>
                </td>
            </tr>
            <tr>
                <td id="er_"></td>
                <td></td>
                <td>
                    <p></p>
                    <p></p>
                </td>
            </tr>
            <tr>
                <td id="er_"></td>
                <td></td>
                <td>
                    <p></p>
                    <p></p>
                </td>
            </tr>
            <tr>
                <td id="er_"></td>
                <td></td>
                <td>
                    <p></p>
                    <p></p>
                </td>
            </tr>
            <tr>
                <td id="er_"></td>
                <td></td>
                <td>
                    <p></p>
                    <p></p>
                </td>
            </tr>
            <tr>
                <td id="er_"></td>
                <td></td>
                <td>
                    <p></p>
                    <p></p>
                </td>
            </tr>
            <tr>
                <td id="er_"></td>
                <td></td>
                <td>
                    <p></p>
                    <p></p>
                </td>
            </tr>
            <tr>
                <td id="er_"></td>
                <td></td>
                <td>
                    <p></p>
                    <p></p>
                </td>
            </tr>
            <tr>
                <td id="er_"></td>
                <td></td>
                <td>
                    <p></p>
                    <p></p>
                </td>
            </tr>
            <tr>
                <td id="er_"></td>
                <td></td>
                <td>
                    <p></p>
                    <p></p>
                </td>
            </tr>
            <tr>
                <td id="er_"></td>
                <td></td>
                <td>
                    <p></p>
                    <p></p>
                </td>
            </tr>
            <tr>
                <td id="er_"></td>
                <td></td>
                <td>
                    <p></p>
                    <p></p>
                </td>
            </tr>
            <tr>
                <td id="er_"></td>
                <td></td>
                <td>
                    <p></p>
                    <p></p>
                </td>
            </tr>
            <tr>
                <td id="er_"></td>
                <td></td>
                <td>
                    <p></p>
                    <p></p>
                </td>
            </tr>
            <tr>
                <td id="er_"></td>
                <td></td>
                <td>
                    <p></p>
                    <p></p>
                </td>
            </tr>
            <tr>
                <td id="er_"></td>
                <td></td>
                <td>
                    <p></p>
                    <p></p>
                </td>
            </tr>
            <tr>
                <td id="er_"></td>
                <td></td>
                <td>
                    <p></p>
                    <p></p>
                </td>
            </tr>
            <tr>
                <td id="er_"></td>
                <td></td>
                <td>
                    <p></p>
                    <p></p>
                </td>
            </tr>
            <tr>
                <td id="er_"></td>
                <td></td>
                <td>
                    <p></p>
                    <p></p>
                </td>
            </tr>
            <tr>
                <td id="er_"></td>
                <td></td>
                <td>
                    <p></p>
                    <p></p>
                </td>
            </tr>
            <tr>
                <td id="er_"></td>
                <td></td>
                <td>
                    <p></p>
                    <p></p>
                </td>
            </tr>
            <tr>
                <td id="er_"></td>
                <td></td>
                <td>
                    <p></p>
                    <p></p>
                </td>
            </tr>
            <tr>
                <td id="er_"></td>
                <td></td>
                <td>
                    <p></p>
                    <p></p>
                </td>
            </tr>
            <tr>
                <td id="er_"></td>
                <td></td>
                <td>
                    <p></p>
                    <p></p>
                </td>
            </tr>
            <tr>
                <td id="er_"></td>
                <td></td>
                <td>
                    <p></p>
                    <p></p>
                </td>
            </tr>
            <tr>
                <td id="er_"></td>
                <td></td>
                <td>
                    <p></p>
                    <p></p>
                </td>
            </tr>
            <tr>
                <td id="er_"></td>
                <td></td>
                <td>
                    <p></p>
                    <p></p>
                </td>
            </tr>
            <tr>
                <td id="er_"></td>
                <td></td>
                <td>
                    <p></p>
                    <p></p>
                </td>
            </tr>
            <tr>
                <td id="er_"></td>
                <td></td>
                <td>
                    <p></p>
                    <p></p>
                </td>
            </tr>
            <tr>
                <td id="er_"></td>
                <td></td>
                <td>
                    <p></p>
                    <p></p>
                </td>
            </tr>
            <tr>
                <td id="er_"></td>
                <td></td>
                <td>
                    <p></p>
                    <p></p>
                </td>
            </tr>
            <tr>
                <td id="er_"></td>
                <td></td>
                <td>
                    <p></p>
                    <p></p>
                </td>
            </tr>
            <tr>
                <td id="er_"></td>
                <td></td>
                <td>
                    <p></p>
                    <p></p>
                </td>
            </tr>
        </table>
        <p></p>
        <p><a href="./00_06.html">***&rArr;</a></p>
    </div>
</body>