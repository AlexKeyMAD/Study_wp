<head>
    <link rel="stylesheet" href="../../../css/books_style.css">
</head>

<body>
    <div>
        <p><a href="./00_04.html">&lArr;Справочник по C/C++ API SQLite</a></p>
        <h1>Коды результатов и ошибок</h1>
        <h2>Описание значений числовых кодов результатов, возвращаемых различными интерфейсами C/C++.</h2>
        <hr>
        <h2>Обзор</h2>
        <p>Многие подпрограммы в интерфейсе на языке C SQLite возвращают числовые коды результатов, указывающие либо успех, либо неудачу, а в случае сбоя - некоторое представление о причине сбоя. Этот документ пытается объяснить, что означает каждый из этих
            числовых кодов результатов. </p>
        <h2>1. Коды результатов в сравнении с кодами ошибок </h2>
        <p>«Коды ошибок» - это подмножество «результирующих кодов», которые указывают на то, что что-то пошло не так. Есть только несколько кодов результатов без ошибок: SQLITE_OK, SQLITE_ROW и SQLITE_DONE. Термин «код ошибки» означает любой код результата,
            кроме этих трех. </p>
        <h2>2. Основные коды результатов по сравнению с кодами расширенных результатов </h2>
        <p>Коды результатов представляют собой 32-битные целые числа со знаком. Младшие 8 битов результирующего кода определяют широкую категорию и называются «первичным результирующим кодом». Более значимые биты предоставляют более подробную информацию
            об ошибке и называются «расширенным кодом результата».</p>
        <p>Обратите внимание, что основной код результата всегда является частью расширенного кода результата. Учитывая полный 32-битный расширенный код результата, приложение всегда может найти соответствующий первичный код результата, просто извлекая 8
            младших битов расширенного кода результата.</p>
        <p>Все расширенные коды результатов также являются кодами ошибок. Следовательно, термины «расширенный код результата» и «расширенный код ошибки» взаимозаменяемы.</p>
        <p>Для исторической совместимости интерфейсы на языке C по умолчанию возвращают первичные коды результатов. Расширенный код результата для самой последней ошибки можно получить с помощью интерфейса sqlite3_extended_errcode(). Интерфейс sqlite3_extended_result_codes()
            можно использовать для перевода соединения с базой данных в режим, в котором он возвращает расширенные коды результатов вместо основных кодов результатов. </p>
        <h2>3. Определения</h2>
        <p>Все коды результатов являются целыми числами. Символические имена для всех результирующих кодов создаются с помощью макроса «#define» в заголовочном файле sqlite3.h. В заголовочном файле sqlite3.h есть отдельные разделы для определений кода результата
            и расширенных определений кода результата.</p>
        <p>Символьные имена первичного кода результата имеют форму «SQLITE_XXXXXX», где XXXXXX - это последовательность букв в верхнем регистре. Имена расширенных кодов результатов имеют форму «SQLITE_XXXXXX_YYYYYYY», где часть XXXXXX - это соответствующий
            первичный код результата, а YYYYYYY - это расширение, которое дополнительно классифицирует код результата.</p>
        <p>Имена и числовые значения для существующих кодов результатов являются фиксированными и неизменными. Однако новые коды результатов и особенно новые расширенные коды результатов могут появиться в будущих выпусках SQLite. </p>
        <h2>4. Список первичных кодов результатов</h2>
        <p>31 код результата определены в sqlite3.h и перечислены в алфавитном порядке ниже:</p>
        <table>
            <tr>
                <td class="table-w-30per">
                    <ul>
                        <li>SQLITE_ABORT <span><a href="#er_SQLITE_ABORT">(4)</a></span></li>
                        <li>SQLITE_AUTH <span><a href="#er_SQLITE_AUTH">(23)</a></span></li>
                        <li>SQLITE_BUSY <span><a href="#er_SQLITE_BUSY">(5)</a></span></li>
                        <li>SQLITE_CANTOPEN <span><a href="#er_SQLITE_CANTOPEN">(14)</a></span></li>
                        <li>SQLITE_CONSTRAINT <span><a href="#er_SQLITE_CONSTRAINT">(19)</a></span></li>
                        <li>SQLITE_CORRUPT <span><a href="#er_SQLITE_CORRUPT">(11)</a></span></li>
                        <li>SQLITE_DONE <span><a href="#er_SQLITE_DONE">(101)</a></span></li>
                        <li>SQLITE_EMPTY <span><a href="#er_SQLITE_EMPTY">(16)</a></span></li>
                        <li>SQLITE_ERROR <span><a href="#er_SQLITE_ERROR">(1)</a></span></li>
                        <li>SQLITE_FORMAT <span><a href="#er_SQLITE_FORMAT">(24)</a></span></li>
                        <li>SQLITE_FULL <span><a href="#er_SQLITE_FULL">(13)</a></span></li>
                    </ul>
                </td>
                <td class="table-w-30per">
                    <ul>
                        <li>SQLITE_INTERNAL <span><a href="#er_SQLITE_INTERNAL">(2)</a></span></li>
                        <li>SQLITE_INTERRUPT <span><a href="#er_SQLITE_INTERRUPT">(9)</a></span></li>
                        <li>SQLITE_IOERR <span><a href="#er_SQLITE_IOERR">(10)</a></span></li>
                        <li>SQLITE_LOCKED <span><a href="#er_SQLITE_LOCKED">(6)</a></span></li>
                        <li>SQLITE_MISMATCH <span><a href="#er_SQLITE_MISMATCH">(20)</a></span></li>
                        <li>SQLITE_MISUSE <span><a href="#er_SQLITE_MISUSE">(21)</a></span></li>
                        <li>SQLITE_NOLFS <span><a href="#er_SQLITE_NOLFS">(22)</a></span></li>
                        <li>SQLITE_NOMEM <span><a href="#er_SQLITE_NOMEM">(7)</a></span></li>
                        <li>SQLITE_NOTADB <span><a href="#er_SQLITE_NOTADB">(26)</a></span></li>
                        <li>SQLITE_NOTFOUND <span><a href="#er_SQLITE_NOTFOUND">(12)</a></span></li>
                        <li>SQLITE_NOTICE <span><a href="#er_SQLITE_NOTICE">(27)</a></span></li>
                    </ul>
                </td>
                <td class="table-w-30per">
                    <ul>
                        <li>SQLITE_OK <span><a href="#er_SQLITE_OK">(0)</a></span></li>
                        <li>SQLITE_PERM <span><a href="#er_SQLITE_PERM">(3)</a></span></li>
                        <li>SQLITE_PROTOCOL <span><a href="#er_SQLITE_PROTOCOL">(15)</a></span></li>
                        <li>SQLITE_RANGE <span><a href="#er_SQLITE_RANGE">(25)</a></span></li>
                        <li>SQLITE_READONLY <span><a href="#er_SQLITE_READONLY">(8)</a></span></li>
                        <li>SQLITE_ROW <span><a href="#er_SQLITE_ROW">(100)</a></span></li>
                        <li>SQLITE_SCHEMA <span><a href="#er_SQLITE_SCHEMA">(17)</a></span></li>
                        <li>SQLITE_TOOBIG <span><a href="#er_SQLITE_TOOBIG">(18)</a></span></li>
                        <li>SQLITE_WARNING <span><a href="#er_SQLITE_WARNING">(28)</a></span></li>
                    </ul>
                </td>
            </tr>
        </table>
        <h2>5. Расширенный список кодов результатов </h2>
        <p>71 расширенный код результата определены в sqlite3.h и перечислены в алфавитном порядке ниже: </p>
        <table>
            <tr>
                <td class="table-en-ru">
                    <ul>
                        <li>SQLITE_ABORT_ROLLBACK <span><a href="#er_SQLITE_ABORT_ROLLBACK">(516)</a></span></li>
                        <li>SQLITE_BUSY_RECOVERY <span><a href="#er_SQLITE_BUSY_RECOVERY">(261)</a></span></li>
                        <li>SQLITE_BUSY_SNAPSHOT <span><a href="#er_SQLITE_BUSY_SNAPSHOT">(517)</a></span></li>
                        <li>SQLITE_BUSY_TIMEOUT <span><a href="#er_">()</a></span>(773)</li>
                        <li>SQLITE_CANTOPEN_CONVPATH <span><a href="#er_">()</a></span>(1038)</li>
                        <li>SQLITE_CANTOPEN_DIRTYWAL <span><a href="#er_">()</a></span>(1294)</li>
                        <li>SQLITE_CANTOPEN_FULLPATH <span><a href="#er_">()</a></span>(782)</li>
                        <li>SQLITE_CANTOPEN_ISDIR <span><a href="#er_">()</a></span>(526)</li>
                        <li>SQLITE_CANTOPEN_NOTEMPDIR <span><a href="#er_">()</a></span>(270)</li>
                        <li>SQLITE_CANTOPEN_SYMLINK <span><a href="#er_">()</a></span>(1550)</li>
                        <li>SQLITE_CONSTRAINT_CHECK <span><a href="#er_">()</a></span>(275)</li>
                        <li>SQLITE_CONSTRAINT_COMMITHOOK <span><a href="#er_">()</a></span>(531)</li>
                        <li>SQLITE_CONSTRAINT_FOREIGNKEY <span><a href="#er_">()</a></span>(787)</li>
                        <li>SQLITE_CONSTRAINT_FUNCTION <span><a href="#er_">()</a></span>(1043)</li>
                        <li>SQLITE_CONSTRAINT_NOTNULL <span><a href="#er_">()</a></span>(1299)</li>
                        <li>SQLITE_CONSTRAINT_PINNED <span><a href="#er_">()</a></span>(2835)</li>
                        <li>SQLITE_CONSTRAINT_PRIMARYKEY <span><a href="#er_">()</a></span>(1555)</li>
                        <li>SQLITE_CONSTRAINT_ROWID <span><a href="#er_">()</a></span>(2579)</li>
                        <li>SQLITE_CONSTRAINT_TRIGGER <span><a href="#er_">()</a></span>(1811)</li>
                        <li>SQLITE_CONSTRAINT_UNIQUE <span><a href="#er_">()</a></span>(2067)</li>
                        <li>SQLITE_CONSTRAINT_VTAB <span><a href="#er_">()</a></span>(2323)</li>
                        <li>SQLITE_CORRUPT_INDEX <span><a href="#er_">()</a></span>(779)</li>
                        <li>SQLITE_CORRUPT_SEQUENCE <span><a href="#er_">()</a></span>(523)</li>
                        <li>SQLITE_CORRUPT_VTAB <span><a href="#er_">()</a></span>(267)</li>
                        <li>SQLITE_ERROR_MISSING_COLLSEQ <span><a href="#er_">()</a></span>(257)</li>
                        <li>SQLITE_ERROR_RETRY <span><a href="#er_">()</a></span>(513)</li>
                        <li>SQLITE_ERROR_SNAPSHOT <span><a href="#er_">()</a></span>(769)</li>
                        <li>SQLITE_IOERR_ACCESS <span><a href="#er_">()</a></span>(3338)</li>
                        <li>SQLITE_IOERR_AUTH <span><a href="#er_">()</a></span>(7178)</li>
                        <li>SQLITE_IOERR_BEGIN_ATOMIC <span><a href="#er_">()</a></span>(7434)</li>
                        <li>SQLITE_IOERR_BLOCKED <span><a href="#er_">()</a></span>(2826)</li>
                        <li>SQLITE_IOERR_CHECKRESERVEDLOCK <span><a href="#er_">()</a></span>(3594)</li>
                        <li>SQLITE_IOERR_CLOSE <span><a href="#er_">()</a></span>(4106)</li>
                        <li>SQLITE_IOERR_COMMIT_ATOMIC <span><a href="#er_">()</a></span>(7690)</li>
                        <li>SQLITE_IOERR_CONVPATH <span><a href="#er_">()</a></span>(6666)</li>
                        <li>SQLITE_IOERR_DATA <span><a href="#er_">()</a></span>(8202)</li>
                    </ul>
                </td>
                <td class="table-en-ru">
                    <ul>
                        <li>SQLITE_IOERR_DELETE <span><a href="#er_">()</a></span>(2570)</li>
                        <li>SQLITE_IOERR_DELETE_NOENT <span><a href="#er_">()</a></span>(5898)</li>
                        <li>SQLITE_IOERR_DIR_CLOSE <span><a href="#er_">()</a></span>(4362)</li>
                        <li>SQLITE_IOERR_DIR_FSYNC <span><a href="#er_">()</a></span>(1290)</li>
                        <li>SQLITE_IOERR_FSTAT <span><a href="#er_">()</a></span>(1802)</li>
                        <li>SQLITE_IOERR_FSYNC <span><a href="#er_">()</a></span>(1034)</li>
                        <li>SQLITE_IOERR_GETTEMPPATH <span><a href="#er_">()</a></span>(6410)</li>
                        <li>SQLITE_IOERR_LOCK <span><a href="#er_">()</a></span>(3850)</li>
                        <li>SQLITE_IOERR_MMAP <span><a href="#er_">()</a></span>(6154)</li>
                        <li>SQLITE_IOERR_NOMEM <span><a href="#er_">()</a></span>(3082)</li>
                        <li>SQLITE_IOERR_RDLOCK <span><a href="#er_">()</a></span>(2314)</li>
                        <li>SQLITE_IOERR_READ <span><a href="#er_">()</a></span>(266)</li>
                        <li>SQLITE_IOERR_ROLLBACK_ATOMIC <span><a href="#er_">()</a></span>(7946)</li>
                        <li>SQLITE_IOERR_SEEK <span><a href="#er_">()</a></span>(5642)</li>
                        <li>SQLITE_IOERR_SHMLOCK <span><a href="#er_">()</a></span>(5130)</li>
                        <li>SQLITE_IOERR_SHMMAP <span><a href="#er_">()</a></span>(5386)</li>
                        <li>SQLITE_IOERR_SHMOPEN <span><a href="#er_">()</a></span>(4618)</li>
                        <li>SQLITE_IOERR_SHMSIZE <span><a href="#er_">()</a></span>(4874)</li>
                        <li>SQLITE_IOERR_SHORT_READ <span><a href="#er_">()</a></span>(522)</li>
                        <li>SQLITE_IOERR_TRUNCATE <span><a href="#er_">()</a></span>(1546)</li>
                        <li>SQLITE_IOERR_UNLOCK <span><a href="#er_">()</a></span>(2058)</li>
                        <li>SQLITE_IOERR_VNODE <span><a href="#er_">()</a></span>(6922)</li>
                        <li>SQLITE_IOERR_WRITE <span><a href="#er_">()</a></span>(778)</li>
                        <li>SQLITE_LOCKED_SHAREDCACHE <span><a href="#er_">()</a></span>(262)</li>
                        <li>SQLITE_LOCKED_VTAB <span><a href="#er_">()</a></span>(518)</li>
                        <li>SQLITE_NOTICE_RECOVER_ROLLBACK <span><a href="#er_">()</a></span>(539)</li>
                        <li>SQLITE_NOTICE_RECOVER_WAL <span><a href="#er_">()</a></span>(283)</li>
                        <li>SQLITE_OK_LOAD_PERMANENTLY <span><a href="#er_">()</a></span>(256)</li>
                        <li>SQLITE_READONLY_CANTINIT <span><a href="#er_">()</a></span>(1288)</li>
                        <li>SQLITE_READONLY_CANTLOCK <span><a href="#er_">()</a></span>(520)</li>
                        <li>SQLITE_READONLY_DBMOVED <span><a href="#er_">()</a></span>(1032)</li>
                        <li>SQLITE_READONLY_DIRECTORY <span><a href="#er_">()</a></span>(1544)</li>
                        <li>SQLITE_READONLY_RECOVERY <span><a href="#er_">()</a></span>(264)</li>
                        <li>SQLITE_READONLY_ROLLBACK <span><a href="#er_">()</a></span>(776)</li>
                        <li>SQLITE_WARNING_AUTOINDEX <span><a href="#er_">()</a></span>(284)</li>
                    </ul>
                </td>
            </tr>
        </table>
        <h2>6. Значение кода результата</h2>
        <p>Значения для всех 102 значений кода результата показаны ниже в числовом порядке. </p>
        <table>
            <tr>
                <th class="table-w-5per">Числовой код</th>
                <th class="table-w-20per">Символьный код</th>
                <th class="table-w-80per">Расшифровка</th>
            </tr>
            <tr>
                <td id="er_SQLITE_OK">0</td>
                <td>SQLITE_OK</td>
                <td>Операция прошла успешно и ошибок не было. Большинство других кодов результатов указывают на ошибку. </td>
            </tr>
            <tr>
                <td id="er_SQLITE_ERROR">1</td>
                <td>SQLITE_ERROR</td>
                <td>Это общий код ошибки, который используется, когда другой более конкретный код ошибки недоступен. </td>
            </tr>
            <tr>
                <td id="er_SQLITE_INTERNAL">2</td>
                <td>SQLITE_INTERNAL</td>
                <td>
                    <p>Указывает на внутреннюю неисправность. В рабочей версии SQLite приложение никогда не должно видеть этот код результата. Если приложение обнаруживает этот результирующий код, это означает, что в ядре базы данных есть ошибка.</p>
                    <p>SQLite в настоящее время не генерирует этот код результата. Однако определяемые приложением функции SQL или виртуальные таблицы, виртуальные файловые системы или другие расширения могут привести к возврату этого кода результата.</p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_PERM">3</td>
                <td>SQLITE_PERM</td>
                <td>Указывает, что запрошенный режим доступа для вновь созданной базы данных не может быть предоставлен. </td>
            </tr>
            <tr>
                <td id="er_SQLITE_ABORT">4</td>
                <td>SQLITE_ABORT</td>
                <td>
                    <p>Указывает, что операция была прервана до завершения, обычно это запрос приложения. См. Также: SQLITE_INTERRUPT.</p>
                    <p>Если функция обратного вызова sqlite3_exec() возвращает ненулевое значение, тогда sqlite3_exec() вернет SQLITE_ABORT.</p>
                    <p>Если операция ROLLBACK происходит в том же соединении с базой данных, что и ожидающее чтение или запись, то ожидающее чтение или запись может завершиться ошибкой SQLITE_ABORT или SQLITE_ABORT_ROLLBACK.</p>
                    <p>Помимо кода результата, значение SQLITE_ABORT также используется в качестве режима разрешения конфликтов, возвращаемого интерфейсом sqlite3_vtab_on_conflict().</p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_BUSY">5</td>
                <td>SQLITE_BUSY</td>
                <td>
                    <p>Указывает, что файл базы данных не может быть записан (или в некоторых случаях прочитан) из-за одновременной активности какого-либо другого соединения с базой данных, обычно соединения с базой данных в отдельном процессе.
                    </p>
                    <p>Например, если процесс A находится в середине большой транзакции записи и в то же время процесс B пытается начать новую транзакцию записи, процесс B вернет результат SQLITE_BUSY, потому что SQLite поддерживает только одну запись за
                        раз. Процессу B нужно будет дождаться, пока процесс A завершит свою транзакцию, прежде чем начинать новую транзакцию. Интерфейсы sqlite3_busy_timeout () и sqlite3_busy_handler () и прагма busy_timeout доступны для процесса B, чтобы
                        помочь ему справиться с ошибками SQLITE_BUSY.</p>
                    <p>Ошибка SQLITE_BUSY может возникнуть в любой момент транзакции: при первом запуске транзакции, во время любых операций записи или обновления или при фиксации транзакции. Чтобы избежать ошибок SQLITE_BUSY в середине транзакции, приложение
                        может использовать BEGIN IMMEDIATE вместо просто BEGIN для запуска транзакции. Команда BEGIN IMMEDIATE может сама вернуть SQLITE_BUSY, но в случае успеха SQLite гарантирует, что никакие последующие операции с той же базой данных
                        через следующий COMMIT не вернут SQLITE_BUSY.</p>
                    <p>См. Также: <span><a href="er_SQLITE_BUSY_RECOVERY">SQLITE_BUSY_RECOVERY</a></span> и <span><a href="er_SQLITE_BUSY_RECOVERY">SQLITE_BUSY_SNAPSHOT</a></span>. </p>
                    <p>Код результата SQLITE_BUSY отличается от <span><a href="er_SQLITE_LOCKED">SQLITE_LOCKED</a></span> тем, что SQLITE_BUSY указывает на конфликт с отдельным соединением с базой данных, вероятно, в отдельном процессе, тогда как <span><a href="er_SQLITE_LOCKED">SQLITE_LOCKED</a></span>                        указывает на конфликт внутри того же соединения с базой данных (или иногда соединения с базой данных с общим кешем). </p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_LOCKED">6</td>
                <td>SQLITE_LOCKED</td>
                <td>
                    <p>Указывает, что операция записи не может быть продолжена из-за конфликта внутри того же соединения с базой данных или конфликта с другим соединением с базой данных, которое использует общий кэш.</p>
                    <p>Например, оператор DROP TABLE не может быть запущен, пока другой поток читает из этой таблицы в том же соединении с базой данных, потому что удаление таблицы приведет к удалению таблицы из-под одновременного чтения.</p>
                    <p>Код результата SQLITE_LOCKED отличается от <span><a href="er_SQLITE_BUSY">SQLITE_BUSY</a></span> тем, что SQLITE_LOCKED указывает на конфликт в том же соединении с базой данных (или в соединении с общим кешем), тогда как <span><a href="er_SQLITE_BUSY">SQLITE_BUSY</a></span>                        указывает на конфликт с другим соединением с базой данных, возможно, в другом процессе. </p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_NOMEM">7</td>
                <td>SQLITE_NOMEM</td>
                <td>
                    <p>Указывает, что SQLite не смог выделить всю память, необходимую для завершения операции. Другими словами, внутренний вызов sqlite3_malloc () или sqlite3_realloc () завершился неудачно в случае, когда выделяемая память требовалась для
                        продолжения операции. </p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_READONLY">8</td>
                <td>SQLITE_READONLY</td>
                <td>
                    <p>Возвращается, когда делается попытка изменить некоторые данные, для которых текущее соединение с базой данных не имеет разрешения на запись. </p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_INTERRUPT">9</td>
                <td>SQLITE_INTERRUPT</td>
                <td>
                    <p>Указывает, что операция была прервана интерфейсом sqlite3_interrupt(). См. Также: <span><a href="er_SQLITE_ABORT">SQLITE_ABORT</a></span></p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_IOERR">10</td>
                <td>SQLITE_IOERR</td>
                <td>
                    <p>Сообщает, что операция не может быть завершена, поскольку операционная система сообщила об ошибке ввода-вывода.</p>
                    <p>Полный диск обычно дает ошибку <span><a href="er_SQLITE_FULL">SQLITE_FULL</a></span>, а не ошибку SQLITE_IOERR.</p>
                    <p>Существует множество различных расширенных кодов результатов для ошибок ввода-вывода, которые идентифицируют конкретную операцию ввода-вывода, в которой произошел сбой. </p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_CORRUPT">11</td>
                <td>SQLITE_CORRUPT</td>
                <td>
                    <p>Указывает, что файл базы данных был поврежден. См. Раздел «Как повредить файлы базы данных» для дальнейшего обсуждения того, как может произойти повреждение. </p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_NOTFOUND">12</td>
                <td>SQLITE_NOTFOUND</td>
                <td>
                    <p>Используется в двух контекстах. SQLITE_NOTFOUND может быть возвращен интерфейсом sqlite3_file_control(), чтобы указать, что код операции управления файлом, переданный в качестве третьего аргумента, не был распознан базовой VFS. SQLITE_NOTFOUND
                        также может быть возвращен методом xSetSystemCall() объекта sqlite3_vfs.</p>
                    <p>Код результата SQLITE_NOTFOUND также используется внутри реализации SQLite, но это внутреннее использование не предоставляется приложению. </p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_FULL">13</td>
                <td>SQLITE_FULL</td>
                <td>
                    <p>Указывает, что запись не может быть завершена из-за переполнения диска. Обратите внимание, что эта ошибка может возникать при попытке записать информацию в основной файл базы данных или при записи во временные файлы на диске.</p>
                    <p>Иногда приложения сталкиваются с этой ошибкой, даже если первичного дискового пространства достаточно, поскольку ошибка возникает при записи во временные файлы на диске в системе, где временные файлы хранятся в отдельном разделе с
                        гораздо меньшим пространством, чем на первичном диске. </p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_CANTOPEN">14</td>
                <td>SQLITE_CANTOPEN</td>
                <td>
                    <p>Указывает, что SQLite не удалось открыть файл. Рассматриваемый файл может быть первичным файлом базы данных или одним из нескольких временных файлов на диске. </p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_PROTOCOL">15</td>
                <td>SQLITE_PROTOCOL</td>
                <td>
                    <p>Указывает на проблему с протоколом блокировки файлов, используемым SQLite. Ошибка SQLITE_PROTOCOL в настоящее время возвращается только при использовании режима WAL и попытке начать новую транзакцию. Когда два отдельных соединения
                        с базой данных пытаются одновременно запустить транзакцию в режиме WAL, возникает состояние гонки. Проигравший в гонке отступает и пытается снова после небольшой задержки. Если одно и то же соединение десятки раз проигрывает в
                        гонке блокировок в течение нескольких секунд, оно в конечном итоге откажется и вернет SQLITE_PROTOCOL. Ошибка SQLITE_PROTOCOL должна появляться на практике очень, очень редко и только тогда, когда существует множество отдельных
                        процессов, все из которых активно конкурируют за запись в одну и ту же базу данных. </p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_EMPTY">16</td>
                <td>SQLITE_EMPTY</td>
                <td>
                    <p>В настоящее время не используется.</p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_SCHEMA">17</td>
                <td>SQLITE_SCHEMA</td>
                <td>
                    <p>указывает, что схема базы данных изменилась. Этот код результата может быть возвращен из sqlite3_step() для подготовленного оператора, который был сгенерирован с помощью sqlite3_prepare() или sqlite3_prepare16(). Если схема базы данных
                        была изменена каким-либо другим процессом между временем подготовки оператора и временем его выполнения, может возникнуть эта ошибка.</p>
                    <p>Если подготовленный оператор генерируется из sqlite3_prepare_v2(), тогда оператор автоматически повторно готовится, если схема изменяется, до SQLITE_MAX_SCHEMA_RETRY раз (по умолчанию: 50). Интерфейс sqlite3_step() будет возвращать
                        SQLITE_SCHEMA обратно в приложение только в том случае, если сбой сохраняется после этих многочисленных попыток. </p>
                    <br>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_TOOBIG">18</td>
                <td>SQLITE_TOOBIG</td>
                <td>
                    <p>Указывает, что строка или большой двоичный объект слишком большой. По умолчанию максимальная длина строки или большого двоичного объекта в SQLite составляет 1 000 000 000 байт. Эту максимальную длину можно изменить во время компиляции
                        с помощью параметра времени компиляции SQLITE_MAX_LENGTH или во время выполнения с помощью интерфейса sqlite3_limit(db, SQLITE_LIMIT_LENGTH, ...). Ошибка SQLITE_TOOBIG возникает, когда SQLite встречает строку или большой двоичный
                        объект, превышающий предел времени компиляции или времени выполнения.</p>
                    <p>Код ошибки SQLITE_TOOBIG также может возникать, когда оператор SQL слишком большого размера передается в один из интерфейсов sqlite3_prepare_v2(). По умолчанию максимальная длина оператора SQL намного меньше - 1000000 байтов. Максимальную
                        длину оператора SQL можно установить во время компиляции с помощью SQLITE_MAX_SQL_LENGTH или во время выполнения с помощью sqlite3_limit(db, SQLITE_LIMIT_SQL_LENGTH, ...). </p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_CONSTRAINT">19</td>
                <td>SQLITE_CONSTRAINT</td>
                <td>
                    <p>Означает, что при попытке обработать инструкцию SQL произошло нарушение ограничения SQL. Дополнительную информацию о невыполненном ограничении можно найти в сопроводительном сообщении об ошибке (возвращенном через sqlite3_errmsg()
                        или sqlite3_errmsg16()) или просмотрев расширенный код ошибки.</p>
                    <p>Код SQLITE_CONSTRAINT также может использоваться как возвращаемое значение из метода xBestIndex() реализации виртуальной таблицы. Когда xBestIndex() возвращает SQLITE_CONSTRAINT, это указывает на то, что конкретная комбинация входных
                        данных, отправленных в xBestIndex(), не может привести к пригодному для использования плану запроса и не должна рассматриваться в дальнейшем. </p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_MISMATCH">20</td>
                <td>SQLITE_MISMATCH</td>
                <td>
                    <p>Указывает на несоответствие типа данных.</p>
                    <p>SQLite обычно очень снисходительно относится к несоответствиям между типом значения и объявленным типом контейнера, в котором это значение должно храниться. Например, SQLite позволяет приложению хранить большой BLOB в столбце с объявленным
                        типом BOOLEAN. Но в некоторых случаях SQLite строго относится к типам. Ошибка SQLITE_MISMATCH возвращается в тех немногих случаях, когда типы не совпадают.</p>
                    <p>Идентификатор строки таблицы должен быть целым числом. Попытка установить для rowid любое значение, кроме целого (или NULL, которое будет автоматически преобразовано в следующий доступный целочисленный rowid), приводит к ошибке SQLITE_MISMATCH.</p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_MISUSE">21</td>
                <td>SQLITE_MISUSE</td>
                <td>
                    <p>Может быть возвращен, если приложение использует какой-либо интерфейс SQLite способом, который не определен или не поддерживается. Например, использование подготовленного оператора после того, как этот подготовленный оператор был завершен,
                        может привести к ошибке SQLITE_MISUSE.</p>
                    <p>SQLite пытается обнаружить неправильное использование и сообщить о неправильном использовании, используя этот код результата. Однако нет никакой гарантии, что обнаружение неправомерного использования будет успешным. Обнаружение злоупотреблений
                        является вероятностным. Приложения никогда не должны зависеть от возвращаемого значения SQLITE_MISUSE.</p>
                    <p>Если SQLite когда-либо возвращает SQLITE_MISUSE из любого интерфейса, это означает, что приложение неправильно закодировано и его необходимо исправить. Не отправляйте приложение, которое иногда возвращает SQLITE_MISUSE из стандартного
                        интерфейса SQLite, потому что это приложение содержит потенциально серьезные ошибки. </p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_NOLFS">22</td>
                <td>SQLITE_NOLFS</td>
                <td>
                    <p>Может возвращаться в системах, которые не поддерживают большие файлы, когда база данных становится больше, чем может обрабатывать файловая система. «NOLFS» означает «ОТСУТСТВИЕ поддержки больших файлов». </p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_AUTH">23</td>
                <td>SQLITE_AUTH</td>
                <td>
                    <p>Возвращается, когда обратный вызов авторизатора указывает, что подготавливаемый оператор SQL не авторизован.</p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_FORMAT">24</td>
                <td>SQLITE_FORMAT</td>
                <td>
                    <p>В настоящее время не используется SQLite. </p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_RANGE">25</td>
                <td>SQLITE_RANGE</td>
                <td>
                    <p>Указывает, что аргумент номера параметра для одной из подпрограмм sqlite3_bind или номер столбца в одной из подпрограмм sqlite3_column выходит за пределы допустимого диапазона. </p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_NOTADB">26</td>
                <td>SQLITE_NOTADB</td>
                <td>
                    <p>При попытке открыть файл ошибка SQLITE_NOTADB указывает, что открываемый файл не является файлом базы данных SQLite. </p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_NOTICE">27</td>
                <td>SQLITE_NOTICE</td>
                <td>
                    <p>Не возвращается ни одним интерфейсом C/C++. Однако SQLITE_NOTICE (или, скорее, один из его расширенных кодов ошибок) иногда используется в качестве первого аргумента в обратном вызове sqlite3_log(), чтобы указать, что происходит необычная
                        операция.
                    </p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_WARNING">28</td>
                <td>SQLITE_WARNING</td>
                <td>
                    <p>Не возвращается ни одним интерфейсом C/C++. Однако SQLITE_WARNING (или, скорее, один из его расширенных кодов ошибок) иногда используется в качестве первого аргумента в обратном вызове sqlite3_log(), чтобы указать, что имеет место
                        необычная и, возможно, непродуманная операция. </p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_ROW">100</td>
                <td>SQLITE_ROW</td>
                <td>
                    <p>Возвращаемый sqlite3_step(), указывает, что доступна другая строка вывода. </p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_DONE">101</td>
                <td>SQLITE_DONE</td>
                <td>
                    <p>Указывает, что операция завершена. Код результата SQLITE_DONE чаще всего рассматривается как возвращаемое значение от sqlite3_step(), указывающее, что оператор SQL выполнен до конца. Но SQLITE_DONE также может быть возвращен другими
                        многошаговыми интерфейсами, такими как sqlite3_backup_step(). </p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_OK_LOAD_PERMANENTLY">256</td>
                <td>SQLITE_OK_LOAD_PERMANENTLY</td>
                <td>
                    <p>Интерфейс sqlite3_load_extension() загружает расширение в одно соединение с базой данных. По умолчанию это расширение автоматически выгружается при закрытии соединения с базой данных. Однако, если точка входа расширения возвращает
                        SQLITE_OK_LOAD_PERMANENTLY вместо SQLITE_OK, то расширение остается загруженным в адресное пространство процесса после закрытия соединения с базой данных. Другими словами, методы xDlClose объекта sqlite3_vfs не вызываются для расширения
                        при закрытии соединения с базой данных.</p>
                    <p>Код возврата SQLITE_OK_LOAD_PERMANENTLY полезен, например, для загружаемых расширений, которые регистрируют новые VFS. </p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_ERROR_MISSING_COLLSEQ">257</td>
                <td>SQLITE_ERROR_MISSING_COLLSEQ</td>
                <td>
                    <p>Означает, что оператор SQL не может быть подготовлен, поскольку последовательность сортировки, указанная в этом операторе SQL, не может быть обнаружена.</p>
                    <p>Иногда, когда встречается этот код ошибки, процедура sqlite3_prepare_v2() преобразует ошибку в SQLITE_ERROR_RETRY и снова пытается подготовить инструкцию SQL, используя другой план запроса, который не требует использования неизвестной
                        последовательности сортировки. </p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_BUSY_RECOVERY">261</td>
                <td>SQLITE_BUSY_RECOVERY</td>
                <td>
                    <p>Это расширенный код ошибки для SQLITE_BUSY, который указывает, что операция не может быть продолжена, потому что другой процесс занят восстановлением файла базы данных в режиме WAL после сбоя. Код ошибки SQLITE_BUSY_RECOVERY возникает
                        только в базах данных в режиме WAL. </p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_LOCKED_SHAREDCACHE">262</td>
                <td>SQLITE_LOCKED_SHAREDCACHE</td>
                <td>
                    <p>Указывает, что доступ к записи данных SQLite заблокирован другим соединением с базой данных, которое использует ту же запись в режиме общего кэша. Когда два или более соединения с базой данных совместно используют один и тот же кеш,
                        и одно из соединений находится в процессе изменения записи в этом кеше, тогда другим соединениям блокируется доступ к этим данным, пока изменения продолжаются, чтобы не дать читателям видеть поврежденное или частично завершенное
                        изменение. </p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_READONLY_RECOVERY">264</td>
                <td>SQLITE_READONLY_RECOVERY</td>
                <td>
                    <p>Это расширенный код ошибки для SQLITE_READONLY. Код ошибки SQLITE_READONLY_RECOVERY указывает, что база данных в режиме WAL не может быть открыта, потому что файл базы данных необходимо восстановить, а для восстановления требуется
                        доступ для записи, но доступен только доступ для чтения.</p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_IOERR_READ">266</td>
                <td>SQLITE_IOERR_READ</td>
                <td>
                    <p>Это расширенный код ошибки для SQLITE_IOERR, указывающий на ошибку ввода-вывода на уровне VFS при попытке чтения из файла на диске. Эта ошибка может возникнуть из-за неисправности оборудования или из-за того, что файловая система была
                        отключена, когда файл был открыт.</p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_CORRUPT_VTAB">267</td>
                <td>SQLITE_CORRUPT_VTAB</td>
                <td>
                    <p>Это расширенный код ошибки для SQLITE_CORRUPT, используемый виртуальными таблицами. Виртуальная таблица может вернуть SQLITE_CORRUPT_VTAB, чтобы указать, что содержимое виртуальной таблицы повреждено.</p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_CANTOPEN_NOTEMPDIR">270</td>
                <td>SQLITE_CANTOPEN_NOTEMPDIR</td>
                <td>
                    <p>Больше не используется.</p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_CONSTRAINT_CHECK">275</td>
                <td>SQLITE_CONSTRAINT_CHECK</td>
                <td>
                    <p>Это расширенный код ошибки для SQLITE_CONSTRAINT, указывающий на сбой ограничения CHECK. </p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_NOTICE_RECOVER_WAL">283</td>
                <td>SQLITE_NOTICE_RECOVER_WAL</td>
                <td>
                    <p>Код результата SQLITE_NOTICE_RECOVER_WAL передается в обратный вызов sqlite3_log() при восстановлении файла базы данных в режиме WAL. </p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_WARNING_AUTOINDEX">284</td>
                <td>SQLITE_WARNING_AUTOINDEX</td>
                <td>
                    <p>Код результата SQLITE_WARNING_AUTOINDEX передается в обратный вызов sqlite3_log() всякий раз, когда используется автоматическое индексирование. Это может служить предупреждением для разработчиков приложений о том, что для базы данных
                        могут быть полезны дополнительные индексы. </p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_ERROR_RETRY">513</td>
                <td>SQLITE_ERROR_RETRY</td>
                <td>
                    <p>Используется внутренне, чтобы спровоцировать sqlite3_prepare_v2() (или одну из его подпрограмм-родственников для создания подготовленных операторов), чтобы попытаться еще раз подготовить оператор, который не удался с ошибкой при предыдущей
                        попытке. </p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_ABORT_ROLLBACK">516</td>
                <td>SQLITE_ABORT_ROLLBACK</td>
                <td>
                    <p>Это расширенный код ошибки для SQLITE_ABORT, указывающий на то, что выполнение инструкции SQL было прервано из-за отката транзакции, которая была активной при первом запуске инструкции SQL. Ожидающие операции записи всегда завершаются
                        сбоем с этой ошибкой при откате. ROLLBACK приведет к сбою отложенной операции чтения только в том случае, если схема была изменена в откатываемой транзакции.</p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_BUSY_SNAPSHOT">517</td>
                <td>SQLITE_BUSY_SNAPSHOT</td>
                <td>
                    <p>Это расширенный код ошибки для SQLITE_BUSY, который возникает в базах данных в режиме WAL, когда соединение с базой данных пытается преобразовать транзакцию чтения в транзакцию записи, но обнаруживает, что другое соединение с базой
                        данных уже записано в базу данных и, таким образом, делает недействительными предыдущие чтения.</p>
                    <p>В следующем сценарии показано, как может возникнуть ошибка SQLITE_BUSY_SNAPSHOT:</p>
                    <ol>
                        <li>Процесс A запускает транзакцию чтения в базе данных и выполняет один или несколько операторов SELECT. Процесс A сохраняет транзакцию открытой.</li>
                        <li>Процесс B обновляет базу данных, изменяя значения, ранее считанные процессом A.</li>
                        <li>Процесс A теперь пытается выполнить запись в базу данных. Но представление процесса A о содержимом базы данных теперь устарело, потому что процесс B изменил файл базы данных после того, как процесс A прочитал из него. Следовательно,
                            процесс A получает ошибку SQLITE_BUSY_SNAPSHOT.</li>
                    </ol>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_LOCKED_VTAB">518</td>
                <td>SQLITE_LOCKED_VTAB</td>
                <td>
                    <p>Код результата SQLITE_LOCKED_VTAB не используется ядром SQLite, но доступен для использования расширениями. Реализации виртуальных таблиц могут возвращать этот код результата, чтобы указать, что они не могут завершить текущую операцию
                        из-за блокировок, удерживаемых другими потоками или процессами.</p>
                    <p>Расширение R-Tree возвращает этот код результата, когда делается попытка обновить R-Tree, в то время как другой подготовленный оператор активно читает R-Tree. Обновление не может быть продолжено, потому что любое изменение R-дерева
                        может включать перестановку и повторную балансировку узлов, что нарушит работу курсоров чтения, в результате чего некоторые строки будут повторяться, а другие строки будут пропущены. </p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_READONLY_CANTLOCK">520</td>
                <td>SQLITE_READONLY_CANTLOCK</td>
                <td>
                    <p>Это расширенный код ошибки для SQLITE_READONLY. Код ошибки SQLITE_READONLY_CANTLOCK указывает, что SQLite не может получить блокировку чтения для базы данных в режиме WAL, поскольку файл с общей памятью, связанный с этой базой данных,
                        доступен только для чтения. </p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_IOERR_SHORT_READ">522</td>
                <td>SQLITE_IOERR_SHORT_READ</td>
                <td>
                    <p>Это расширенный код ошибки для SQLITE_IOERR, указывающий, что попытка чтения на уровне VFS не смогла получить столько байтов, сколько было запрошено. Это могло произойти из-за усеченного файла. </p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_CORRUPT_SEQUENCE">523</td>
                <td>SQLITE_CORRUPT_SEQUENCE</td>
                <td>
                    <p>Означает, что схема таблицы sqlite_sequence повреждена. Таблица sqlite_sequence используется для помощи в реализации функции AUTOINCREMENT. Таблица sqlite_sequence должна иметь следующий формат:</p>
                    <p>
                        <Code>CREATE TABLE sqlite_sequence(name,seq);</Code>
                    </p>
                    <p>Если SQLite обнаруживает, что таблица sqlite_sequence имеет любой другой формат, он возвращает ошибку SQLITE_CORRUPT_SEQUENCE.</p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_CANTOPEN_ISDIR">526</td>
                <td>SQLITE_CANTOPEN_ISDIR</td>
                <td>
                    <p>Это расширенный код ошибки для SQLITE_CANTOPEN, указывающий, что операция открытия файла завершилась неудачно, поскольку файл действительно является каталогом. </p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_CONSTRAINT_COMMITHOOK">531</td>
                <td>SQLITE_CONSTRAINT_COMMITHOOK</td>
                <td>
                    <p>Это расширенный код ошибки для SQLITE_CONSTRAINT, указывающий, что обратный вызов ловушки фиксации вернул ненулевое значение, что, таким образом, вызвало откат оператора SQL.</p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_NOTICE_RECOVER_ROLLBACK">539</td>
                <td>SQLITE_NOTICE_RECOVER_ROLLBACK</td>
                <td>
                    <p>Передается обратному вызову sqlite3_log() при откате горячего журнала.</p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_ERROR_SNAPSHOT">769</td>
                <td>SQLITE_ERROR_SNAPSHOT</td>
                <td>
                    <p>Может быть возвращен при попытке запустить транзакцию чтения в исторической версии базы данных с помощью интерфейса sqlite3_snapshot_open(). Если исторический моментальный снимок больше недоступен, транзакция чтения завершится ошибкой
                        с SQLITE_ERROR_SNAPSHOT. Этот код ошибки возможен только в том случае, если SQLite скомпилирован с -DSQLITE_ENABLE_SNAPSHOT. </p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_BUSY_TIMEOUT">773</td>
                <td>SQLITE_BUSY_TIMEOUT</td>
                <td>
                    <p>Указывает, что блокирующий запрос блокировки файла с рекомендациями Posix на уровне VFS завершился неудачно из-за тайм-аута. Блокирующие рекомендательные блокировки Posix доступны только как проприетарное расширение SQLite, и даже
                        в этом случае они поддерживаются только в том случае, если SQLite скомпилирован с параметром времени компиляции SQLITE_EANBLE_SETLK_TIMEOUT.</p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_READONLY_ROLLBACK">776</td>
                <td>SQLITE_READONLY_ROLLBACK</td>
                <td>
                    <p>Это расширенный код ошибки для SQLITE_READONLY. Код ошибки SQLITE_READONLY_ROLLBACK указывает, что база данных не может быть открыта, потому что у нее есть горячий журнал, который необходимо откатить, но не может, потому что база данных
                        доступна только для чтения. </p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_IOERR_WRITE">778</td>
                <td>SQLITE_IOERR_WRITE</td>
                <td>
                    <p>Это расширенный код ошибки для SQLITE_IOERR, указывающий на ошибку ввода-вывода на уровне VFS при попытке записи в файл на диске. Эта ошибка может возникнуть из-за неисправности оборудования или из-за того, что файловая система была
                        отключена, когда файл был открыт. Эта ошибка не должна возникать, если файловая система заполнена, поскольку для этой цели существует отдельный код ошибки (SQLITE_FULL).</p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_CORRUPT_INDEX">779</td>
                <td>SQLITE_CORRUPT_INDEX</td>
                <td>
                    <p>Означает, что SQLite обнаружил, что запись отсутствует в индексе. Это особый случай кода ошибки SQLITE_CORRUPT, который предполагает, что проблема может быть решена путем выполнения команды REINDEX, при условии, что в другом месте
                        файла базы данных нет других проблем.</p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_CANTOPEN_FULLPATH">782</td>
                <td>SQLITE_CANTOPEN_FULLPATH</td>
                <td>
                    <p>Это расширенный код ошибки для SQLITE_CANTOPEN, указывающий, что операция открытия файла завершилась неудачно, поскольку операционная система не смогла преобразовать имя файла в полный путь.</p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_CONSTRAINT_FOREIGNKEY">787</td>
                <td>SQLITE_CONSTRAINT_FOREIGNKEY</td>
                <td>
                    <p>Это расширенный код ошибки для SQLITE_CONSTRAINT, указывающий на сбой ограничения внешнего ключа. </p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_READONLY_DBMOVED">1032</td>
                <td>SQLITE_READONLY_DBMOVED</td>
                <td>
                    <p>Это расширенный код ошибки для SQLITE_READONLY. Код ошибки SQLITE_READONLY_DBMOVED указывает, что база данных не может быть изменена, потому что файл базы данных был перемещен с момента его открытия, и поэтому любая попытка изменения
                        базы данных может привести к повреждению базы данных, если процессы выйдут из строя из-за неправильного имени журнала отката. </p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_IOERR_FSYNC">1034</td>
                <td>SQLITE_IOERR_FSYNC</td>
                <td>
                    <p>Это расширенный код ошибки для SQLITE_IOERR, указывающий на ошибку ввода-вывода на уровне VFS при попытке сбросить ранее записанный контент из буферов ОС и / или управления диском в постоянное хранилище. Другими словами, этот код указывает
                        на проблему с системным вызовом fsync() в unix или системным вызовом FlushFileBuffers() в Windows.</p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_CANTOPEN_CONVPATH">1038</td>
                <td>SQLITE_CANTOPEN_CONVPATH</td>
                <td>
                    <p>Это расширенный код ошибки для SQLITE_CANTOPEN, используемый только Cygwin VFS и указывающий на сбой системного вызова cygwin_conv_path() при попытке открыть файл. См. Также: SQLITE_IOERR_CONVPATH</p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_CONSTRAINT_FUNCTION">1043</td>
                <td>SQLITE_CONSTRAINT_FUNCTION</td>
                <td>
                    <p>В настоящее время не используется ядром SQLite. Однако этот код ошибки доступен для использования функциями расширения.</p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_READONLY_CANTINIT">1288</td>
                <td>SQLITE_READONLY_CANTINIT</td>
                <td>
                    <p>Код результата SQLITE_READONLY_CANTINIT исходит из метода xShmMap VFS, чтобы указать, что область разделяемой памяти, используемая режимом WAL, существует, но ее содержимое ненадежно и непригодно для использования текущим процессом,
                        поскольку текущий процесс не имеет разрешения на запись в область разделяемой памяти. (Область общей памяти для режима WAL обычно представляет собой файл с суффиксом «-wal», который отображается в пространстве процесса. Если текущий
                        процесс не имеет разрешения на запись в этот файл, он не может записывать в общую память.)</p>
                    <p>Логика более высокого уровня в SQLite обычно перехватывает код ошибки и создает временную область разделяемой памяти в памяти, чтобы текущий процесс мог, по крайней мере, прочитать содержимое базы данных. Этот код результата не должен
                        доходить до уровня интерфейса приложения. </p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_IOERR_DIR_FSYNC">1290</td>
                <td>SQLITE_IOERR_DIR_FSYNC</td>
                <td>
                    <p>Это расширенный код ошибки для SQLITE_IOERR, указывающий на ошибку ввода-вывода на уровне VFS при попытке вызвать fsync() в каталоге. Unix VFS пытается открыть каталоги fsync() после создания или удаления определенных файлов, чтобы
                        гарантировать, что эти файлы по-прежнему будут отображаться в файловой системе после отключения питания или сбоя системы. Этот код ошибки указывает на проблему при попытке выполнить эту fsync(). </p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_CANTOPEN_DIRTYWAL">1294</td>
                <td>SQLITE_CANTOPEN_DIRTYWAL</td>
                <td>
                    <p>В настоящее время не используется.</p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_CONSTRAINT_NOTNULL">1299</td>
                <td>SQLITE_CONSTRAINT_NOTNULL</td>
                <td>
                    <p>Это расширенный код ошибки для SQLITE_CONSTRAINT, указывающий на сбой ограничения NOT NULL. </p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_READONLY_DIRECTORY">1544</td>
                <td>SQLITE_READONLY_DIRECTORY</td>
                <td>
                    <p>Указывает, что база данных доступна только для чтения, поскольку процесс не имеет разрешения на создание файла журнала в том же каталоге, что и база данных, и создание файла журнала является предварительным условием для записи. </p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_IOERR_TRUNCATE">1546</td>
                <td>SQLITE_IOERR_TRUNCATE</td>
                <td>
                    <p>Это расширенный код ошибки для SQLITE_IOERR, указывающий на ошибку ввода-вывода на уровне VFS при попытке усечь файл до меньшего размера.</p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_CANTOPEN_SYMLINK">1550</td>
                <td>SQLITE_CANTOPEN_SYMLINK</td>
                <td>
                    <p>Возвращается интерфейсом sqlite3_open() и его родственниками, когда используется флаг SQLITE_OPEN_NOFOLLOW и файл базы данных является символической ссылкой.</p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_CONSTRAINT_PRIMARYKEY">1555</td>
                <td>SQLITE_CONSTRAINT_PRIMARYKEY</td>
                <td>
                    <p>Это расширенный код ошибки для SQLITE_CONSTRAINT, указывающий на сбой ограничения PRIMARY KEY. </p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_IOERR_FSTAT">1802</td>
                <td>SQLITE_IOERR_FSTAT</td>
                <td>
                    <p>Это расширенный код ошибки для SQLITE_IOERR, указывающий на ошибку ввода-вывода на уровне VFS при попытке вызвать fstat() (или эквивалент) для файла, чтобы определить такую информацию, как размер файла или права доступа. </p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_CONSTRAINT_TRIGGER">1811</td>
                <td>SQLITE_CONSTRAINT_TRIGGER</td>
                <td>
                    <p>Это расширенный код ошибки для SQLITE_CONSTRAINT, указывающий, что сработала функция RAISE в триггере, что привело к прерыванию оператора SQL. </p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_IOERR_UNLOCK">2058</td>
                <td>SQLITE_IOERR_UNLOCK</td>
                <td>
                    <p>Это расширенный код ошибки для SQLITE_IOERR, указывающий на ошибку ввода-вывода в методе xUnlock объекта sqlite3_io_methods. </p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_CONSTRAINT_UNIQUE">2067</td>
                <td>SQLITE_CONSTRAINT_UNIQUE</td>
                <td>
                    <p>Это расширенный код ошибки для SQLITE_CONSTRAINT, указывающий на сбой ограничения UNIQUE. </p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_IOERR_RDLOCK">2314</td>
                <td>SQLITE_IOERR_RDLOCK</td>
                <td>
                    <p>Это расширенный код ошибки для SQLITE_IOERR, указывающий на ошибку ввода-вывода в методе xLock объекта sqlite3_io_methods при попытке получить блокировку чтения. </p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_CONSTRAINT_VTAB">2323</td>
                <td>SQLITE_CONSTRAINT_VTAB</td>
                <td>
                    <p>В настоящее время не используется ядром SQLite. Однако этот код ошибки доступен для использования виртуальными таблицами, определяемыми приложением. </p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_IOERR_DELETE">2570</td>
                <td>SQLITE_IOERR_DELETE</td>
                <td>
                    <p>Это расширенный код ошибки для SQLITE_IOERR, указывающий на ошибку ввода-вывода в методе xDelete объекта sqlite3_vfs.</p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_CONSTRAINT_ROWID">2579</td>
                <td>SQLITE_CONSTRAINT_ROWID</td>
                <td>
                    <p>Это расширенный код ошибки для SQLITE_CONSTRAINT, указывающий, что идентификатор строки не уникален. </p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_IOERR_BLOCKED">2826</td>
                <td>SQLITE_IOERR_BLOCKED</td>
                <td>
                    <p>Больше не используется.</p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_CONSTRAINT_PINNED">2835</td>
                <td>SQLITE_CONSTRAINT_PINNED</td>
                <td>
                    <p>Это расширенный код ошибки для SQLITE_CONSTRAINT, указывающий, что попытка триггера UPDATE удаляет строку, которая обновлялась в середине обновления.</p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_IOERR_NOMEM">3082</td>
                <td>SQLITE_IOERR_NOMEM</td>
                <td>
                    <p>Код ошибки SQLITE_IOERR_NOMEM иногда возвращается уровнем VFS, чтобы указать, что операция не может быть завершена из-за невозможности выделить достаточно памяти. Этот код ошибки обычно преобразуется в SQLITE_NOMEM более высокими уровнями
                        SQLite перед возвратом в приложение. </p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_IOERR_ACCESS">3338</td>
                <td>SQLITE_IOERR_ACCESS</td>
                <td>
                    <p>Это расширенный код ошибки для SQLITE_IOERR, указывающий на ошибку ввода-вывода в методе xAccess объекта sqlite3_vfs. </p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_IOERR_CHECKRESERVEDLOCK">3594</td>
                <td>SQLITE_IOERR_CHECKRESERVEDLOCK</td>
                <td>
                    <p>Это расширенный код ошибки для SQLITE_IOERR, указывающий на ошибку ввода-вывода в методе xCheckReservedLock объекта sqlite3_io_methods. </p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_IOERR_LOCK">3850</td>
                <td>SQLITE_IOERR_LOCK</td>
                <td>
                    <p>Это расширенный код ошибки для SQLITE_IOERR, указывающий на ошибку ввода-вывода в логике блокировки рекомендательного файла. Обычно ошибка SQLITE_IOERR_LOCK указывает на проблему с получением блокировки PENDING. Однако он также может
                        указывать на различные ошибки блокировки на некоторых специализированных VFS, используемых на компьютерах Mac. </p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_IOERR_CLOSE">4106</td>
                <td>SQLITE_IOERR_CLOSE</td>
                <td>
                    <p>Это расширенный код ошибки для SQLITE_IOERR, указывающий на ошибку ввода-вывода в методе xClose объекта sqlite3_io_methods. </p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_IOERR_DIR_CLOSE">4362</td>
                <td>SQLITE_IOERR_DIR_CLOSE</td>
                <td>
                    <p>Больше не используется.</p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_IOERR_SHMOPEN">4618</td>
                <td>SQLITE_IOERR_SHMOPEN</td>
                <td>
                    <p>Это расширенный код ошибки для SQLITE_IOERR, указывающий на ошибку ввода-вывода в методе xShmMap объекта sqlite3_io_methods при попытке открыть новый сегмент разделяемой памяти. </p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_IOERR_SHMSIZE">4874</td>
                <td>SQLITE_IOERR_SHMSIZE</td>
                <td>
                    <p>Это расширенный код ошибки для SQLITE_IOERR, указывающий на ошибку ввода-вывода в методе xShmMap объекта sqlite3_io_methods при попытке увеличить файл "shm" как часть обработки транзакции в режиме WAL. Эта ошибка может указывать на
                        то, что на томе базовой файловой системы не хватает места. </p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_IOERR_SHMLOCK">5130</td>
                <td>SQLITE_IOERR_SHMLOCK</td>
                <td>
                    <p>Больше не используется.</p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_IOERR_SHMMAP">5386</td>
                <td>SQLITE_IOERR_SHMMAP</td>
                <td>
                    <p>Это расширенный код ошибки для SQLITE_IOERR, указывающий на ошибку ввода-вывода в методе xShmMap объекта sqlite3_io_methods при попытке сопоставить сегмент разделяемой памяти в адресное пространство процесса.</p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_IOERR_SEEK">5642</td>
                <td>SQLITE_IOERR_SEEK</td>
                <td>
                    <p>Это расширенный код ошибки для SQLITE_IOERR, указывающий на ошибку ввода-вывода в методах xRead или xWrite в объекте sqlite3_io_methods при попытке поиска файлового дескриптора в начальной точке файла, где должно произойти чтение или
                        запись. </p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_IOERR_DELETE_NOENT">5898</td>
                <td>SQLITE_IOERR_DELETE_NOENT</td>
                <td>
                    <p>Это расширенный код ошибки для SQLITE_IOERR, указывающий, что метод xDelete объекта sqlite3_vfs завершился неудачно, поскольку удаляемый файл не существует. </p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_IOERR_MMAP">6154</td>
                <td>SQLITE_IOERR_MMAP</td>
                <td>
                    <p>Это расширенный код ошибки для SQLITE_IOERR, указывающий на ошибку ввода-вывода в методах xFetch или xUnfetch объекта sqlite3_io_methods при попытке сопоставить или отменить отображение части файла базы данных в адресное пространство
                        процесса. </p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_IOERR_GETTEMPPATH">6410</td>
                <td>SQLITE_IOERR_GETTEMPPATH</td>
                <td>
                    <p>Это расширенный код ошибки для SQLITE_IOERR, указывающий, что VFS не может определить подходящий каталог для размещения временных файлов. </p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_IOERR_CONVPATH">6666</td>
                <td>SQLITE_IOERR_CONVPATH</td>
                <td>
                    <p>Это расширенный код ошибки для SQLITE_IOERR, используемый только Cygwin VFS и указывающий на сбой системного вызова cygwin_conv_path(). См. Также: SQLITE_CANTOPEN_CONVPATH </p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_IOERR_VNODE">6922</td>
                <td>SQLITE_IOERR_VNODE</td>
                <td>
                    <p>Это код, зарезервированный для использования расширениями. Он не используется ядром SQLite. </p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_IOERR_AUTH">7178</td>
                <td></td>
                <td>
                    <p>Это код, зарезервированный для использования расширениями. Он не используется ядром SQLite. </p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_IOERR_BEGIN_ATOMIC">7434</td>
                <td>SQLITE_IOERR_BEGIN_ATOMIC</td>
                <td>
                    <p>Указывает, что базовая операционная система сообщила об ошибке в элементе управления файлом SQLITE_FCNTL_BEGIN_ATOMIC_WRITE. Это происходит только тогда, когда SQLITE_ENABLE_ATOMIC_WRITE включен и база данных размещена в файловой системе,
                        которая поддерживает атомарные записи. </p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_IOERR_COMMIT_ATOMIC">7690</td>
                <td>SQLITE_IOERR_COMMIT_ATOMIC</td>
                <td>
                    <p>Указывает, что базовая операционная система сообщила об ошибке в элементе управления файлом SQLITE_FCNTL_COMMIT_ATOMIC_WRITE. Это происходит только тогда, когда SQLITE_ENABLE_ATOMIC_WRITE включен и база данных размещена в файловой
                        системе, которая поддерживает атомарные записи. </p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_IOERR_ROLLBACK_ATOMIC">7946</td>
                <td>SQLITE_IOERR_ROLLBACK_ATOMIC</td>
                <td>
                    <p>Указывает, что базовая операционная система сообщила об ошибке в элементе управления файлом SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE. Это происходит только тогда, когда SQLITE_ENABLE_ATOMIC_WRITE включен и база данных размещена в файловой
                        системе, которая поддерживает атомарные записи. </p>
                </td>
            </tr>
            <tr>
                <td id="er_SQLITE_IOERR_DATA">8202</td>
                <td>SQLITE_IOERR_DATA</td>
                <td>
                    <p>Это расширенный код ошибки для SQLITE_IOERR, используемый только прокладкой контрольной суммы VFS, чтобы указать, что контрольная сумма на странице файла базы данных неверна. </p>
                </td>
            </tr>
        </table>
        <br>
        <p><a href="./00_06.html">Синтаксис SQL&rArr;</a></p>
    </div>
</body>