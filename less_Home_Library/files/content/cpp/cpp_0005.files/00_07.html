<head>
    <link rel="stylesheet" href="../../../css/books_style.css">
</head>

<body>
    <div>
        <p><a href="./00_06.html">&lArr;Синтаксис SQL</a></p>
        <h1>Команды Pragma</h1>
        <h2>В этом документе описаны параметры настройки производительности SQLite и другие команды базы данных специального назначения.</h2>
        <hr>
        <h2>Заявления PRAGMA</h2>
        <p>Оператор PRAGMA - это расширение SQL, специфичное для SQLite, которое используется для изменения работы библиотеки SQLite или для запроса библиотеки SQLite для внутренних (не табличных) данных. Оператор PRAGMA выполняется с использованием того
            же интерфейса, что и другие команды SQLite (например, SELECT, INSERT), но отличается в следующих важных отношениях:</p>
        <ul>
            <li>Команда pragma специфична для SQLite и несовместима с другими механизмами баз данных SQL.</li>
            <li>Определенные операторы прагмы могут быть удалены, а другие добавлены в будущих выпусках SQLite. Нет гарантии обратной совместимости.</li>
            <li>Сообщения об ошибках не генерируются, если выдается неизвестная прагма. Неизвестные прагмы просто игнорируются. Это означает, что если есть опечатка в инструкции прагмы, библиотека не информирует пользователя об этом факте.</li>
            <li>Некоторые прагмы действуют на этапе компиляции SQL, а не на этапе выполнения. Это означает, что при использовании API sqlite3_prepare (), sqlite3_step (), sqlite3_finalize () на языке C (или аналогичного в интерфейсе оболочки) прагма может
                выполняться во время вызова sqlite3_prepare (), а не во время вызова sqlite3_step () как обычный SQL заявления делаю. Или прагма может выполняться во время sqlite3_step (), как обычные операторы SQL. Будет ли прагма выполняться во время
                sqlite3_prepare () или sqlite3_step (), зависит от прагмы и от конкретной версии SQLite.</li>
            <li>Префиксы EXPLAIN и EXPLAIN QUERY PLAN для операторов SQL влияют только на поведение оператора во время sqlite3_step (). Это означает, что операторы PRAGMA, которые вступают в силу во время sqlite3_prepare (), будут вести себя одинаково, независимо
                от того, предваряются ли они «EXPLAIN» или нет. </li>
        </ul>
        <p>API языка C для SQLite предоставляет файловый элемент управления SQLITE_FCNTL_PRAGMA, который дает реализациям VFS возможность добавлять новые операторы PRAGMA или переопределять значение встроенных операторов PRAGMA. </p>
        <hr>
        <h2>Синтаксис команды PRAGMA</h2>
        <p>pragma-stmt:</p>
        <img src="00_07_01.png" alt="">
        <p>pragma-value:</p>
        <img src="00_07_02.png" alt="">
        <p>signed-number:</p>
        <img src="00_07_03.png" alt="">
        <p>Прагма может принимать либо ноль, либо один аргумент. Аргумент может быть заключен в круглые скобки или может быть отделен от имени прагмы знаком равенства. Два синтаксиса дают одинаковые результаты. Во многих прагмах аргумент является логическим.
            Логическое значение может быть одним из:</p>
        <p class="font-bold">1 yes true on</p>
        <p class="font-bold">0 no false off</p>
        <p>Аргументы ключевых слов могут при желании заключаться в кавычки. (Пример: 'yes' [FALSE].) Некоторые прагмы принимают строковый литерал в качестве аргумента. Когда прагма принимает аргумент ключевого слова, он обычно также принимает числовой эквивалент.
            Например, «0» и «нет» означают то же самое, что и «1» и «да». При запросе значения параметра многие прагмы возвращают число, а не ключевое слово.</p>
        <p>Прагма может иметь необязательное имя схемы перед именем прагмы. Имя схемы - это имя базы данных, созданной с помощью ATTACH, или "main" или "temp" для основной базы данных и базы данных TEMP. Если необязательное имя схемы опущено, предполагается
            «основная». В некоторых прагмах имя схемы не имеет смысла и просто игнорируется. В документации ниже прагмы, для которых имеет смысл имя схемы, показаны с «схемой». префикс. </p>
        <hr>
        <h2>Функции PRAGMA </h2>
        <p>К PRAGMA, возвращающим результаты и не имеющим побочных эффектов, можно получить доступ из обычных операторов SELECT как функций, возвращающих табличное значение. Для каждой участвующей PRAGMA соответствующая возвращающая табличное значение функция
            имеет то же имя, что и PRAGMA, с 7-символьным префиксом pragma_. Аргумент и схема PRAGMA, если таковые имеются, передаются в качестве аргументов функции, возвращающей табличное значение.</p>
        <p>Например, информацию о столбцах в индексе можно прочитать с помощью прагмы index_info следующим образом: </p>
        <p>
            <Code>PRAGMA index_info('idx52');</Code>
        </p>
        <p>Или тот же контент можно прочитать, используя: </p>
        <p>
            <Code>SELECT * FROM pragma_index_info('idx52');</Code>
        </p>
        <p>Преимущество формата функции с табличным значением состоит в том, что запрос может возвращать только подмножество столбцов PRAGMA, может включать предложение WHERE, может использовать агрегатные функции, а функция с табличным значением может быть
            только одним из нескольких источников данных в присоединиться. Например, чтобы получить список всех проиндексированных столбцов в схеме, можно запросить: </p>
        <p class="cpp_code">SELECT DISTINCT m.name || '.' || ii.name AS 'indexed-columns'</p>
        <p class="cpp_code_1t">FROM sqlite_schema AS m,</p>
        <p class="cpp_code_2t">pragma_index_list(m.name) AS il,</p>
        <p class="cpp_code_2t">pragma_index_info(il.name) AS ii</p>
        <p class="cpp_code_1t">WHERE m.type='table'</p>
        <p class="cpp_code">ORDER BY 1;</p>
        <h2>Дополнительные замечания: </h2>
        <ul>
            <li>Возвращающие табличное значение функции существуют только для встроенных PRAGMA, но не для PRAGMA, определенных с помощью файлового элемента управления SQLITE_FCNTL_PRAGMA.</li>
            <li>Возвращающие табличное значение функции существуют только для PRAGMA, которые возвращают результаты и не имеют побочных эффектов.</li>
            <li>Эту функцию можно использовать для реализации информационной схемы, сначала создав отдельную схему с помощью
                <p>
                    <Code>ATTACH ':memory:' AS 'information_schema';</Code>
                </p>
            </li>
            <li>Затем создание представлений в этой схеме, которые реализуют таблицы схемы официальной информации с использованием возвращающих табличное значение функций PRAGMA.</li>
            <li>Это экспериментальная функция, которая может быть изменена. Дополнительная документация станет доступной, если и когда функции с табличными значениями для функции PRAGMA станут официально поддерживаться.</li>
            <li>Возвращающие табличное значение функции для функции PRAGMA были добавлены в SQLite версии 3.16.0 (02.01.2017). Предыдущие версии SQLite не могут использовать эту функцию. </li>
        </ul>
        <hr>
        <p></p>
        <p></p>
        <p></p>
        <p></p>
        <p></p>
        <p></p>
        <p></p>
        <p></p>
        <p></p>
        <p></p>
        <p></p>
        <p></p>
        <p></p>
        <p></p>
        <p><a href="./00_08.html">***&rArr;</a></p>
    </div>
</body>