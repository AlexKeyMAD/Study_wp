<head>
    <link rel="stylesheet" href="../../../css/books_style.css">
</head>

<body>
    <div>
        <p><a href="./00_02.html">&lArr;Введение в интерфейс SQLite C/C++</a></p>
        <h1>Как компилировать SQLite</h1>
        <h2>Инструкции и подсказки по компиляции кода SQLite C и интеграции этого кода с вашим собственным приложением.</h2>
        <hr>
        <h2>Обзор</h2>
        <p>SQLite - это исходный код ANSI-C. Он должен быть скомпилирован в машинный код, прежде чем станет полезным. Эта статья представляет собой руководство по различным способам компиляции SQLite.</p>
        <p>В этой статье нет пошагового рецепта компиляции SQLite. Это было бы сложно, поскольку каждая ситуация развития индивидуальна. Скорее, эта статья описывает и иллюстрирует принципы компиляции SQLite. Типичные команды компиляции представлены в качестве
            примеров с ожиданием, что разработчики приложений могут использовать эти примеры в качестве руководства для разработки своих собственных пользовательских процедур компиляции. Другими словами, в этой статье представлены идеи и идеи, а не готовые
            решения. </p>
        <h2>1. Объединение по сравнению с отдельными исходными файлами </h2>
        <p>SQLite построен из более чем сотни файлов кода C и скриптов, разбросанных по нескольким каталогам. Реализация SQLite - это чистый ANSI-C, но многие файлы исходного кода на языке C либо генерируются, либо преобразуются вспомогательными программами
            C и сценариями AWK, SED и TCL до включения в готовую библиотеку SQLite. Создание необходимых программ на C и преобразование и / или создание исходного кода на языке C для SQLite - сложный процесс.</p>
        <p>Чтобы упростить задачу, SQLite также доступен в виде предварительно упакованного файла исходного кода объединения: sqlite3.c. Объединение представляет собой один файл кода ANSI-C, который реализует всю библиотеку SQLite. С объединением справиться
            намного проще. Все содержится в одном файле кода, поэтому его легко добавить в исходное дерево более крупной программы на C или C ++. Все этапы генерации кода и преобразования уже выполнены, поэтому нет никаких вспомогательных программ C,
            которые нужно настраивать и компилировать, и нет скриптов для запуска. А поскольку вся библиотека содержится в одной единице трансляции, компиляторы могут выполнять более сложные оптимизации, приводящие к повышению производительности на 5-10%.
            По этим причинам исходный файл объединения ("sqlite3.c") рекомендуется для всех приложений.</p>
        <p class="font-bold">Использование амальгамации рекомендуется для всех приложений.</p>
        <p>Сборка SQLite непосредственно из отдельных файлов исходного кода, безусловно, возможна, но не рекомендуется. Для некоторых специализированных приложений может потребоваться изменить процесс сборки способами, которые невозможно сделать, используя
            только предварительно созданный исходный файл объединения, загруженный с веб-сайта. В таких ситуациях рекомендуется создать и использовать индивидуальное объединение (как описано ниже). Другими словами, даже если проект требует создания SQLite,
            начиная с отдельных исходных файлов, все же рекомендуется использовать исходный файл объединения в качестве промежуточного шага. </p>
        <h2>2. Компиляция интерфейса командной строки</h2>
        <p>Для сборки интерфейса командной строки требуется три исходных файла: </p>
        <ul>
            <li>
                sqlite3.c: исходный файл объединения SQLite</li>
            <li>sqlite3.h: файлы заголовков, сопровождающие sqlite3.c и определяющие интерфейсы языка C для SQLite.</li>
            <li>shell.c: Сама программа интерфейса командной строки. Это файл исходного кода C, который содержит определение подпрограммы main () и цикла, который запрашивает ввод данных пользователем и передает этот ввод в ядро ​​базы данных SQLite для обработки.</li>
        </ul>
        <p>Все три из вышеперечисленных исходных файлов содержатся в архиве объединения, доступном на странице загрузки.</p>
        <p>Чтобы построить CLI, просто поместите эти три файла в один каталог и скомпилируйте их вместе. Используя MSVC:</p>
        <p>
            <Code>cl shell.c sqlite3.c -Fesqlite3.exe</Code>
        </p>
        <p>В системах unix (или в Windows с использованием cygwin или mingw + msys) команда обычно выглядит примерно так:</p>
        <p>
            <Code>gcc shell.c sqlite3.c -lpthread -ldl -lm</Code>
        </p>
        <p>Библиотека pthreads необходима для обеспечения безопасности потоков SQLite. Но поскольку интерфейс командной строки является однопоточным, мы могли бы проинструктировать SQLite о том, что нужно выполнить сборку в небезопасном для потоков режиме
            и тем самым опустить библиотеку pthreads:</p>
        <p>
            <Code>gcc -DSQLITE_THREADSAFE = 0 shell.c sqlite3.c -ldl -lm</Code>
        </p>
        <p>Библиотека -ldl необходима для поддержки динамической загрузки, интерфейса sqlite3_load_extension() и функции SQL load_extension(). Если эти функции не требуются, их можно опустить, используя параметр времени компиляции SQLITE_OMIT_LOAD_EXTENSION:</p>
        <p>
            <Code>gcc -DSQLITE_THREADSAFE = 0 -DSQLITE_OMIT_LOAD_EXTENSION shell.c sqlite3.c</Code>
        </p>
        <p>Может потребоваться предоставить другие параметры времени компиляции, такие как -DSQLITE_ENABLE_FTS4 или -DSQLITE_ENABLE_FTS5 для полнотекстового поиска, -DSQLITE_ENABLE_RTREE для расширения поисковой системы R * Tree, -DSQLITE_ENABLE_JSON1 для
            включения функций JSON SQL или -DSQLITE_ENABLE_DBSTAT_Vstat_Vstat_Vstat_Vstat_Vstat_Vstat_Vstat_Vstat_ . Чтобы увидеть дополнительные комментарии в списках EXPLAIN, добавьте параметр -DSQLITE_ENABLE_EXPLAIN_COMMENTS. В системах unix добавьте
            -DHAVE_USLEEP = 1, если хост-машина поддерживает системный вызов usleep (). Добавьте -DHAVE_READLINE и библиотеки -lreadline и -lncurses, чтобы получить поддержку редактирования командной строки. Можно также указать некоторые переключатели
            оптимизации компилятора. (В предварительно скомпилированном интерфейсе командной строки, доступном для загрузки с веб-сайта SQLite, используется «-O».) Здесь существует бесчисленное множество возможных вариантов. Команда для компиляции полнофункциональной
            оболочки может выглядеть примерно так:</p>
        <p>
            <Code>gcc -Os -I. -DSQLITE_THREADSAFE = 0 -DSQLITE_ENABLE_FTS4 \
   -DSQLITE_ENABLE_FTS5 -DSQLITE_ENABLE_JSON1 \
   -DSQLITE_ENABLE_RTREE -DSQLITE_ENABLE_EXPLAIN_COMMENTS \
   -DHAVE_USLEEP -DHAVE_READLINE \
   shell.c sqlite3.c -ldl -lm -lreadline -lncurses -o sqlite3</Code>
        </p>
        <p>Ключевой момент заключается в следующем: построение интерфейса командной строки состоит из компиляции двух файлов на языке C. Файл shell.c содержит определение точки входа и цикла пользовательского ввода, а объединение SQLite sqlite3.c содержит
            полную реализацию библиотеки SQLite. </p>
        <h2>3. Компиляция интерфейса TCL </h2>
        <p>Интерфейс TCL для SQLite - это небольшой модуль, который добавляется в обычное объединение. В результате получился новый объединенный исходный файл под названием «tclsqlite3.c». Этот единственный исходный файл - это все, что нужно для создания
            общей библиотеки, которую можно загрузить в стандартный tclsh или по желанию с помощью команды загрузки TCL, или для создания автономного tclsh, который поставляется со встроенным SQLite. Копия объединения tcl является включены на страницу
            загрузки в виде файла в архиве TEA.</p>
        <p>Чтобы сгенерировать загружаемую TCL библиотеку для SQLite в Linux, достаточно будет следующей команды:</p>
        <p>
            <Code>gcc -o libtclsqlite3.so -shared tclsqlite3.c -lpthread -ldl -ltcl</Code>
        </p>
        <p>К сожалению, создание общих библиотек для Mac OS X и Windows далеко не так просто. Для этих платформ лучше всего использовать скрипт конфигурации и make-файл, которые включены в архив TEA.</p>
        <p>Чтобы сгенерировать автономный tclsh, который статически связан с SQLite, используйте этот вызов компилятора:</p>
        <p>
            <Code>gcc -DTCLSH = 1 tclsqlite3.c -ltcl -lpthread -ldl -lz -lm</Code>
        </p>
        <p>Уловка здесь - опция -DTCLSH = 1. Модуль интерфейса TCL для SQLite включает процедуру main (), которая инициализирует интерпретатор TCL и входит в цикл командной строки, когда он компилируется с -DTCLSH = 1. Приведенная выше команда работает как
            в Linux, так и в Mac OS X, хотя может потребоваться настроить параметры библиотеки в зависимости от платформы и версии TCL, с которой выполняется компоновка. </p>
        <h2>4. Строительство Объединения </h2>
        <p>Версии объединения SQLite, представленные на странице загрузки, обычно подходят для большинства пользователей. Однако некоторые проекты могут захотеть или нуждаться в создании собственных объединений. Распространенной причиной создания пользовательского
            объединения является использование определенных параметров времени компиляции для настройки библиотеки SQLite. Напомним, что объединение SQLite содержит много C-кода, который генерируется вспомогательными программами и скриптами. Многие параметры
            времени компиляции влияют на этот сгенерированный код и должны быть переданы генераторам кода до сборки объединения. Набор параметров времени компиляции, которые необходимо передать в генераторы кода, может варьироваться от одного выпуска
            SQLite к другому, но на момент написания этой статьи (около SQLite 3.6.20, 2009-11-04) набор параметров которые должны быть известны генераторам кода, включают: </p>
        <ul>
            <li>SQLITE_ENABLE_UPDATE_DELETE_LIMIT</li>
            <li>SQLITE_OMIT_ALTERTABLE</li>
            <li>SQLITE_OMIT_ANALYZE</li>
            <li>SQLITE_OMIT_ATTACH</li>
            <li>SQLITE_OMIT_AUTOINCREMENT</li>
            <li>SQLITE_OMIT_CAST</li>
            <li>SQLITE_OMIT_COMPOUND_SELECT</li>
            <li>SQLITE_OMIT_EXPLAIN</li>
            <li>SQLITE_OMIT_FOREIGN_KEY</li>
            <li>SQLITE_OMIT_PRAGMA</li>
            <li>SQLITE_OMIT_REINDEX</li>
            <li>SQLITE_OMIT_SUBQUERY</li>
            <li>SQLITE_OMIT_TEMPDB</li>
            <li>SQLITE_OMIT_TRIGGER</li>
            <li>SQLITE_OMIT_VACUUM</li>
            <li>SQLITE_OMIT_VIEW</li>
            <li>SQLITE_OMIT_VIRTUALTABLE</li>
        </ul>
        <p>Чтобы создать собственное объединение, сначала загрузите исходные отдельные исходные файлы на unix или unix-подобную платформу разработки. Убедитесь, что вы получили оригинальные исходные файлы, а не «предварительно обработанные исходные файлы».
            Полный набор исходных файлов можно получить либо со страницы загрузки, либо непосредственно из системы управления конфигурацией.</p>
        <p>Предположим, что исходное дерево SQLite хранится в каталоге с именем «sqlite». Запланируйте создание объединения в параллельном каталоге с именем (например) «bld». Сначала создайте соответствующий Makefile, запустив сценарий configure в верхней
            части исходного дерева SQLite или сделав копию одного из Makefile шаблона в верхней части исходного дерева. Затем вручную отредактируйте этот Makefile, чтобы включить желаемые параметры времени компиляции. Наконец запустите:</p>
        <p>
            <Code>make sqlite3.c</Code>
        </p>
        <p>Или в Windows с MSVC:</p>
        <p>
            <Code>nmake / f Makefile.msc sqlite3.c</Code>
        </p>
        <p>Цель make "sqlite3.c" автоматически создаст обычный исходный файл объединения "sqlite3.c", его файл заголовка "sqlite3.h" и исходный файл объединения "tclsqlite3.c", который включает интерфейс TCL. После этого необходимые файлы можно скопировать
            в каталоги проекта и скомпилировать в соответствии с процедурами, описанными выше. </p>
        <h2>5. Создание Windows DLL</h2>
        <p>Чтобы создать DLL SQLite для использования в Windows, сначала приобретите соответствующие объединенные файлы исходного кода sqlite3.c и sqlite3.h. Их можно либо загрузить с веб-сайта SQLite, либо создать из источников, как показано выше.</p>
        <p>Если файлы исходного кода находятся в рабочем каталоге, DLL можно создать с помощью MSVC с помощью следующей команды:</p>
        <p>
            <Code>cl sqlite3.c -link -dll -out: sqlite3.dll</Code>
        </p>
        <p>Приведенную выше команду следует запускать из командной строки MSVC Native Tools. Если на вашем компьютере установлен MSVC, вероятно, у вас есть несколько версий этой командной строки для собственных сборок для x86 и x64, а также, возможно, для
            кросс-компиляции в ARM. Используйте соответствующую командную строку в зависимости от желаемой библиотеки DLL.</p>
        <p>При использовании компилятора MinGW командная строка выглядит так:</p>
        <p>
            <Code>gcc -shared sqlite3.c -o sqlite3.dll</Code>
        </p>
        <p>Обратите внимание, что MinGW генерирует только 32-битные библиотеки DLL. Существует отдельный проект MinGW64, который можно использовать для создания 64-битных DLL. Предположительно синтаксис командной строки похож. Также обратите внимание, что
            последние версии MSVC генерируют библиотеки DLL, которые не работают в WinXP и более ранних версиях Windows. Поэтому для максимальной совместимости сгенерированной DLL рекомендуется использовать MinGW. Хорошее практическое правило - создавать
            32-разрядные библиотеки DLL с использованием MinGW и 64-разрядные библиотеки DLL с помощью MSVC.</p>
        <p>В большинстве случаев вы захотите дополнить приведенные выше базовые команды параметрами времени компиляции, подходящими для вашего приложения. Обычно используемые параметры времени компиляции включают: </p>
        <ul>
            <li>-Os - Оптимизировать по размеру. Сделайте DLL как можно меньше.</li>
            <li>-O2 - Оптимизировать по скорости. Это увеличит размер библиотеки DLL за счет развертывания циклов и встраивания функций.</li>
            <li>-DSQLITE_ENABLE_FTS4 - Включить код полнотекстовой поисковой системы в SQLite.</li>
            <li>-DSQLITE_ENABLE_RTREE - Включить расширение R-Tree.</li>
            <li>-DSQLITE_ENABLE_COLUMN_METADATA - это включает некоторые дополнительные API, которые требуются для некоторых распространенных систем, включая Ruby-on-Rails. </li>
        </ul>
        <p></p>
        <p><a href="./00_04.html">***&rArr;</a></p>
    </div>
</body>