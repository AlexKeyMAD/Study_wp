<head>
    <link rel="stylesheet" href="../../css/books_style.css">
</head>

<body>
    <div class="book-title">
        <p><a href="./12_3.html">&lArr;12.3 Типы итераторов</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="./12_5.html">12.5 Предикаты&rArr;</a></p>
        <h2>12.4. Итераторы потоков</h2>
        <hr>
        <div>
            <p>Итераторы представляют собой общую полезную концепцию для обработки последовательностей элементов в контейнерах. Однако контейнеры - это не единственное место, где мы находим последовательности элементов. Например, входной поток создает последовательность
                значений, и мы записываем последовательность значений в выходной поток. Следовательно, понятие итераторов может быть с пользой применено для ввода и вывода.</p>
            <p>Чтобы создать ostream_iterator, нужно указать, какой поток будет использоваться, и тип объектов, которые будут в него записываться. Например:</p>
            <img src="./12_4_p001.png" alt="">
            <p>Результатом присваивания значения *оо является запись присваиваемого значения в cout. Например:</p>
            <img src="./12_4_p002.png" alt="">
            <p>Это еще один способ записи канонического сообщения в стандартный вывод. Запись ++оо представляет собой имитацию записи в массив через указатель.</p>
            <p>Аналогично istream_iterator позволяет рассматривать входной поток как контейнер, предназначенный только для чтения. Здесь мы также должны указать используемый поток и тип ожидаемых значений: </p>
            <img src="./12_4_p003.png" alt="">
            <p>Входные итераторы используются в паре, представляющей последовательность, так что мы должны предоставить istream_iterator для указания конца ввода. Это делает istream_iterаtor по умолчанию:</p>
            <img src="./12_4_p004.png" alt="">
            <p>Как правило, istream_iterator и ostream_iterator не используются непосредственно. Вместо этого они передаются алгоритмам в качестве аргументов. Например, мы можем написать простую программу, которая читает файл, сортирует прочитанные слова,
                удаляет дубликаты и записывает результат в другой файл:</p>
            <img src="./12_4_p005.png" alt="">
            <p>ifstream-этo поток istream, который может быть присоединен к файлу, а ofstream - это поток ostream, который может быть присоединен к файлу (§10.7). Второй аргумент ostream_iterator используется для разграничения выходных значений.</p>
            <p>На самом деле эта программа длиннее, чем она должна быть. Мы читаем строки в vector, затем выполняем sort (),а затем записываем их, исключая дубликаты. Более элегантное решение заключается в том, чтобы вообще не хранить дубликаты. Это можно
                сделать, сохранив строки в множество, которое не сохраняет дубликаты и хранит свои элементы в упорядоченном виде (§ 11.4). Таким образом, мы могли бы заменить две строки, использующие вектор, одной, использующей множество, и заменить unique_сору()
                более простой функцией сору ( ) </p>
            <img src="./12_4_p006.png" alt="">
            <p>Мы используем имена ii, eos и оо по одному разу, так что программу можно сократить еще сильнее: </p>
            <img src="./12_4_p007.png" alt="">
            <p>Улучшает ли это последнее упрощение удобочитаемость - вопрос вкуса и опыта.</p>
        </div>
    </div>
</body>