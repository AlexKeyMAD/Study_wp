<head>
    <link rel="stylesheet" href="../../css/books_style.css">
</head>

<body>
    <div class="book-title">
        <p><a href="./4_5_3.html">&lArr;4.5.3 Избежание утечки ресурсов</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="./5_1.html">ГЛАВА 5. ОСНОВНЫЕ ОПЕРАЦИИ. 5.1. Введение&rArr;</a></p>
        <h2>4.6. Советы</h2>
        <hr>
        <div>
            <p>Приведенные здесь советы в основном представляют собой подмножество советов из С++ Core Guidelines [61]. Ссылки на них выглядят как [CG:ES.23], что означает 23-е правило из раздела Expressions and Statement. Обычно советы по ссылке более подробны,
                с обоснованием и примерами.</p>
            <ol>
                <li>Выражайте идеи непосредственно в коде; §4.1; [CG:P. I ].</li>
                <li>Конкретный тип является простейшей разновидностью класса. Где это возможно, предпочитайте конкретные типы более сложным классам и простым структурам данных; §4.2; [CG:C. l О].</li>
                <li>Для представления простых концепций используйте конкретные классы; §4.2. </li>
                <li>Для компонентов, критичных с точки зрения производительности, предпочитайте конкретные классы иерархиям классов; §4.2. </li>
                <li>Для управления инициализацией объектов определяйте конструкторы; §4.2.1, §5.1.1; [CG:C.40) [CG:C.41 ]. </li>
                <li>Делайте функцию членом только тогда, когда необходим непосредственный доступ к представлению класса; §4.2.1; [CG:C.4].</li>
                <li>Определяйте операторы, в первую очередь, для имитации обычного применения; §4.2.1; [CG:C.160). </li>
                <li>Используйте свободные функции для симметричных операторов; §4.2.1; [CG:C.161 ].</li>
                <li>Объявляйте функции-члены, которые не модифицируют объект, как cons t; §4.2.1.</li>
                <li>Если конструктор захватывает ресурс, необходим деструктор, освобождающий этот ресурс ; §4.2.2; [CG:C.20).</li>
                <li>Избегайте операций с "голыми" new и delete; §4.2.2; [CG:R.11 ].</li>
                <li>Для управления ресурсами используйте дескрипторы ресурсов и идиому RAII; §4.2.2; [CG:R. l ]. </li>
                <li>Если класс представляет собой контейнер, снабдите его конструктором на основе списка инициализации; §4.2.3; [CG:C. l 03). </li>
                <li>Когда требуется полное разделение интерфейса и реализации, используйте в качестве интерфейсов абстрактные классы; §4.3; [CG:C.122). </li>
                <li>Обращайтесь к полиморфным объектам с помощью указателей и ссылок; §4.3.</li>
                <li>Абстрактный класс обычно не нуждается в конструкторе; §4.3; [CG:C.126). </li>
                <li>Используйте иерархии классов для представления концепций с иерархической структурой; §4.5.</li>
                <li>Класс с виртуальной функцией должен иметь виртуальный деструктор; §4.5; [CG:C.127). </li>
                <li>Используйте ключевое слово overr ide для явного указания перекрытия в больших иерархиях классов; §4.5.1; [CG:C.128). </li>
                <li>При проектировании иерархии классов различайте наследование реализации и наследование интерфейса; §4.5.1; [CG:C.129).</li>
                <li>Используйте dynamic_cast там, где навигация по иерархии классов неизбежна; §4.5.2; [CG:C.146). </li>
                <li>Используйте dynamic _ cast для ссылочного типа там, где невозможность найти необходимый класс рассматривается как ошибка; §4.5.2; [CG:C.147]. </li>
                <li>Используйте dynamic _ cast для типа указателя там, где невозможность найти необходимый класс рассматривается как корректный вариант; §4.5.2; [CG:C.148]. </li>
                <li>Используйте unique _ptr или shared _ptr, чтобы не забывать удалять объекты, созданные с помощью оператора new; §4.5.3; [CG:C.149]. </li>
            </ol>
        </div>
    </div>
</body>