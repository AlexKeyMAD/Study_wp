<head>
    <link rel="stylesheet" href="../../css/books_style.css">
</head>

<body>
    <div class="book-title">
        <p><a href="./6_2_2.html">&lArr;6.2.2 Аргументы-значения шаблонов</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="./6_3.html">6.3 Параметризованные операции&rArr;</a></p>
        <h2>6.2.3. Вывод арrументов wабnона</h2>
        <hr>
        <div>
            <p>Рассмотрим применение шаблона стандартной библиотеки pair: </p>
            <img src="./6_2_3_p001.png" alt="">
            <p>Многим необходимость указывать аргументы-типы шаблона кажется утомительной, поэтому стандартная библиотека предлагает функцию rnake_pair(),которая выводит аргументы возвращаемого ею шаблона pair из аргументов функции:</p>
            <img src="./6_2_3_p002.png" alt="">
            <p>Это приводит к очевидному вопросу "Почему нельзя просто вывести параметры шаблона из аргументов конструктора?" В С++ 17 это возможно:</p>
            <img src="./6_2_3_p003.png" alt="">
            <p>Это проблема не только pair; функции rnake _очень распространены. Рассмотрим простой пример:</p>
            <img src="./6_2_3_p004.png" alt="">
            <p>Эта возможность упрощает запись и может устранить раздражение, вызываемое ошибочным вводом избыточных аргументов-типов шаблона. Однако это не панацея. Вывод типов может приводить к сюрпризам (как в функциях make_; так и в конструкторах). Рассмотрим
                следующий фрагмент кода: </p>
            <img src="./6_2_3_p005.png" alt="">
            <p>Тип строкового литерала в стиле С - const char* (§1.7.1). Если это не то, что вы хотели, добавьте суффикс s, чтобы сделать его корректной строкой string (§9.2). Если элементы списка инициализации имеют различные типы, компилятор не в состоянии
                вывести единственный тип элементов, и мы получаем сообщение об ошибке.</p>
            <p>Когда аргумент шаблона не может быть выведен из аргументов конструктора, мы можем помочь компилятору, предоставляя правwю вывода (deduction guide). Рассмотрим следующий фрагмент:</p>
            <img src="./6_2_3_p006.png" alt="">
            <p>Очевидно, что v2 должен быть Vector2&lt;int&gt;, но без помощи компилятор не может это вывести. В коде указано только, что существует конструктор из пары значений одного и того же типа. Без языковой поддержки концептов (§7.2) компилятор ничего
                не может предполагать об этом типе. Чтобы разрешить вывод, мы можем добавить правило вывода после объявления Vector2: </p>
            <img src="./6_2_3_p007.png" alt="">
            <p>То есть если компилятор встречает Vector2, инициализированный парой итераторов, то он должен вывести Vector2:: value_type как тип значения итератора. </p>
            <p>Применение правил вывода может сопровождаться очень тонкими эффектами, поэтому лучше всего разрабатывать шаблоны классов таким образом, чтобы правила вывода были не нужны. Однако в настоящий момент стандартная библиотека полна классов, которые
                (пока) не используют концепты (§7.2) и содержат неоднозначности, поэтому в ней используется довольно много правил вывода.</p>
        </div>
    </div>
</body>