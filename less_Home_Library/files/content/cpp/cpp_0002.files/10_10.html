<head>
    <link rel="stylesheet" href="../../css/books_style.css">
</head>

<body>
    <div class="book-title">
        <p><a href="./10_9.html">&lArr;10.9 Ввод-вывод в стиле С</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="./10_11.html">10.11 Советы&rArr;</a></p>
        <h2>10.10. Файловая система</h2>
        <hr>
        <div>
            <p>Большинство систем имеют понятие файловой системы, обеспечивающей доступ к информации, перманентно хранящейся в виде файлов. К сожалению, свойства файловых систем и способы манипулирования ими сильно различаются. Чтобы справиться с этим, библиотека
                файловой системы &lt;filesystem&gt; предлагает единый интерфейс для большинства возможно стей большинства файловых систем. Используя &lt;filesystem&gt;, мы можем переносимо
            </p>
            <ul>
                <li>выражать пути файловой системы и перемещаться по ней;</li>
                <li>исследовать типы файлов и связанные с ними разрешения.</li>
            </ul>
            <p>Библиотека файловой системы может работать с Unicode, но подробное объяснение этой темы выходит за рамки книги. Для получения подробной информации я рекомендую сайт cppreference [13] и документацию Boost для файловой системы [1]. </p>
            <p>Рассмотрим пример:</p>
            <img src="./10_10_p001.png" alt="">
            <p>Обратите внимание, что программа управления файловой системой обычно выполняется на компьютере вместе с другими программами. Таким образом, содержимое файловой системы между двумя командами может меняться. Например, хотя мы, в первую очередь,
                проверили, что файл f существует, это может оказаться неверным, когда в следующей строке мы выясняем, является ли f обычным файлом.</p>
            <p>path - довольно сложный класс, способный обрабатывать различные наборы символов и соглашения многих операционных систем. В частности, он может обрабатывать имена файлов из командной строки, переданные в main (). Например: </p>
            <img src="./10_10_p002.png" alt="">
            <p>Корректность ра th не проверяется до его использования. И даже тогда его корректность зависит от соглашений системы, в которой работает программа.</p>
            <p>Естественно, что ра th можно использовать для открытия файла: </p>
            <img src="./10_10_p003.png" alt="">
            <p>&lt;filesystem&gt; в дополнение к path предлагает типы для обхода каталогов и запросов о свойствах найденных файлов.</p>
            <img src="./10_10_p004.png" alt="">
            <p>Рассмотрим простой, но не такой уж нереальный пример: </p>
            <img src="./10_10_p005.png" alt="">
            <p>Строка может быть неявно преобразована в ра th, поэтому мы можем использовать print_directory следующим образом:</p>
            <img src="./10_10_p006.png" alt="">
            <p>Если бы я хотел перечислить еще и подкаталоги, я написал бы recursive_directory_iterator{р}. Если бы я хотел вывести записи в лексикографическом порядке, я скопировал бы пути ра th в вектор и отсортировал их перед выводом.
                <p>Класс ра th предлагает множество распространенных и полезных операций.</p>
                <img src="./10_10_p007.png" alt="">
                <p>Например:</p>
                <img src="./10_10_p008.png" alt="">
                <p>Мы используем раth как строку, из которой можем получить строки с различной информацией (например, расширение f. extension () . string () ). </p>
                <p>Обратите внимание, что соглашения об именах, естественные языки и кодировки строк отличаются большой сложностью. Абстракции библиотеки для файловых систем предлагают переносимость и существенное упрощение проблем.
                </p>
                <img src="./10_10_p009.png" alt="">
                <p>Многие операции имеют перегрузки, которые принимают дополнительные аргументы, такие как разрешения операционных систем. Обработка таковых выходит далеко за рамки данной книги, поэтому вам придется поискать соответствующую информацию, если
                    она вам понадобится, самостоятельно.</p>
                <p>Как и сору () , все операции имеют две версии. </p>
                <ul>
                    <li>Основная версия, показанная в таблице, например exists (р). Эта функция генерирует исключение filesystem_error в случае неудачи операции. </li>
                    <li>Версия с дополнительным аргументом error_code&, например exists (р, е) . Проверяйте значение е, чтобы убедиться в успешности операции или выяснить причины ее неудачи. </li>
                </ul>
                <p>Мы используем коды ошибок, когда ожидается, что при обычном использовании операции будут часто неудачны, и генерацию исключений, когда ошибка рассматривается как исключительная ситуация.</p>
                <p>Зачастую использование функции с запросом информации - самый простой и прямой подход к изучению свойств файла. Библиотека
                    <filesystem>
                        знает о нескольких распространенных типах файлов и классифицирует остальные как "иные".</p>
                <img src="./10_10_p010.png" alt="">
            </p>
        </div>
    </div>
</body>