<head>
    <link rel="stylesheet" href="../../css/books_style.css">
</head>

<body>
    <div class="book-title">
        <p><a href="./13_4_2.html">&lArr;13.4.2 bitset</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="./13_5.html">13.5 Альтернативы&rArr;</a></p>
        <h2>13.4.3. pair и tuple</h2>
        <hr>
        <div>
            <p>Часто нам нужны некоторые данные, которые являются просто данными, т.е. набором значений, а не объектом класса с четко определенной семантикой и инвариантом для его значения (§3.5.2). В таких случаях часто бывает идеальной простая структура
                с соответствующим набором именованных членов. Можно также позволить стандартной библиотеке написать для нас такое определение. Например, алгоритм стандартной библиотеки equal_range возвращает пару итераторов, задающих подпоследовательность,
                соответствующую предикату:</p>
            <img src="./13_4_3_p001.png" alt="">
            <p>Для заданной отсортированной последовательности [first;last] алгоритм equal range () возвращает значение типа pair, представляющее подпоследовательность, значения которой отвечают предикату cmp. Его можно использовать для выполнения поиска
                в отсортированной последовательности записей типа Record: </p>
            <img src="./13_4_3_p002.png" alt="">
            <p>Первый член pair называется first, а второй - second. Это наименование не особенно креативно и поначалу может показаться немного странным, но такое последовательное именование - благо, когда мы хотим написать обобщенный код. Там, где имена
                first и second слишком общие, можно использовать структурное связывание (§3.6.3): </p>
            <img src="./13_4_3_p003.png" alt="">
            <p>pair стандартной библиотеки (из заголовочного файла &lt;utility&gt;) довольно часто используется в стандартной библиотеке и в других местах. pair предоставляет такие операторы, как=,== и&lt;, если это делают ее элементы. Вывод типа позволяет
                легко создать пару pair без явного упоминания ее типа. Например:</p>
            <img src="./13_4_3_p004.png" alt="">
            <p>И pl, и р2 имеют тип pair&lt;vector&lt;string&gt;::iterator, int&gt;.</p>
            <p>pl, и р2 имеют тип pair&lt;vector&lt;string&gt;::iterator, int&gt;. Если требуется больше двух элементов (или меньше), можно использовать tuple (из того же заголовочного файла &lt;utility&gt;). tuple представляет собой гетерогенную последовательность
                элементов. Например: </p>
            <img src="./13_4_3_p005.png" alt="">
            <p>Более старый код тяготеет к использованию make_tuple (), так как вывод аргументов типа шаблона из аргументов конструктора появился только в C++l7. </p>
            <p>Доступ к членам tuple выполняется с помощью шаблона функции get: </p>
            <img src="./13_4_3_p006.png" alt="">
            <p>Элементы tuple нумеруются (начиная с нуля); используемые индексы должны быть константами.</p>
            <p>Доступ к членам кортежа tuple по индексу является общим, уродливым и в определенной мере чреватым ошибками. К счастью, элемент кортежа с уникальным типом в этом кортеже может быть "именован" по его типу:</p>
            <img src="./13_4_3_p007.png" alt="">
            <p>Можно использовать get&lt;&gt; и для записи: </p>
            <img src="./13_4_3_p008.png" alt="">
            <p>Как и пары, кортежи можно присваивать и сравнивать, если их элементы могут это делать. Как и к элементам tuple, к элементам pair можно получить доступ, используя get&lt;&gt;().</p>
            <p>Структурное связывание (§3.6.3) применимо к tuple так же, как и к pair. Однако, когда коду не требуется обобщенность, простая структура с именованными членами часто приводит к более понятному и легче поддерживаемому коду. </p>
        </div>
    </div>
</body>