<head>
    <link rel="stylesheet" href="../../css/books_style.css">
</head>

<body>
    <div class="book-title">
        <p><a href="./7_2.html">&lArr;7.2 Концепты (С++20)</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="./7_2_2.html">7.2.2 Перегрузка на основе концептов&rArr;</a></p>
        <h2>7.2.1. Применение концептов</h2>
        <hr>
        <div>
            <p>Большинство аргументов шаблонов должны удовлетворять определенным требованиям для правильной компиляции шаблона и правильного функционирования сгенерированного кода. Таким образом, большинство шаблонов должны быть ограниченными шаблонами (§6.2.1).
                Ключевое слово t ypename является наименее ограничивающим, требующим только того, чтобы аргумент был типом. Обычно мы можем сделать большее. Рассмотрим функцию sum() еще раз:</p>
            <img src="./7_2_1_p001.png" alt="">
            <p>Так код становится намного яснее. Как только мы определим, что означают понятия Sequence и NurnЬer, компилятор сможет отклонить неверные вызовы, просмотрев только интерфейс sum (),а не его реализацию. Это улучшит отчеты об ошибках.</p>
            <p>Однако спецификация интерфейса sum () неполная: я "забыл" сказать, что мы должны иметь возможность суммировать элементы Sequence с NumЬer. Мы можем это сделать:</p>
            <img src="./7_2_1_p002.png" alt="">
            <p>Value_type у последовательности представляет собой тип элементов в последовательности. Ari thmetic&lt;X, У&gt; - это концепт, указывающий, что мы можем выполнять арифметические вычисления с типами Х и У. Это спасает нас от случайных попыток
                вычисления sum() для vector&lt;string&gt; или vector&lt;int*&gt;, принимая при этом аргументы vector&lt;int&gt; и vector &lt;complex&lt;douЬle&gt;&gt;. </p>
            <p>В этом примере нам понадобился только оператор +=, но для простоты и гибкости мы не должны слишком строго ограничивать наш шаблонный аргумент. В частности, мы можем когда-нибудь захотеть выразить sum () в терминах + и =, а не +=, и тогда мы
                будем рады, что использовали более общий концепт (в данном случае -Arithmetic), а не узкое требование "наличия+=".</p>
            <p>Частичные спецификации, как в первой версии sum () с использованием концептов, могут быть очень полезными. Если спецификация не будет полной, некоторые ошибки не будут найдены до момента инстанцирования. Тем не менее частичные спецификации
                могут помочь выразить намерения и необходимы для плавного постепенного развития, когда мы изначально не знаем все необходимые требования. При наличии зрелых библиотек концептов исходные спецификации будут близки к совершенству. </p>
            <p>Неудивительно, что конструкция requires Ari thmetic&lt;Value type &lt;Seq&gt;, Num&gt; называется конструкцией requirements (конструкцией требований). Запись template&lt;Sequence Seq&gt; просто является сокращением для явного использования
                requires Sequence&lt;Seq&gt;. Если вам нравится многословность, можете воспользоваться следующей эквивалентной записью: </p>
            <img src="./7_2_1_p003.png" alt="">
            <p>С другой стороны, можно также воспользоваться эквивалентностью двух записей, чтобы написать</p>
            <img src="./7_2_1_p004.png" alt="">
            <p>В тех случаях, когда мы еще не можем использовать концепты, приходится ограничиваться соглашениями об именовании и комментариями, такими как</p>
            <img src="./7_2_1_p005.png" alt="">
            <p>Какую бы запись мы ни выбрали, важно спроектировать шаблон с семантически значимыми ограничениями его аргументов (§7.2.4).</p>
        </div>
    </div>
</body>