<head>
    <link rel="stylesheet" href="../../css/books_style.css">
</head>

<body>
    <div class="book-title">
        <p><a href="./13_5.html">&lArr;13.5 Альтернативы</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="./13_5_2.html">13.5.2 optional&rArr;</a></p>
        <h2>13.5.1. variant</h2>
        <hr>
        <div>
            <p>variant&lt;A, В, С&gt; зачастую является более удобной и безопасной альтернативой явному использованию union (§2.4). Возможно, простейшим примером применения является возврат либо значения, либо кода ошибки: </p>
            <img src="./13_5_1_p001.png" alt="">
            <p>При присваивании или инициализации variant значением он запоминает тип этого значения. Позже мы можем узнать, какой именно тип содержит variant, и извлечь значение. Например:</p>
            <img src="./13_5_1_p002.png" alt="">
            <p>Этот стиль нравится некоторым программистам, которым не нравятся исключения (см. §3.5.3), но есть и более интересные применения variant. Например, простому компилятору может потребоваться различать разные виды узлов с разными представлениями:</p>
            <img src="./13_5_1_p003.png" alt="">
            <p>Такая схема проверки альтернатив для принятия решения о соответствующих действиях настолько распространена и относительно неэффективна, что заслуживает непосредственной поддержки:</p>
            <img src="./13_5_1_p004.png" alt="">
            <p>Это в основном эквивалентно вызову виртуальной функции, но потенциально быстрее. Как и во всех случаях, в которых критична производительность, это ''потенциально быстрее" следует проверять измерениями. Для большинства применений разница в
                производительности незначительна. </p>
            <p>К сожалению, нужен overloaded, который не является стандартным. Это "кусок магии", который создает множество перегрузки из набора аргументов (обычно - лямбда-выражений):</p>
            <img src="./13_5_1_p005.png" alt="">
            <p>"Посетитель" visit применяет () к overload, который в соответствии с правилами вывода выбирает наиболее подходящее лямбда-выражение для вызова.
            </p>
            <p>Правила вывода - это механизм для разрешения тонких неоднозначностей, прежде всего для конструкторов шаблонов классов в фундаментальных библиотеках (§6.2.3). </p>
            <p>Если мы попытаемся обратиться к variant, хранящему тип, отличный от ожидаемого, то будет сгенерировано исключение bad_var iant_access. </p>
        </div>
    </div>
</body>