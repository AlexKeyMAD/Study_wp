<head>
    <link rel="stylesheet" href="../../css/books_style.css">
</head>

<body>
    <div class="book-title">
        <p><a href="./5_4_3.html">&lArr;5.4.3 Операции ввода-вывода</a>&nbsp;&nbsp;&nbsp;<a href="../cpp_0002.html">Содержание</a>&nbsp;&nbsp;&nbsp;<a href="./5_4_5.html">5.4.5 swap()&rArr;</a></p>
        <h2>5.4.4. Пользовательские литералы</h2>
        <hr>
        <div>
            <p>Одна из целей классов заключалась в том, чтобы лозволить лрограммисту лроектировать и реализовывать тилы, точно имитирующие встроенные тилы. Конструкторы обеслечивают инициализацию, которая эквивалентна (или даже лревосходит) гибкости и эффективности
                встроенной инициализации тила, но для встроенных тилов мы имеем также соответствующие литералы.</p>
            <ul>
                <li>123 лредставляет собой int.</li>
                <li>OxFFOOu лредставляет собой unsigned int.</li>
                <li>123.456 представляет собой double.</li>
                <li>"Surprise!" представляет собой const char [10]. </li>
            </ul>
            <p>Может быть полезным предоставить подобные литералы для пользовательских типов. Это делается путем определения смысла подходящего суффикса литерала, поэтому мы можем получить следующее.</p>
            <ul>
                <li>"Surprise!"s представляет собой std::string.</li>
                <li>123s представляет собой секунды.</li>
                <li>12.7i является мнимым числом, так что 12.7i + 47 представляет собой комплексное число (в данном случае - {47, 12.7}).</li>
            </ul>
            <p>В частности, в стандартной библиотеке с использованием соответствующих заголовочных файлов и пространств имен мы получаем доступ к следующим суффиксам.</p>
            <table class="border-none" border="1">
                <tr>
                    <th colspan="3">
                        <h4>Суффиксы стандартной библиотеки для литералов</h6>
                    </th>
                </tr>
                <tr>
                    <td>&lt;chrono&gt;</td>
                    <td>std::literals::chrono_literals</td>
                    <td>h, min, s, ms, us, ns</td>
                </tr>
                <tr>
                    <td>&lt;string&gt;</td>
                    <td>std::literals::string_literals</td>
                    <td>s</td>
                </tr>
                <tr>
                    <td>&lt;string_view&gt;</td>
                    <td>std::literals::chrono_literals</td>
                    <td>sv</td>
                </tr>
                <tr>
                    <td>&lt;complex&gt;</td>
                    <td>std::literals::complex_literals</td>
                    <td>i, il, if</td>
                </tr>
            </table>
            <p>Неудивительно, что литералы с такими определяемыми пользователем суффиксами называются пользовательскими литералами (user-defined literal - UDL). Они определяются с использованием литеральных операторов. Литеральный оператор преобразует литерал
                типа своего аргумента в его возвращаемый тип. Например, суффикс i для мнимых чисел может быть реализован следующим образом:</p>
            <img src="./5_4_4_p001.png" alt="">
            <p>Здесь</p>
            <ul>
                <li>operator"" указывает, что мы определяем литеральный оператор; </li>
                <li>i после индикатора литерального оператора "" представляет собой суффикс, для которого оператор определяет его значение; </li>
                <li>тип аргумента, long double, указывает, что суффикс (i) определен для литералов с плавающей точкой;</li>
                <li>возвращаемый тип, complex&lt;double&gt;, указывает тип возвращаемого значения.</li>
            </ul>
            <p>С учетом сказанного мы можем написать</p>
            <p>complex&lt;double&gt; z = 2.7182818+6.283185i;</p>
        </div>
    </div>
</body>