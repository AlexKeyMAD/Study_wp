<head>
    <link rel="stylesheet" href="../../css/books_style.css">
</head>

<body>
    <div class="book-title">
        <p><a href="./x_x.html">&lArr;6.1 Введение</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="./6_2_1.html">6.2.1 Ограниченные аргументы шаблона (С++20)&rArr;</a></p>
        <h2>6.2. Параметризованные типы</h2>
        <hr>
        <div>
            <p>Мы можем обобщить наш вектор элементов типа douЫe до вектора элементов произвольного типа, сделав его шаблоном и заменив конкретный тип douЫe параметром типа. Например:</p>
            <img src="./6_2_p001.png" alt="">
            <p>Префикс template&lt;typename Т&gt; делает Т параметром объявления, префиксом которого он является. Это С++-версия математического выражения &forall;Т­ - "для всех Т" (или, точнее, "для всех типов т"). Если вы хотите выразить математическое
                выражение "для всех Т, таких, что Р(Т)", вам нужны концепты (§6.2.1, §7.2). Применение ключевого слова class для введения параметра типа эквивалентно использованию t ypename, и в старом коде часто встречается префикс template&lt;class
                Т&gt;. </p>
            <p>Функции-члены могут быть определены аналогично:</p>
            <img src="./6_2_p002.png" alt="">
            <p>С учетом вышесказанного можно определить объекты Vector следующим образом:</p>
            <img src="./6_2_p003.png" alt="">
            <p>Пара символов &gt;&gt; в Vector&lt;list&lt;int&gt;&gt; завершает вложенные аргументы шаблона; это не ошибочно размещенный оператор ввода.</p>
            <p>Использовать Vector можно следующим образом:</p>
            <img src="./6_2_p004.png" alt="">
            <p>Чтобы обеспечить поддержку цикла for по диапазону для нашего Vector, мы должны определить подходящие функции begin () и end ():</p>
            <img src="./6_2_p005.png" alt="">
            <p>Теперь можно записать:</p>
            <img src="./6_2_p006.png" alt="">
            <p>Аналогично можно определить списки, векторы, отображения (т.е. ассоциативные массивы), неупорядоченные отображения (т.е. хеш-таблицы) и тому подобное как шаблоны (глава 11, "Контейнеры").</p>
            <p>Шаблоны представляют собой механизм времени компиляции, поэтому их использование не требует дополнительных затрат времени по сравнению с написанным вручную кодом. Фактически код, созданный для Vector &lt;double&gt;, идентичен коду, сгенерированному
                для версии Vector из главы 4, "Классы··. Кроме того, код, сгенерированный для vector&lt;double&gt; из стандартной библиотеки, скорее всего, будет лучшего качества (потому что в его реализацию вложено больше усилий).</p>
            <p>Шаблон плюс набор аргументов шаблона называется инстанцированием или специализацией. В конце процесса компиляции, во время инстанцирования, генерируется код для каждого инстанцирования, используемого в программе (§7.5). Для сгенерированного
                кода выполняются проверки типов, так что этот код оказывается таким же безопасным с точки зрения типов, как и написанный вручную. К сожалению, такая проверка часто выполняется в конце процесса компиляции, во время инстанцирования.</p>
        </div>
    </div>
</body>