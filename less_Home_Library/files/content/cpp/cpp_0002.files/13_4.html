<head>
    <link rel="stylesheet" href="../../css/books_style.css">
</head>

<body>
    <div class="book-title">
        <p><a href="./13_3.html">&lArr;13.3 Проверка выхода за границы диапазона: gsl::span</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="./13_4_1.html">13.4.1 array&rArr;</a></p>
        <h2>13.4. Специализированные контейнеры</h2>
        <hr>
        <div>
            <p>Стандартная библиотека предоставляет несколько контейнеров, которые не вписываются идеально в каркас STL (глава 11, "Контейнеры", глава 12, "Алгоритмы"). Примерами являются встроенные массивы, array и string. Я иногда называю их "почти контейнерами",
                но это не совсем справедливо: они содержат элементы, поэтому являются контейнерами, но у каждого есть ограничения или дополнительные возможности, которые делают их выпада ющими из контекста STL. Кроме того, их отдельное описание упрощает
                описание STL.</p>
            <table>
                <tr>
                    <th></th>
                    <th>"Почти контейнеры"</th>
                </tr>
                <tr>
                    <td>T[N]</td>
                    <td>Встроенный массив: непрерывная последовательность фиксированного размера из N элементов типа т; неявно преобразуется в Т*</td>
                </tr>
                <tr>
                    <td>array&lt;T,N&gt;</td>
                    <td>Непрерывная последовательность фиксированного размера из N элементов типа т; подобна встроенному массиву, но с решением большинства проблем</td>
                </tr>
                <tr>
                    <td>bitset&lt;N&gt;</td>
                    <td>Последовательность фиксированного размера из N битов</td>
                </tr>
                <tr>
                    <td>vector&lt;bool&gt;</td>
                    <td>Последовательность битов, компактно хранящаяся в специализации vector</td>
                </tr>
                <tr>
                    <td>pair&lt;T,U&gt;</td>
                    <td>Два элемента типов T и U</td>
                </tr>
                <tr>
                    <td>tuple&lt;T...&gt;</td>
                    <td>Последовательность произвольного количества элементов произвольных типов</td>
                </tr>
                <tr>
                    <td>basic_string&lt;C&gt;</td>
                    <td>Последовательность символов типа C; предоставляет строковые операции
                    </td>
                </tr>
                <tr>
                    <td>valarray&lt;T&gt;</td>
                    <td>Массив числовых значений типа T; предоставляет числовые операции
                    </td>
                </tr>
            </table>
            <p>Почему стандартная библиотека предоставляет так много контейнеров? Они служат распространенным, но различным (хотя и часто перекрывающимся) потребностям. Если бы стандартная библиотека их не предоставляла, многим программистам пришлось бы
                разрабатывать и реализовывать собственные контейнеры.</p>
            <ul>
                <li>pair и tuple - гетерогенные; все прочие контейнеры гомогенные (все их элементы одного и того же типа). </li>
                <li>Элементы array, vector и tuple располагаются в памяти непрерывно; forward_ list и map представляют собой связанные структуры.</li>
                <li>bi tset и vector&lt;bool&gt; хранят биты и обращаются к ним через прокси-объекты; все прочие контейнеры стандартной библиотеки могут хранить различные типы и непосредственно обращаться к хранимым элементам.</li>
                <li>basic_string требует, чтобы все были некоторой разновидностью символов и обеспечивали возможность работы со строками, как, например, конкатенация или операции, чувствительные к локали.</li>
                <li>valarray требует, чтобы все элементы были числами и обеспечивали возможность выполнения числовых операций. </li>
            </ul>
            <p>Все эти контейнеры можно рассматривать как предоставляющие специализированные услуги, необходимые для больших сообществ программистов. Ни один контейнер не может удовлетворить все эти потребности одновременно, потому что некоторые из них противоречивы,
                например "способность увеличиваться" и "гарантированно размещаться в фиксированном местоположении" или "элементы при добавлении не перемещаются" и "элементы располагаются в памяти непрерывно".</p>
        </div>
    </div>
</body>