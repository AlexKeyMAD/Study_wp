<head>
    <link rel="stylesheet" href="../../css/books_style.css">
</head>

<body>
    <div class="book-title">
        <p><a href="./13_9.html">&lArr;13.9 Функции типов</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="./13_9_2.html">13.9.2 Предикаты типов&rArr;</a></p>
        <h2>13.9.1. iterator_traits</h2>
        <hr>
        <div>
            <p>Алгоритм стандартной библиотеки sort () использует пару итераторов, которые должны определять последовательность (глава 12, "Алгоритмы"). Кроме того, эти итераторы должны обеспечивать произвольный доступ к элементам этой последовательности,
                т.е. они должны быть итераторами с произвольным доступом. Некоторые контейнеры, такие как forward_list, не предлагают такой возможности. В частности, forward_list является односвязным списком, поэтому индексация его элементов дорогостоящая,
                а разумного способа вернуться к предыдущему элементу не существует. Однако, как и большинство контейнеров, fоrward_1ist предлагает однонаправленные итераторы, которые можно использовать для обхода последовательности с помощью алгоритмов
                и циклов for (§6.2).</p>
            <p>Стандартная библиотека предоставляет механизм iterator_traits, который позволяет проверять, какой тип итератора предоставляется. С учетом этой возможности можно улучшить sort () для диапазона из §12.8 так, чтобы он принимал либо vector, либо
                forward_list. Например:</p>
            <img src="./13_9_1_p001.png" alt="">
            <p>Методы, необходимые для выполнения этой работы, полезны в общем случае.</p>
            <p>Сначала я пишу две вспомогательные функции, которые принимают дополнительный аргумент, указывающий, будет ли функция использоваться для итераторов с произвольным доступом или для однонаправленных итераторов. Версия с аргументами произвольного
                доступа тривиальна:</p>
            <img src="./13_9_1_p002.png" alt="">
            <p>Версия для однонаправленных итераторов копирует список в vector, сортирует и копирует обратно:</p>
            <img src="./13_9_1_p003.png" alt="">
            <p>Value_type&lt;For&gt; - это тип элементов For, называемый типом значения. Каждый итератор стандартной библиотеки имеет член value_type. Я получаю запись Value_type&lt;For&gt;, определяя псевдоним типа (§6.4.2): </p>
            <img src="./13_9_1_p004.png" alt="">
            <p>Таким образом, для vector&lt;X&gt; запись Value type&lt;X&gt; представляет собой Х.</p>
            <p>Настоящая "магия типов" состоит в выборе вспомогательной функции:</p>
            <img src="./13_9_1_p005.png" alt="">
            <p>Здесь я использую две функции типа: I tera tor type&lt;C&gt; возвращает тип итератора С (т.е. С::iterator), а затем Iterator_саtegory&lt;Iter&gt;{} создает значение "дескриптора", указывающее разновидность предоставленного итератора:
            </p>
            <ul>
                <li>std::random_access_iterator_tag, если итератор С поддерживает произвольный доступ; </li>
                <li>std::forward_iterator_tag, если итератор С поддерживает однонаправленную итерацию. </li>
            </ul>
            <p>Теперь можно выбирать между двумя алгоритмами сортировки во время компиляции. Этот метод, называемый диспетчеризацией дескрипторов, является одним из нескольких методов, используемых в стандартной библиотеке и других местах для повышения гибкости
                и производительности.</p>
            <p>Мы могли бы определить Iterator_type следующим образом:</p>
            <img src="./13_9_1_p006.png" alt="">
            <p>Однако, чтобы распространить эту идею на типы без типов-членов, такие как указатели, поддержка диспетчеризации дескрипторов в стандартной библиотеке представлена в виде шаблона класса iterator_traits из заголовочного файла &lt;iterator&gt;.
                Специализация для указателей выглядит следующим образом:</p>
            <img src="./13_9_1_p007.png" alt="">
            <p>Теперь можно написать:</p>
            <img src="./13_9_1_p008.png" alt="">
            <p>Теперь int * может использоваться в качестве итератора с произвольным доступом, несмотря на отсутствие типа-члена; Iterator_category&lt;int*&gt; представляет собой random_access_ iterator_tag. </p>
            <p>Многие свойства и методы, основанные на свойствах, станут ненужными при появлении концептов (§7.2). Рассмотрим версию примера sort () с концептами: </p>
            <img src="./13_9_1_p009.png" alt="">
            <p>Прогресс налицо.</p>
        </div>
    </div>
</body>