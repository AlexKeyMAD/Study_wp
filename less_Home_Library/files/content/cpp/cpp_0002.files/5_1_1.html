<head>
    <link rel="stylesheet" href="../../css/books_style.css">
</head>

<body>
    <div class="book-title">
        <p><a href="./5_1.html">&lArr;5.1 Введение</a>&nbsp;&nbsp;&nbsp;<a href="../cpp_0002.html">Содержание</a>&nbsp;&nbsp;&nbsp;<a href="./5_1_2.html">5.1.2 Преобразования типов&rArr;</a></p>
        <h2>5.1.1. Основные операции</h2>
        <hr>
        <div>
            <p>Построение объектов играет ключевую роль во многих nроектах. Широкий сnектр их nрименения отражается в диаnазоне и гибкости языковых возможностей для nоддержки инициализации.</p>
            <p>Конструкторы, деструкторы, оnерации коnирования и nеремещения для тиnа логически нераздельны. Мы должны оnределять их как согласованный набор или в nротивном случае страдать от логических проблем или проблем с nроизводительностью. Если класс
                Х имеет деструктор, который выnолняет нетривиальную задачу, такую как освобождение nамяти или блокировки, классу, вероятно, nотребуется nолный набор функций:</p>
            <img src="./5_1_1_p001.png" alt="">
            <p>Имеется nять ситуаций, когда объект может быть скоnирован или nеремещен: когда он выстуnает в роли</p>
            <ul>
                <li>источника nрисваивания;</li>
                <li>инициализатора объекта;</li>
                <li>аргумента функции;</li>
                <li>возвращаемого значения функции;</li>
                <li>исключения.</li>
            </ul>
            <p>Присваивание исnользует оnератор коnирующего или nеремещающего nрисваивания. В nринциnе, в других случаях исnользуется копирующий или nеремещающий конструктор. Однако вызов коnирующего или nеремещающего конструктора часто отбрасывается при
                оnтимизации nутем конструирования объекта, исnользуемого для инициализации сnрава, непосредственно в целевом объекте. Наnример:</p>
            <img src="./5_1_1_p002.png" alt="">
            <p>В этой ситуации компилятор обычно создает Х из make() непосредственно в х, тем самым отменяя (аннулируя) копирование (сору elision). </p>
            <p>В дополнение к инициализации именованных объектов и объектов в свободной памяти конструкторы используются для инициализации временных объектов и для реализации явного преобразования типов.</p>
            <p>За исключением "обычного конструктора", эти специальные функции-члены генерируются компилятором по мере необходимости. Если вы хотите явно затребовать генерацию реализаций по умолчанию, можете сделать это следующим образом:</p>
            <img src="./5_1_1_p003.png" alt="">
            <p>Если вы явным образом указали генерацию некоторых специальных функций по умолчанию, то прочие определения по умолчанию генерироваться не будут </p>
            <p>Если у класса есть член-указатель, обычно рекомендуется явно записывать операции копирования и перемещения. Причина в том, что указатель может указывать на нечто, что класс должен удалить, и в этом случае выполняемое по умолчанию почленное
                копирование будет неправильным. Или напротив - член может указывать на то, что класс не должен удалять. В любом случае читателю кода хотелось бы это точно знать. Пример можно найти в §5.2.1.</p>
            <p>Хорошее эмпирическое правило (иногда называемое правwюм нуля) состоит в том, чтобы определить либо все основные операции, либо ни одну из них (используя генерацию по умолчанию для всех них). Например: </p>
            <img src="./5_1_1_p004.png" alt="">
            <p>В этом случае компилятор при необходимости будет генерировать почленные конструктор, копирующий конструктор, перемещающий конструктор и деструктор по умолчанию, и все они будут иметь правильную семантику.</p>
            <p>В дополнение к = default имеется конструкция = delete, указывающая, что данная операция не должна генерироваться. Базовый класс в иерархии классов является классическим примером того, где не следует разрешать почленное копирование. Например:</p>
            <img src="./5_1_1_p005.png" alt="">
            <p>Конструкция = delete приводит к тому, что попытка использования удаленной функции является ошибкой времени компиляции; = delete может использоваться для подавления любой функции, а не только важных функций-членов.</p>
        </div>
    </div>
</body>