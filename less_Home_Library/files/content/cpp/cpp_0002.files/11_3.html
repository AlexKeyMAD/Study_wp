<head>
    <link rel="stylesheet" href="../../css/books_style.css">
</head>

<body>
    <div class="book-title">
        <p><a href="./11_2_2.html">&lArr;11.2.2 Проверка выхода за границы диапазона</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="./11_4.html">11.4 map&rArr;</a></p>
        <h2>11.3. list</h2>
        <hr>
        <div>
            <p>Стандартная библиотека предлагает двусвязный список под названием list.</p>
            <img src="./11_3_p001.png" alt="">
            <p>Мы используем list для последовательностей, в которые хотим эффективно вставлять (и удалять) элементы, не перемещая при этом другие элементы. Вставка и удаление записей телефонной книги может быть распространенной операцией, поэтому для представления
                простой телефонной книги подходящей структурой данных может оказаться list. Например: </p>
            <img src="./11_3_p002.png" alt="">
            <p>Используя связанный список, мы, как правило, не обращаемся к элементам с использованием индексов, как обычно делаем это для векторов. Вместо этого мы можем искать в списке элемент с заданным значением. Для этого мы воспользуемся тем фактом,
                что list представляет собой последовательность, описанную в главе 12, "Алгоритмы":</p>
            <img src="./11_3_p003.png" alt="">
            <p>Поиск s начинается с начала списка и продолжается до тех пор, пока не будет найдено значение s или не будет достигнут конец списка phone_bооk. </p>
            <p>Иногда нам нужно идентифицировать элемент списка. Например, мы можем удалить элемент или вставить новый элемент перед ним. Для этого мы используем итератор: итератор списка идентифицирует элемент списка и может использоваться для итераций
                по списку (отсюда и его имя). Каждый контейнер стандартной библиотеки предоставляет функции begin () и end () , которые возвращают итераторы, указывающие на первый элемент и на элемент, следующий за последним, соответственно (глава 12,
                "Алгоритмы"). Используя итераторы явным образом, мы можем - менее элегантно - переписать функцию get_number () следующим образом: </p>
            <img src="./11_3_p004.png" alt="">
            <p>На самом деле это примерно то же самое, как если бы компилятор реализовал цикл for по диапазону - более кратко и менее чревато ошибками. Для данного итератора р запись *р - это элемент, на который ссылается итератор; ++р перемешает р для обращения
                к следующему элементу, а когда р относится к классу с членом m, то запись p->m эквивалентна записи ( *р) . m. </p>
            <p>Добавление элементов в list и удаление их оттуда выполняется очень легко: </p>
            <img src="./11_3_p005.png" alt="">
            <p>Для списка list вызов insert (р, elem) вставляет элемент с копией значения elem перед элементом, на который указывает р. Здесь р может быть итератором, указывающим на элемент, следующий за концом списка. И наоборот, erase (р) удаляет элемент,
                на который указывает р, и уничтожает его.</p>
            <p>Эти примеры с list могут быть записаны идентично с использованием vector и (что кажется удивительным, если вы не понимаете архитектуру машины) лучше работают с небольшим вектором, чем с небольшим списком. Когда все, что мы хотим, - это последовательность
                элементов, у нас есть выбор между использованием vector и list. Если у вас нет особой причины поступить иначе, используйте vector. Вектор лучше работает в случае обхода (например, при работе find () и count ()) и при сортировке и поиске
                (например, с помощью sort () и equal _ range (), § 12.6, § 13.4.3). </p>
            <p>Стандартная библиотека предлагает также односвязный список, именуемый forward list.</p>
            <img src="./11_3_p006.png" alt="">
            <p>Список forward_list отличается от list тем, что допускает итерации только в одном направлении. Главная цель его существования - сэкономить память. В нем нет необходимости хранить указатель на предшественника в каждом элементе, а размер пустого
                списка forward list - всего лишь один указатель. forward_list даже не хранит количество элементов. Если вам нужно количество элементов, вы можете посчитать его сами. </p>
        </div>
    </div>
</body>