<head>
    <link rel="stylesheet" href="../../css/books_style.css">
</head>

<body>
    <div class="book-title">
        <p><a href="./12_4.html">&lArr;12.4 Итераторы потоков</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="./12_6.html">12.6 Обзор алгоритмов&rArr;</a></p>
        <h2>12.5. Предикаты</h2>
        <hr>
        <div>
            <p>В приводимых до настоящего времени примерах алгоритмы просто "встроены" в действие, которое необходимо выполнить для каждого элемента последовательности. Однако зачастую мы хотим сделать это действие параметром алгоритма. Например, алгоритм
                find (§ 12.2, § 12.6) обеспечивает удобный способ поиска определенного значения. Более общий вариант ищет элемент, для которого выполняется указанное требование - предикат. Например, мы можем захотеть выполнить поиск в map первого значения,
                большего 42. Отображение позволяет получить доступ к своим элементам как к последовательности пар (ключ.значение), чтобы мы могли выполнить поиск вmap&lt;string, int&gt; пары pair&lt;const string, int&gt;, где int больше 42: </p>
            <img src="./12_5_p001.png" alt="">
            <p>Здесь Greater_than - функциональный объект (§6.3.2), хранящий значение (42), с которым выполняется сравнение:</p>
            <img src="./12_5_p002.png" alt="">
            <p>В качестве альтернативы можно воспользоваться лямбда-выражением (§6.3.2): </p>
            <img src="./12_5_p003.png" alt="">
            <p>Предикат не должен модифицировать элементы, к которым применяется. </p>
        </div>
    </div>
</body>