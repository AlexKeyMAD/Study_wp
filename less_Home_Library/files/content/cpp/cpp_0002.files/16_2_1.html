<head>
    <link rel="stylesheet" href="../../css/books_style.css">
</head>

<body>
    <div class="book-title">
        <p><a href="./16_2.html">&lArr;16.2 Эволюция возможностей С++</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="./16_2_2.html">16.2.2 Возможности языка С++14&rArr;</a></p>
        <h2>16.2.1. Возможности языка С++11</h2>
        <hr>
        <div>
            <p>Такой список возможностей языка может быть сложным для восприятия. Помните, что ни одна языковая возможность не предназначена для использования изолированно от других. В частности, большинство функциональных возможностей, которые являются
                новинками С++ 11, не имеют смысла в изоляции от инфраструктуры, предоставляемой более старыми функциональными возможностями языка.</p>
            <ol>
                <li>Унифицированная и общая инициализация с использованием списков { } (§ 1.4, §4.2.3)</li>
                <li>Вывод типов из инициализаторов: auto (§ 1.4) </li>
                <li>Предотвращение сужения(§ 1.4) </li>
                <li>Обобщенные и гарантированные константные выражения: constexpr (§ 1.6)</li>
                <li>Цикл for для диапазона(§ 1.7)</li>
                <li>Ключевое слово для нулевого указателя: nullptr (§ 1.7)</li>
                <li>Строго типизированные перечисления с областью видимости: enum class (§2.5)</li>
                <li>Проверки времени компиляции: static_assert (§3.5.5) </li>
                <li>Отображение {} - списков на std::initiаlizеr_list на уровне языка (§4.2.3)</li>
                <li>Ссылки на r-значения, обеспечивающие семантику перемещения (§5.2.2) </li>
                <li>Вложенные аргументы шаблонов завершаются &gt;&gt; (не требуется пробел между символами &gt;) </li>
                <li>Лямбда-выражения (§6.3 .2)</li>
                <li>Шаблоны с переменным количеством параметров (§7.4)</li>
                <li>Псевдонимы типов и шаблонов (§6.4.2) </li>
                <li>Символы Unicode</li>
                <li>Целочисленный тип long long</li>
                <li>Управление выравниванием: alignas и alignof</li>
                <li>Возможность использовать тип выражения как тип в объявлении: decl type
                </li>
                <li>Необработанные строковые литералы (§9.4) </li>
                <li>Обобщенные POD (Plain Old Data- обычные старые данные) </li>
                <li>Обобщенные union</li>
                <li>Локальные классы в качестве аргументов шаблонов</li>
                <li>Синтаксис указания возвращаемого типа в виде суффикса</li>
                <li>Синтаксис атрибутов и два стандартных атрибута: [[carries_depen dency]] и [[noreturn]] </li>
                <li>Предотвращение распространения исключений: спецификатор noex cept (§3.5.1) </li>
                <li>Проверка возможности генерации исключений в выражениях: оператор noexcept
                </li>
                <li>Возможности С99: расширенные целочисленные типы (например, правила для необязательных более длинных целочисленных типов); конкатенация узких/широких строк; _STDC_HOSTED_; _Pragma (Х); макросы с переменным количеством аргументов и пустые
                    аргументы макросов</li>
                <li>_func_ как имя строки, хранящей имя текущей функции</li>
                <li>inline пространства имен</li>
                <li>Делегирование конструкторов</li>
                <li>Инициализаторы членов в классе (§5.1.3)</li>
                <li>Управление генерируемыми функциями: default и delete (§5.1.1) </li>
                <li>Операторы явного преобразования типов</li>
                <li>Пользовательские литералы (§5.4.4) </li>
                <li>Более явное управление инстанцированием template: extern template
                </li>
                <li>Аргументы шаблонов по умолчанию для шаблонов функций</li>
                <li>Наследование конструкторов</li>
                <li>Управление перекрытием: override и final (§4.5.1) </li>
                <li>Более простое и более общее правило SFINAE (Substitution Failure ls Not An Error - ошибка подстановки ошибкой не является)</li>
                <li>Модель памяти (§ 15.1)</li>
                <li>Память, локальная для потока: thread_local</li>
            </ol>
            <p>Более полное описание изменений С++11 по сравнению с С++98 приведено в [59]. </p>
        </div>
    </div>
</body>