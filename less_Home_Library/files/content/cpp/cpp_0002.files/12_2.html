<head>
    <link rel="stylesheet" href="../../css/books_style.css">
</head>

<body>
    <div class="book-title">
        <p><a href="./12_1.html">&lArr;12.1 Введение</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="./12_3.html">12.3 Типы итераторов&rArr;</a></p>
        <h2>12.2. Применение итераторов</h2>
        <hr>
        <div>
            <p>Для контейнера можно получить несколько итераторов, ссылающихся на полезные элементы; begin () и end () - лучшие тому примеры. Кроме того, многие алгоритмы возвращают итераторы. Например, стандартный алгоритм find ищет значение в последовательности
                и возвращает итератор найденного элемента:</p>
            <img src="./12_2_p001.png" alt="">
            <p>Как и многие другие алгоритмы поиска стандартной библиотеки, find возвращает end() , чтобы указать, что поиск завершился неудачно и искомый элемент не найден. Эквивалентное, более короткое определение has_с() имеет следующий вид: </p>
            <img src="./12_2_p002.png" alt="">
            <p>Более интересным упражнением был бы поиск местоположений всех вхождений символа в строку. Мы можем вернуть множество вхождений как вектор итераторов строк. Возврат вектора эффективен, потому что вектор обеспечивает семантику перемещения (§5.2.1
                ). Предполагая, что мы захотим изменить символы в найденных местоположениях, мы передаем неконстантную строку:</p>
            <img src="./12_2_p003.png" alt="">
            <p>Мы проходим по строке с помощью обычного цикла, перемещая итератор р вперед по одному элементу за раз с использованием оператора ++ и просматривая элементы с помощью оператора разыменования *. Мы могли бы проверить работоспособность find_all()
                следующим образом: </p>
            <img src="./12_2_p004.png" alt="">
            <p>Этот вызов find_all () графически можно представить следующим образом.</p>
            <img src="./12_2_p005.png" alt="">
            <p>Итераторы и стандартные алгоритмы работают одинаково с каждым стандартным контейнером, для которого их использование имеет смысл. Следовательно, можно обобщить функцию find_аll(): </p>
            <img src="./12_2_p006.png" alt="">
            <p>Ключевое слово typename необходимо, чтобы сообщить компилятору, что итератор С::iterator представляет собой тип, а не значение некоторого типа, например целое число 7. Эту деталь реализации можно скрыть, вводя псевдоним типа (§6.4.2) для Iterator:
                </p>
            <img src="./12_2_p007.png" alt="">
            <p>Теперь можно написать следующий код:</p>
            <img src="./12_2_p008.png" alt="">
            <p>Итераторы используются для разделения алгоритмов и контейнеров. Алгоритм управляет своими данными через итераторы и ничего не знает о контейнере, в котором хранятся элементы. И наоборот, контейнер ничего не знает об алгоритмах, работающих
                с его элементами; все, что он делает, - это предоставляет итераторы по запросу (например, begin () и end () ). Такая модель разделения хранилища данных и алгоритма обеспечивает очень обобщенное и гибкое программное обеспечение.</p>
        </div>
    </div>
</body>