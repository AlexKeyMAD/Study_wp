<head>
    <link rel="stylesheet" href="../../css/books_style.css">
</head>

<body>
    <div class="book-title">
        <p><a href="./12_5.html">&lArr;12.5 Предикаты</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="./12_7.html">12.7 Концепты (С++20)&rArr;</a></p>
        <h2>12.6. Обзор аnrоритмов</h2>
        <hr>
        <div>
            <p>Общее определение алгоритма - "набор конечного числа правил, задающих последовательность выполнения операций для решения задачи определенного типа ". [и] и.1wеет пять важных особенностей: Конечность ." Определенность... Ввод ". Вывод... Эффективность"
                [31, § 1.1 ]. В контексте стандартной библиотеки С++ алгоритм является шаблоном функции, работающим с последовательностями элементов.</p>
            <p>Стандартная библиотека предоставляет десятки алгоритмов. Алгоритмы определены в пространстве имен s td и представлены в заголовочном файле &lt;algori thm&gt;. Эти алгоритмы стандартной библиотеки принимают в качестве входных данных последовательности.
                Полуоткрытая последовательность от Ь до е записывается как [Ь:е). Вот несколько примеров. </p>
            <table border="1">
                <tr>
                    <th></th>
                    <th>Избранные стандартные алгоритмы</th>
                </tr>
                <tr>
                    <td>f=for_each(b,e,f) </td>
                    <td>Для каждого элементах в [Ь:е) выполнить f (х) </td>
                </tr>
                <tr>
                    <td>p=find(b,e,x) </td>
                    <td>р - первый элемент в [Ь:е), такой, что *р==х</td>
                </tr>
                <tr>
                    <td>p=find_if(b,e,f) </td>
                    <td>р - первый элемент в [Ь:е), такой, что f ( *р)</td>
                </tr>
                <tr>
                    <td>n=count(b,e,x)</td>
                    <td>п - количество элементов *q в [Ь:е), таких, что *q==x</td>
                </tr>
                <tr>
                    <td>n=count_if(b,e,f) </td>
                    <td>п - количество элементов *q в [Ь:е), таких, что f ( *q)</td>
                </tr>
                <tr>
                    <td>replace(b,e,v,v2) </td>
                    <td>Замена элементов *q в [Ь:е), таких, что *q==v, на v2 </td>
                </tr>
                <tr>
                    <td>replace_if(b,e,f,v2) </td>
                    <td>Замена элементов *q в [Ь:е), таких, что f ( *q), на v2</td>
                </tr>
                <tr>
                    <td>p=copy(b,e,out) </td>
                    <td>Копирование (b:е) в (out:p)</td>
                </tr>
                <tr>
                    <td>p=copy_if(b,e,out,f) </td>
                    <td>Копирование элементов *q из [Ь:е), таких, что f ( *q), в [out:p) </td>
                </tr>
                <tr>
                    <td>p=move(b,e,out) </td>
                    <td>Перемещение [Ь:е) в [out:p) </td>
                </tr>
                <tr>
                    <td>p=unique_copy(b,e,out) </td>
                    <td>Копирование [Ь:е) в [out:p); соседние дубликаты не копируются </td>
                </tr>
                <tr>
                    <td>sort (Ь, е) </td>
                    <td>Сортировка элементов [Ь:е) с использованием &lt; в качестве критерия сортировки</td>
                </tr>
                <tr>
                    <td>sort (Ь, е, f) </td>
                    <td>Сортировка элементов [Ь:е) с испольэованием f в качестве критерия сортировки</td>
                </tr>
                <tr>
                    <td>(pl, р2) =equal range (Ь, е, v) </td>
                    <td>[pl:p2) является подпоследовательностью отсортированной последовательности [Ь:е) со значением v; по сути, бинарный поиск v </td>
                </tr>
                <tr>
                    <td>p=merge (Ь, е, Ь2, е2, out)</td>
                    <td>Слияние двух отсортированных последовательностей, [Ь:е) и [Ь2:е2), в [out:p)</td>
                </tr>
                <tr>
                    <td>p=merge (Ь, е, Ь2, е2, out, f)</td>
                    <td>Слияние двух отсортированных последовательностей, [Ь:е) и [Ь2:е2), в [out:p) с использованием f для сравнения
                    </td>
                </tr>
            </table>
            <p>Эти и многие другие алгоритмы (например, § 14.3) могут применяться к элементам контейнеров, строк и встроенных массивов. </p>
            <p>Некоторые алгоритмы, такие как replace () и sort (), изменяют значения элементов, но ни один алгоритм не добавляет или не удаляет элементы контейнера. Причина в том, что последовательность не идентифицирует контейнер, который содержит ее элементы.
                Чтобы добавить или удалить элементы, вам нужно что-то, знающее о конкретном контейнере (например, back_inserter; §12.1), или непосредственное обращение к контейнеру (например, push_back () или erase (); § 11.2). </p>
            <p>Для операций, передаваемых в качестве аргументов, очень часто применяются лямбда-выражения. Например:</p>
            <img src="./12_6_p001.png" alt="">
            <p>Алгоритмы стандартной библиотеки, как правило, более тщательно разработаны, специфицированы и реализованы, чем средний созданный вручную цикл, поэтому их нужно знать и использовать, предпочитая коду, написанному на "голом" языке. </p>
        </div>
    </div>
</body>