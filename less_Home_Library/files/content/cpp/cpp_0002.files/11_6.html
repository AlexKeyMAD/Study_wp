<head>
    <link rel="stylesheet" href="../../css/books_style.css">
</head>

<body>
    <div class="book-title">
        <p><a href="./11_5.html">&lArr;11.5 unordered_map</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="./11_7.html">11.7 Советы&rArr;</a></p>
        <h2>11.6. Обзор контейнеров</h2>
        <hr>
        <div>
            <p>Стандартная библиотека предоставляет ряд наиболее общих и полезных типов контейнеров, позволяющих программисту выбрать контейнер, который наилучшим образом удовлетворяет потребностям приложения.</p>
            <table border="1">
                <tr>
                    <th class="table-w-30per"></th>
                    <th>Стандартные контейнеры</th>
                </tr>
                <tr>
                    <td>vector&lt;T&gt;</td>
                    <td>Вектор переменного размера (§ 11.2) </td>
                </tr>
                <tr>
                    <td>list&lt;T&gt;</td>
                    <td>Двусвязный список (§11.З)</td>
                </tr>
                <tr>
                    <td>forward list&lt;T&gt;</td>
                    <td>Односвязный список</td>
                </tr>
                <tr>
                    <td>deque&lt;T&gt;</td>
                    <td>Двусторонняя очередь</td>
                </tr>
                <tr>
                    <td>set&lt;T&gt;</td>
                    <td>Множество (отображение только с ключом, без значения)</td>
                </tr>
                <tr>
                    <td>multiset&lt;T&gt;</td>
                    <td>Множество, в котором одно и то же значение может встречаться неоднократно</td>
                </tr>
                <tr>
                    <td>map&lt;K,V&gt;</td>
                    <td>Ассоциативный массив - отображение (§ 11.4)</td>
                </tr>
                <tr>
                    <td>multimap&lt;K,V&gt;</td>
                    <td>Отображение, в котором один и тот же ключ может встречаться неоднократно</td>
                </tr>
                <tr>
                    <td>unordered_map&lt;K,V&gt;</td>
                    <td>Отображение с использованием поиска на основе хеширования (§11.5) </td>
                </tr>
                <tr>
                    <td>unordered_multimap&lt;K,V&gt;</td>
                    <td>Мультиотображение с использованием поиска на основе хеширования</td>
                </tr>
                <tr>
                    <td>unordered set&lt;T&gt;</td>
                    <td>Множество с использованием поиска на основе хеширования </td>
                </tr>
                <tr>
                    <td>unordered multiset&lt;T&gt;</td>
                    <td>Мультимножество с использованием поиска на основе хеширования</td>
                </tr>
            </table>
            <p>Неупорядоченные контейнеры оптимизированы для поиска с помощью ключа (часто строки); другими словами, они реализуются с использованием хеш-таблиц. </p>
            <p>Контейнеры определены в пространстве имен std и представлены в заголовочных файлах &lt;vector&gt;, &lt;list&gt;, &lt;map&gt; и т.д. (§8.3). Кроме того, стандартная библиотека предоставляет адаптеры контейнеров queue&lt;T&gt;, stack&lt;T&gt;
                и priority_queue&lt;T&gt;. Познакомьтесь с ними, если ваше приложение нуждается в соответствующих структурах данных. Стандартная библиотека предоставляет также более специализированные контейнерообразные типы, такие как массив фиксированного
                размера array&lt;T, N&gt; (§ 13.4.1) и множество битов bitset&lt;N&gt; (§13.4.2). </p>
            <p>Стандартные контейнеры и их основные операции спроектированы таким образом, чтобы быть похожими с точки зрения записи. Кроме того, смыслы операций эквивалентны для различных контейнеров. Основные операции применяются ко всем типам контейнеров,
                для которых они имеют смысл и могут быть эффективно реализованы. </p>
            <h4>Операции со стандартными контейнерами (список неполный)</h4>
            <table>
                <tr>
                    <th>value type</th>
                    <th>Тип элемента</th>
                </tr>
                <tr>
                    <td>р=с.begin() </td>
                    <td>р указывает на первый элемент с; имеется также функция cbegin(), возвращающая константный итератор</td>
                </tr>
                <tr>
                    <td>p=c.end()</td>
                    <td>р указывает на элемент с, следующий за последним; имеется также функция cend (), возвращающая константный итератор </td>
                </tr>
                <tr>
                    <td>k=c.size()</td>
                    <td>k равно количеству элементов в с</td>
                </tr>
                <tr>
                    <td>c.empty()</td>
                    <td>Является ли контейнер с пустым?</td>
                </tr>
                <tr>
                    <td>k=c.capacity()</td>
                    <td>k равно количеству элементов, которые с в состоянии хранить без нового выделения памяти</td>
                </tr>
                <tr>
                    <td>c.reserve(k)</td>
                    <td>Делает емкость равной k</td>
                </tr>
                <tr>
                    <td>c.resize(k)</td>
                    <td>Делает количество элементов равным k; добавленные элементы имеют значение value_type{}</td>
                </tr>
                <tr>
                    <td>с[k]</td>
                    <td>k-й элемент с; проверки выхода за границы диапазона нет</td>
                </tr>
                <tr>
                    <td>c.at(k)</td>
                    <td>k-й элемент с; при выходе за границы диапазона генерируется исключение out_of_range</td>
                </tr>
                <tr>
                    <td>c.push_back(x)</td>
                    <td>Добавление х в конец с; увеличение размера с на единицу</td>
                </tr>
                <tr>
                    <td>с.emplace_back(а)</td>
                    <td>Добавление value_type{а} в конец с; увеличение размера с на единицу</td>
                </tr>
                <tr>
                    <td>q=c.insert(p,x)</td>
                    <td>Добавление х в с перед р</td>
                </tr>
                <tr>
                    <td>q=c.erase(p)</td>
                    <td>Удаление из с элемента, на который указывает р</td>
                </tr>
                <tr>
                    <td>=</td>
                    <td>Присваивание</td>
                </tr>
                <tr>
                    <td>==, !=</td>
                    <td>Проверка на попарное равенство всех элементов двух контейнеров
                    </td>
                </tr>
                <tr>
                    <td>&lt;, &lt;=, &gt;, &gt;=</td>
                    <td>Лексикографическое упорядочение</td>
                </tr>
            </table>
            <p>Такое нотационное и семантическое единообразие позволяет программистам создавать новые типы контейнеров, которые могут быть использованы точно так же, как и стандартные. Примером этого является вектор с проверкой выхода за границы диапазона
                Vector (§3.5.2, глава 4, "Классы"). Единообразие интерфейсов контейнеров позволяет определять алгоритмы независимо от конкретных типов контейнеров. Однако у каждого контейнера есть свои сильные и слабые стороны. Например, индексация и
                обход вектора vector выполняются легко и дешево. С другой стороны, элементы vector перемещаются при вставке или удалении элементов. Список list обладает противоположными свойствами. Обратите внимание, что для коротких последовательностей
                небольших элементов вектор обычно более эффективен, чем список (даже для операций insert () и erase ()).Я рекомендую использовать vector стандартной библиотеки как тип по умолчанию для последовательностей элементов: вам нужна серьезная
                причина для иного выбора. </p>
            <p>Рассматривайте односвязный список forward_list как контейнер, оптимизированный для пустой последовательности (§ 11.3). Пустой forward _ list занимает только одно слово, тогда как пустой vector занимает их три. Пустые последовательности и последовательности
                только с одним или двумя элементами на удивление распространены и полезны.</p>
            <p>Операция размещения, такая как emplace_back (),принимает аргументы для конструктора элемента и строит объект непосредственно в выделенном пространстве в контейнере, а не копирует объект в контейнер. Например, для vector&lt;pair&lt;int, string&gt;&gt;
                мы могли бы написать </p>
        </div>
    </div>
</body>