<head>
    <link rel="stylesheet" href="../../css/books_style.css">
</head>

<body>
    <div class="book-title">
        <p><a href="./1_6.html">&lArr;1.6. Константы</a>&nbsp;&nbsp;&nbsp;<a href="../cpp_0002.html">Содержание</a>&nbsp;&nbsp;&nbsp;<a href="./1_7_1.html">1.7.1. Нулевой указатель&rArr;</a></p>
        <h2>1.7. Указатели, массивы и ссыпки</h2>
        <hr>
        <div>
            <p>Наиболее фундаментальной коллекцией данных является смежно расположенная последовательность элементов одного и того же типа, именуемая массивом. Фундаментально это именно то, что может предоставить аппаратное обеспечение. Массив элементов
                типа char может быть объявлен следующим образом: </p>
            <p>char v[б]; //Массив из 6 символов</p>
            <p>Аналогично указатель может быть объявлен следующим образом:</p>
            <p>char*p; // Указатель на символ</p>
            <p>В объявлениях [ ] означает "массив из", а * - "указатель на". Все массивы в качестве нижней границы имеют О, поэтому упомянутый выше массив v имеет шесть элементов - от v [О] до v [ 5] . Размер массива должен быть константным выражением (§
                1.6). Переменная указателя может хранить адрес объекта соответствующего типа: </p>
            <img src="./1_7_p001.png" alt="">
            <p>В выражении унарный префикс * означает "содержимое", а & - "адрес". Результат показанного выше инициализированного определения графически может быть представлен следующим образом.</p>
            <img src="./1_7_p002.png" alt="">
            <p>Рассмотрим копирование десяти элементов из одного массива в другой:</p>
            <img src="./1_7_p003.png" alt="">
            <p>Эта инструкция for может быть прочтена как "установить i равным нулю; пока i не равно 10, копировать i-й элемент и увеличить i". При применении к целочисленной переменной или к переменной с плавающей точкой оператор инкремента++ просто добавляет
                1. С++ предлагает также более простую инструкцию for, которая называется циклом for для диапазона, для простейшего обхода последовательности: </p>
            <img src="./1_7_p004.png" alt="">
            <p>Первый цикл для диапазона можно прочитать как "для каждого элемента v от первого до последнего поместить его копию в х и распечатать ее". Обратите внимание, что не нужно указывать границы массива, когда мы инициализируем его списком. Цикл
                for для диапазона может использоваться для любой последовательности элементов (§ 12.1 ). </p>
            <p>Если мы не хотим копировать значения из v в переменную х и хотим, чтобы вместо этого х была ссылкой, ссылающейся на элемент, можем написать: </p>
            <img src="./1_7_p005.png" alt="">
            <p>Здесь в объявлении унарный суффикс & означает "ссылка на". Ссылка похожа на указатель, за исключением того, что вам не нужно использовать префикс * для доступа к значению, на которое указывает ссылка. Кроме того, после инициализации ссылка
                не может быть перенацелена (не может ссылаться на другой объект).</p>
            <p>Ссылки особенно полезны для указания аргументов функции. Например:</p>
            <img src="./1_7_p006.png" alt="">
            <p>Используя ссылку, мы гарантируем, что при вызове sort (my_vec) мы не копируем my _ vec и что будет отсортирован именно my_vec, а не его копия.</p>
            <p>Если мы не хотим изменять аргумент, но при этом хотим избежать затрат на копирование, мы используем константную ссылку (§ 1.6). Например:</p>
            <img src="./1_7_p007.png" alt="">
            <p>Функции, принимающие константные ссылки, весьма распространены.</p>
            <p>При использовании в объявлениях операторы (такие, как &, * или []) называются операторами деклараторов:</p>
            <img src="./1_7_p008.png" alt="">
        </div>
    </div>
</body>