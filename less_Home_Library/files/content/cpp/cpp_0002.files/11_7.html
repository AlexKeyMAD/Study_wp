<head>
    <link rel="stylesheet" href="../../css/books_style.css">
</head>

<body>
    <div class="book-title">
        <p><a href="./11_6.html">&lArr;11.6 Обзор контейнеров</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="./12_1.html">ГЛАВА 12. АЛГОРИТМЫ. 12.1. Введение&rArr;</a></p>
        <h2>11.7. Советы</h2>
        <hr>
        <div>
            <p>Приведенные здесь советы в основном представляют собой подмножество советов из С++ Core Guidelines [61]. Ссылки на них выглядят как [CG:ES.23], что означает 23-е правило из раздела Expressions and Statement. Обычно советы по ссылке более подробны,
                с обоснованием и примерами.</p>
            <ol>
                <li>Контейнер STL определяет последовательность; § 11.2. </li>
                <li>Контейнеры STL представляют собой дескрипторы ресурсов; § 11.2, §11.3, §11.4, §11.5. </li>
                <li>Используйте vector в качестве контейнера по умолчанию; § 11.2, § 11.6; [CG:SL.con.2].</li>
                <li>Для простого обхода контейнера используйте цикл по диапазону или пару итераторов begin () /end (); § 11.2, § 11.3. </li>
                <li>Используйте функцию reserve (), чтобы избежать недействительности указателей на элементы и итераторов; § 11.2.</li>
                <li>Не следует рассчитывать на повышение производительности из-за применения reserve () без проведения измерений; § 11.2. </li>
                <li>Используйте push_back () или resize () для контейнера вместо realloc () для массива; § 11.2. </li>
                <li>Не используйте итераторы, указывавшие в vector, после изменения его размера; § 11.2. </li>
                <li>Не рассчитывайте на проверку выхода за границы диапазона в операторе [ ] ; § 11.2. </li>
                <li>Используйте at (),если вам нужна гарантированная проверка выхода за границы диапазона; § 11.2; [CG:SL.con.3]. </li>
                <li>Используйте цикл for для диапазона и алгоритмы стандартной библиотеки, чтобы без затрат избежать проверки выхода за границы диапазона; § 11.2.2. </li>
                <li>Элементы копируются в контейнер; § 11.2.1. </li>
                <li>Для сохранения полиморфного поведения элементов храните указатели; § 11.2.1. </li>
                <li>Операции вставки, такие как insert () и push_back(), в vector зачастую оказываются на удивление эффективными; §11.3. </li>
                <li>Используйте forward _ list для последовательностей, которые обычно пусты; § 11.6. </li>
                <li>Когда дело касается производительности - выполняйте измерения, не доверяя интуиции; § 11.2.</li>
                <li>map обычно реализуется как красно-черное дерево; § 11.4. </li>
                <li>unordered_mар представляет собой хеш-таблицу; § 11.5. </li>
                <li>Передавайте контейнеры в функции по ссылке, а возвращайте по значению; §11.2. </li>
                <li>В случае контейнеров используйте синтаксис инициализации с ( ) для размеров и с { } - для списков элементов; §4.2.3, § 11.2. </li>
                <li>Предпочитайте компактные структуры данных с последовательным размещением элементов; § 11.3.</li>
                <li>Обход списка - относительно дорогостоящая процедура; § 11.3. </li>
                <li>Используйте неупорядоченные контейнеры, если требуется быстрый поиск среди большого количества данных; § 11.5.</li>
                <li>Используйте упорядоченные ассоциативные контейнеры (такие, как map или set), если требуется упорядоченный обход их элементов; § 11.4. </li>
                <li>Используйте неупорядоченные контейнеры для элементов, типы которых не имеют естественного порядка (например, не имеют разумного оператора &lt;); § 11.4. </li>
                <li>Для получения приемлемой хеш-функции следует немного поэкспериментировать; § 11.5. </li>
                <li>Зачастую хорошие хеш-функции получаются при комбинировании стандартных хеш-функций элементов с использованием оператора исключающего или (л); §11.5. </li>
                <li>Следует знать контейнеры стандартной библиотеки и предпочитать их самостоятельно создаваемым вручную структурам данных; § 11.6. </li>
            </ol>
        </div>
    </div>
</body>