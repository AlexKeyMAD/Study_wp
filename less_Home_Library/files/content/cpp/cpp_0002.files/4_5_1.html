<head>
    <link rel="stylesheet" href="../../css/books_style.css">
</head>

<body>
    <div class="book-title">
        <p><a href="./4_5.html">&lArr;4.5 Иерархии классов</a>&nbsp;&nbsp;&nbsp;<a href="../cpp_0002.html">Содержание</a>&nbsp;&nbsp;&nbsp;<a href="./4_5_2.html">4.5.2 Навигация по иерархии&rArr;</a></p>
        <h2>4.5.1. Преимущества иерархий</h2>
        <hr>
        <div>
            <p>Иерархия классов предоставляет две разновидности преимуществ.</p>
            <ul>
                <li>Наследование интерфейса. Объект производного класса можно использовать везде, где требуется объект базового класса. То есть базовый класс действует в качестве интерфейса для производного класса. Примерами являются классы Container и Shape.
                    Такие классы часто являются абстрактными.</li>
                <li>Наследование реализации. Базовый класс предоставляет функции или данные, что упрощает реализацию производных классов. Примерами являются использование классом Smiley конструктора Circle и функции-члена Circle::draw().Такие базовые классы
                    часто имеют члены данных и конструкторы.</li>
            </ul>
            <p>Конкретные классы - особенно с небольшими представлениями - очень похожи на встроенные типы: мы определяем их как локальные переменные, обращаемся к ним с помощью имен, копируем их и т.д. Классы в иерархии классов различаются - обычно для
                них выделяется память с использованием оператора new, и доступ к ним выполняется через указатели или ссылки. Например, рассмотрим функцию, которая считывает данные, описывающие фигуры, из входного потока и создает соответствующие объекты
                Shape:
            </p>
            <img src="./4_5_1_p001.png" alt="">
            <p>Программа может использовать функцию чтения фигуры следующим образом:</p>
            <img src="./4_5_1_p002.png" alt="">
            <p>Очевидно, что пример упрощен (особенно в отношении обработки ошибок), но он наглядно иллюстрирует, что user() не имеет абсолютно никакого представления о том, с какими видами фигур он работает. Код user() может быть скомпилирован один раз
                и позже использоваться для новых видов фигур, добавленных в программу. Обратите внимание, что нет никаких указателей на фигуры вне user (), поэтому за освобождение объектов отвечает сама функция. Это делается с помощью оператора delete,
                полагаясь при этом на виртуальный деструктор Shape. Поскольку деструктор является виртуальным, delete вызывает деструктор для наиболее позднего производного класса. Это имеет решающее значение, поскольку производный класс может захватывать
                всевозможные ресурсы (такие, как дескрипторы файлов, блокировки и выходные потоки), которые должны быть освобождены. В нашем случае Srniley удаляет свои объекты eyes и rnouth. Как только это сделано, вызывается деструктор Circle. Объекты
                строятся конструкторами "снизу вверх" (сначала - базовый), а уничтожаются деструкторами "сверху вниз" (сначала - производные).</p>
        </div>
    </div>
</body>