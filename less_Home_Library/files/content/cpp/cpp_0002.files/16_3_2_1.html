<head>
    <link rel="stylesheet" href="../../css/books_style.css">
</head>

<body>
    <div class="book-title">
        <p><a href="./16_3_2.html">&lArr;16.3.2 Проблемы совместимости</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="./16_3_2_2.html">16.3.2.2 void*&rArr;</a></p>
        <h2>16.3.2.1. Проблемы сrиля</h2>
        <hr>
        <div>
            <p>Естественно, программа на С пишется в стиле С, таком, например, как стиль, используемый в K&R [30]. Это подразумевает широкое использование указателей и массивов и, возможно, множества макросов. Эти средства трудно надежно использовать в большой
                программе. Управление ресурсами и обработка ошибок часто оказываются приспосабливаемыми к конкретным условиям, основанными на документировании (а не на поддержке языком и инструментами), и часто не полностью документированы и плохо соблюдаются.
                Простое построчное преобразование программы на С в программу на С++ даст программу, которая часто оказывается лучше проверенной. Но на самом деле я никогда не преобразовывал программу на С в программу на С++, не обнаружив какой-нибудь
                ошибки. Тем не менее фундаментальная структура такой программы остается неизменной, как и основные источники ошибок. Если у вас была неполная обработка ошибок, утечки ресурсов или переполнения буфера в исходной программе на С, они все
                равно будут присутствовать в версии на С++. Чтобы получить преимущества от применения С++, вы должны внести изменения в саму структуру кода. </p>
            <ol>
                <li>Не рассматривайте С++ просто как С с некоторыми добавленными возможностями. С++ может быть использован таким образом, но это его использование будет неоптимальным. Чтобы получить реальные преимущества от применения С++ по сравнению с С,
                    необходимы иные дизайн и стили реализации.</li>
                <li>Используйте стандартную библиотеку С++ как преподаватель новых методов и стилей программирования. Обращайте внимание на отличие от стандартной библиотеки С (например, применение = вместо strcpy () для копирования и == вместо strcmp ()
                    для сравнения строк).</li>
                <li>Подстановка макросов в С++ почти никогда не требуется. Используйте cons t (§ 1.6), constexpr (§ 1.6), enum или enum class (§2.5) для определения констант, inline (§4.2.1 ), чтобы избежать накладных расходов на вызовы функций, шаблоны (глава
                    6, "Шаблоны") для определения семейств функций и типов, а также пространства имен (§3.4), чтобы избежать коллизий имен.</li>
                <li>Не объявляйте переменную до того, как она понадобится, и немедленно ее инициализируйте. Объявление может находиться везде, где может быть инструкция (§1.8), в инициализаторах циклов for (§1.7) и в условиях (§4.5.2).</li>
                <li>Не используйте malloc (). Оператор new (§4.2.2) выполняет те же действия лучше, а вместо realloc () попробуйте применить vector (§4.2.3, §12.1). Но не делайте простую бездумную замену malloc () и free () "голыми" операторами new и delete
                    (§4.2.2). </li>
                <li>Избегайте void*, объединений и приведений, кроме как глубоко в реализации некоторой функции или класса. Их использование ограничивает поддержку, которую вы можете получить от системы типов, и может нанести ущерб производительности. В большинстве
                    случаев приведение является признаком ошибки проектирования.</li>
                <li>Если вы должны использовать явное преобразование типов, прибегните к соответствующему именованному приведению (например, static_cast; §16.2.7) для более точного определения того, что вы пытаетесь сделать. </li>
                <li>Минимизируйте использование массивов и строк в стиле С. Строки string стандартной библиотеки С++ (§9.2), массивы array (§13.4.1) и векторы vector (§ 11.2) часто могут использоваться для написания более простого и более удобного в обслуживании
                    кода по сравнению с традиционным стилем С. В общем случае старайтесь не создавать то, что уже предоставлено стандартной библиотекой.</li>
                <li>Избегайте арифметики указателей, за исключением очень специализированного кода (такого, как диспетчер памяти) и простого обхода массива (например, ++р). </li>
                <li>Не думайте, что что-то, кропотливо написанное в стиле С (без учета таких особенностей С++, как классы, шаблоны и исключения), будет более эффективным, чем более короткая альтернатива (например, с использованием стандартных библиотечных
                    средств). Часто (но, конечно, не всегда), верно обратное.</li>
            </ol>
        </div>
    </div>
</body>