<head>
    <link rel="stylesheet" href="../../css/books_style.css">
</head>

<body>
    <div class="book-title">
        <p><a href="./9_4_1.html">&lArr;9.4.1 Поиск</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="./9_4_3.html">9.4.3 Итераторы&rArr;</a></p>
        <h2>9.4.2. Запись регулярных выражений</h2>
        <hr>
        <div>
            <p>Библиотека регулярных выражений regex может распознавать несколько вариантов обозначений для регулярных выражений. Здесь я использую стандартную запись, вариант стандарта ЕСМА, используемый в ECMAScript (более известен как JavaScript). </p>
            <p>Синтаксис регулярных выражений основан на символах со специальным значением.
            </p>
            <img src="./9_4_2_p001.png" alt="">
            <p>Например, мы можем указать строку, начинающуюся с нуля или более символов А, за которыми следует одна или несколько букв В, а затем - необязательный символ С:</p>
            <img src="./9_4_2_p002.png" alt="">
            <p>Вот примеры строк, соответствующих этому регулярному выражению: </p>
            <img src="./9_4_2_p003.png" alt="">
            <p>А вот примеры строк, не соответствующих этому регулярному выражению:</p>
            <img src="./9_4_2_p004.png" alt="">
            <p>Часть шаблона рассматривается как подшаблон (который может быть извлечен отдельно из srnatch), если он находится в круглых скобках. Например: </p>
            <img src="./9_4_2_p005.png" alt="">
            <p>Шаблон может быть сделан необязательным или повторяющимся (по умолчанию он повторяется ровно один раз) с помощью суффикса.</p>
            <img src="./9_4_2_p006.png" alt="">
            <p>Например:</p>
            <img src="./9_4_2_p007.png" alt="">
            <p>Вот примеры строк, соответствующих этому регулярному выражению:</p>
            <img src="./9_4_2_p008.png" alt="">
            <p>А вот примеры строк, не соответствующих этому регулярному выражению:</p>
            <img src="./9_4_2_p009.png" alt="">
            <p>Суффикс ? после любого указателя повторений (?, *, + и { } ) делает шаблон "ленивым" или "нежадным", т.е. в процессе поиска шаблона он будет искать кратчайшее соответствие, а не длиннейшее. По умолчанию всегда выполняется поиск наидлиннейшего
                соответствия; этот принцип известен как правwю наибольшего соответствия (Мах Munch rule). Рассмотрим строку </p>
            <img src="./9_4_2_p010.png" alt="">
            <p>Шаблон ( аЬ) + находит всю строку аЬаЬаЬ, но шаблон ( аЬ) +? находит только первое аЬ.</p>
            <p>Наиболее распространенные классификации символов имеют имена.</p>
            <img src="./9_4_2_p011.png" alt="">
            <p>В регулярных выражениях имя класса символов должно находиться в специальных скобках- [::] . Например, [:digit:] соответствует десятичной цифре. Кроме того, они должны использоваться в паре скобок [ ] , определяющей класс символов.</p>
            <p>Для некоторых классов символов поддерживается сокращенная запись. </p>
            <img src="./9_4_2_p012.png" alt="">
            <p>Кроме того, языки с поддержкой регулярных выражений часто предоставляют следующее.</p>
            <img src="./9_4_2_p013.png" alt="">
            <p>Для обеспечения переносимости используйте имена классов символов, а не эти аббревиатуры. </p>
            <p>В качестве примера рассмотрим написание шаблона, который описывает идентификаторы С++: символ подчеркивания или буква, за которой следует, возможно, пустая последовательность букв, цифр или символов подчеркивания. Чтобы проиллюстрировать ряд
                тонкостей, я включаю в пример несколько ложных попыток: </p>
            <img src="./9_4_2_p014.png" alt="">
            <p>Наконец, вот функция, которая использует простейшую версию regex_match () (§9.4.1) для проверки, является ли строка идентификатором: </p>
            <img src="./9_4_2_p015.png" alt="">
            <p>Обратите внимание на удвоение обратной косой черты при включении обратной косой черты в обычный строковый литерал. Используйте необработанные строковые литералы, чтобы облегчить работу со специальными символами. Например:</p>
            <img src="./9_4_2_p016.png" alt="">
            <p>Вот несколько примеров шаблонов:</p>
            <img src="./9_4_2_p017.png" alt="">
            <p>Группа (подшаблон), потенциально представимая с помощью sub match, отделяется круглыми скобками. Если вам нужны круглые скобки, не определяющие подшаблон, используйте (? : вместо простого (. Например: </p>
            <img src="./9_4_2_p018.png" alt="">
            <p>В предположении, что нас не интересуют символы до числа (предположительно разделители), можно написать.</p>
            <img src="./9_4_2_p019.png" alt="">
            <p>Это предохранит механизм регулярных выражений от необходимости сохранять первые символы: вариант (?: содержит один только подшаблон.</p>
            <img src="./9_4_2_p020.png" alt="">
            <p>Последний шаблон в таблице полезен для синтаксического анализа XML. Он находит маркеры начала/конца дескриптора. Обратите внимание, что я использовал нежадное (ленивое) соответствие, . *?,для подшаблона между начальным и конечным дескрипторами.
                Если бы я использовал просто . *, это вызвало бы проблемы:</p>
            <img src="./9_4_2_p021.png" alt="">
            <p>Жадное соответствие первого подшаблона привело бы к тому, что первая открывающая угловая скобка &lt; была бы сопоставлена с последней закрывающей &gt;. Это было бы корректным поведением, но вряд ли тем, которое хотел программист.
            </p>
            <p>Более подробное изложение регулярных выражений приведено в [22].</p>
        </div>
    </div>
</body>