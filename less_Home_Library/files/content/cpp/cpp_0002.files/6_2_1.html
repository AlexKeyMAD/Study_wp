<head>
    <link rel="stylesheet" href="../../css/books_style.css">
</head>

<body>
    <div class="book-title">
        <p><a href="./6_2.html">&lArr;6.2 Параметризованные типы</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="./6_2_2.html">6.2.2 Аргументы-значения шаблонов&rArr;</a></p>
        <h2>6.2.1. Ограниченные аргументы wабnона (С++20)</h2>
        <hr>
        <div>
            <p>Чаще всего шаблон имеет смысл только для аргументов шаблона, которые отвечают определенным критериям. Например, Vector обычно предлагает операцию копирования и, если это так, должен требовать, чтобы его элементы были копируемы. То есть мы
                должны требовать, чтобы аргумент шаблона Vector был не просто typenarne, а Elernent, где "Elernent" определяет требования к типу, которому могут принадлежать элементы: </p>
            <img src="./6_2_1_p001.png" alt="">
            <p>Этот префикс ternplate&lt;Elernent Т&gt; представляет собой С++-версию математического выражения "для всех Т, таких, что Elernent (Т)"; т.е. Elernent является предикатом, который проверяет, обладает ли Т всеми свойствами, которые требует Vector.
                Такой предикат называется концептом (concept) (§7.2). Шаблонный аргумент, для которого указан концепт, называется ограниченным аргументом, а шаблон, для которого аргумент ограничен, - ограниченным шаблоном.</p>
            <p>Попытка инстанцирования шаблона с типом, не соответствующим его требованиям, является ошибкой времени компиляции. Например</p>
            <img src="./6_2_1_p002.png" alt="">
            <p>Поскольку официально до стандарта С++20 язык программирования С++ концепты не поддерживает, более старый код использует неограниченные аргументы шаблона и указывает необходимые требования в документации. </p>
        </div>
    </div>
</body>