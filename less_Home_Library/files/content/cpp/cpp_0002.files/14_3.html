<head>
    <link rel="stylesheet" href="../../css/books_style.css">
</head>

<body>
    <div class="book-title">
        <p><a href="./14_2.html">&lArr;14.2 Математические функции</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="./14_3_1.html">14.3.1 Параллельные алгоритмы&rArr;</a></p>
        <h2>14.3. Числовые аnrоритмы</h2>
        <hr>
        <div>
            <p>В заголовочном файле &lt;numeric&gt; находится небольшое множество обобщенных числовых алгоритмов, таких как accumulate(). </p>
            <table border="1">
                <tr>
                    <th>Числовые алгоритмы</th>
                    <th></th>
                </tr>
                <tr>
                    <td>x=accumulate(b,e,i)</td>
                    <td>х - сумма i и элементов последовательности [Ь:е]</td>
                </tr>
                <tr>
                    <td>x=accumulate(b,e,i,f) </td>
                    <td>accumulate с использованием f вместо+</td>
                </tr>
                <tr>
                    <td>x=inner_product(b,e, b2,i)
                    </td>
                    <td>х - скалярное произведение [Ь:е] и [Ь2:Ь2 + (е-Ь)], т.е. сумма i и ( *pl) * ( *р2) для каждого pl из [Ь:е] и соответствующего р2 из [Ь2:Ь2+ (е-Ь)]</td>
                </tr>
                <tr>
                    <td>x=inner_product(b,e, Ь2, i, f, f2)</td>
                    <td>inner_product с использованием f и f2 вместо+ и *</td>
                </tr>
                <tr>
                    <td>p=partial_sum(b,e,out)</td>
                    <td>i-й элемент в [out:p] является суммой элементов [b:b+i] </td>
                </tr>
                <tr>
                    <td>p=partial_sum(b,e,out,f)</td>
                    <td>partial_sum с использованием f вместо+</td>
                </tr>
                <tr>
                    <td>p=adjacent_difference (b,e,out)
                    </td>
                    <td>i-й элемент в [out:p] равен * (Ь+ i) - * (Ь+ i-1) для i&gt;O; если е-Ь&gt;О, то *out равно *Ь</td>
                </tr>
                <tr>
                    <td>p=adjacent_difference (b,e,out,f)
                    </td>
                    <td>adjacent_difference с использованием f вместо -</td>
                </tr>
                <tr>
                    <td>iota(b,e,v)</td>
                    <td>Каждому элементу в [Ь:е) присваивается значение ++v; таким образом, последовательность становится равной v+l, v+2, ... </td>
                </tr>
                <tr>
                    <td>x=gcd(n,m) </td>
                    <td>х - наибольший общий делитель целых чисел n и m</td>
                </tr>
                <tr>
                    <td>x=lcm(n,m)</td>
                    <td>х - наименьшее общее кратное целых чисел n и m</td>
                </tr>
            </table>
            <p>Эти алгоритмы обобщают распространенные операции, такие как вычисление суммы, позволяя применять их ко всем видам последовательностей. Они также делают операцию, применяемую к элементам этих последовательностей, параметром. Для каждого алгоритма
                общая версия дополняется версией, применяющей наиболее распространенный оператор для этого алгоритма. Например: </p>
            <img src="./14_3_p001.png" alt="">
            <p>Описанные алгоритмы работают для любой последовательности стандартной библиотеки и могут иметь операции, предоставляемые в качестве аргументов(§ 14.3).</p>
        </div>
    </div>
</body>