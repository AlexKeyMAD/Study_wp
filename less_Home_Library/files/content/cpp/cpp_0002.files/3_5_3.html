<head>
    <link rel="stylesheet" href="../../css/books_style.css">
</head>

<body>
    <div class="book-title">
        <p><a href="./3_5_2.html">&lArr;3.5.2 Инварианты</a>&nbsp;&nbsp;&nbsp;<a href="../cpp_0002.html">Содержание</a>&nbsp;&nbsp;&nbsp;<a href="./3_5_4.html">3.5.4 Контракты&rArr;</a></p>
        <h2>3.5.3. Альтернативные варианты обработки оwибок</h2>
        <hr>
        <div>
            <p>Обработка ошибок - важная проблема в реальном программировании, поэтому имеется множество различных подходов к ее решению. Если обнаружена ошибка, которая не может быть обработана локально в функции, то функция должна каким-то образом передать
                информацию о проблеме некоторой вызывающей функции. Генерация исключения - наиболее общий механизм С++ для этого.</p>
            <p>Существуют языки, в которых исключения предназначены просто для предоставления альтернативного механизма возврата значений. С++ таким языком не является: исключения предназначены для сообщения о невозможности выполнить задание. Исключения
                интегрированы с конструкторами и деструкторами для обеспечения согласованной схемы обработки ошибок и управления ресурсами (§4.2.2, §5.3). Компиляторы оптимизированы таким образом, чтобы вернуть значение было намного дешевле, чем сгенерировать
                то же значение в виде исключения.</p>
            <p>Генерация исключения - не единственный способ сообщить об ошибке, которая не может быть обработана локально. Функция может указать, что она не в состоянии выполнить поставленную перед ней задачу, разными путями:</p>
            <ul>
                <li>генерируя исключение;</li>
                <li>возвращая некоторое значение, указывающее на ошибку;</li>
                <li>завершая работу программы (вызывая функцию наподобие exit(), terminate() или abort()).</li>
            </ul>
            <p>Индикатор ошибки ("код ошибки") возвращается в следующих случаях. </p>
            <ul>
                <li>Когда ошибка - нормальное, ожидаемое явление. Например, вполне нормальной является ошибка открытия файла (возможно, такого файла нет или он не может быть открыт из-за проблем с правами доступа).</li>
                <li>Ожидается, что непосредственная вызывающая функция в состоянии обработать такую ошибку.</li>
            </ul>
            <p>Исключения генерируются в следующих ситуациях.</p>
            <ul>
                <li>Ошибка настолько редкая, что программист, скорее всего, забудет выполнить ее проверку. Например, когда вы в последний раз проверяли значение, возвращаемое функцией printf()?</li>
                <li>Ошибка не может быть обработана непосредственной вызывающей функцией. Вместо этого ошибка должна быть передана конечной вызывающей функции. Например, невозможно, чтобы каждая функция приложения надежно обрабатывала все ошибки выделения
                    памяти или обрыва соединения сети.</li>
                <li>В модулях более низкого уровня в приложении могут быть добавлены новые типы ошибок, при том что модули более высокого уровня не были написаны с учетом необходимости обработки таких ошибок (например, если бывшее однопоточным приложение
                    было изменено для работы с несколькими потоками или с удаленными ресурсами с доступом по сети).</li>
                <li>Отсутствует подходящий путь возврата для кодов ошибок. Например, конструктор не имеет возвращаемого значения, которое могла бы проверить вызывающая функция 1 • Кроме того, конструкторы могут быть вызваны для нескольких локальных переменных
                    или в частично сконструированном сложном объекте, так что очистка на основе кодов ошибок окажется довольно сложной.</li>
                <li>Путь возврата значения из функции оказывается более сложным или дорогостоящим из-за необходимости возвращать как значение, так и индикатор ошибки (например, в виде pair; § 13.4.3), что может привести к использованию лишних параметров и
                    нелокальных указателей ошибки или к другим обходным путям. </li>
                <li>Ошибка должна быть передана цепочке вызовов "конечной вызывающей функции". Многократная проверка кода ошибки утомительна, дорогостояща и чревата ошибками.</li>
                <li>Восстановление после ошибки зависит от результатов нескольких вызовов функций, что ведет к необходимости поддерживать локальное состояние между вызовами и к усложненным управляющим структурам.</li>
                <li>Функция, обнаружившая ошибку, является функцией обратного вызова (функциональный аргумент), так что непосредственная вызывающая функция может даже не знать, что функция была вызвана. </li>
                <li>Ошибка требует выполнения некоторой "отмены действий".</li>
            </ul>
            <p>Программа завершается в следующих случаях.</p>
            <ul>
                <li>Восстановление после ошибки данного вида невозможно. Например, во многих - но не во всех - системах нет разумного способа восстановления после исчерпания доступной памяти.</li>
                <li>В данной системе обработка нетривиальных ошибок требует перезапуска потока, процесса или компьютера.</li>
            </ul>
            <p>Одним из способов гарантировать завершение работы приложения является добавление noexcept к функции, с тем чтобы генерация исключения с помощью throw в любом месте реализации функции приводила к вызову terminate(). Обратите внимание, что существуют
                приложения, для которых безусловное завершение работы неприемлемо, поэтому необходимо использовать альтернативные варианты.</p>
            <p>К сожалению, перечисленные ситуации не всегда оказываются логически непересекающимися и простыми в применении. Имеют значение такие факторы, как размер и сложность программы. Иногда по мере развития приложения происходит изменение приоритетов
                и компромиссов. Для принятия верного решения требуется опыт. Если у вас есть сомнения, предпочитайте исключения, потому что их использование лучше масштабируется и не требует внешних инструментов для проверки того, что все ошибки обработаны.</p>
            <p>Не верьте, что все коды ошибок или все исключения плохи; для каждого из механизмов есть своя достаточно точно определенная ниша. Кроме того, не верьте мифу о том, что обработка исключений плохо влияет на производительность; зачастую она быстрее,
                чем корректная обработка сложных или редких условий ошибки, а также повторных проверок кодов ошибок.</p>
            <p>Идиома RAII (§4.2.2, §5.3) имеет жизненное значение для простой и эффективной обработки ошибок с использованием исключений. Код, переполненный trу-блоками, зачастую просто является отражением худших аспектов стратегий обработки ошибок на основе
                кодов ошибок.</p>
        </div>
    </div>
</body>