<head>
    <link rel="stylesheet" href="../../css/books_style.css">
</head>

<body>
    <div class="book-title">
        <p><a href="./x_x.html">&lArr;1.9.1. Присваивание</a>&nbsp;&nbsp;&nbsp;<a href="../cpp_0002.html">Содержание</a>&nbsp;&nbsp;&nbsp;<a href="./x_x.html">1.10. Советы&rArr;</a></p>
        <h2>1.9.2. Инициализация</h2>
        <hr>
        <div>
            <p>Инициализация отличается от присваивания. В общем случае, чтобы присваивание работало правильно, целевой объект присваивания должен иметь значение. С другой стороны, задачей инициализации является превращение неинициализированного фрагмента
                памяти в корректный объект. Для почти всех типов результат чтения или записи неинициализированной переменной не определен. Для встроенных типов это наиболее очевидно для ссылок:</p>
            <img src="./1_9_2_p001.png" alt="">
            <p>К счастью, невозможно получить неинициализированную ссылку- в противном случае присваивание r2=99 сохраняло бы 99 в некотором неопределенном месте в памяти; в конечном итоге это могло бы привести к неверным результатам или краху программы.</p>
            <p>Можно использовать для инициализации ссылки оператор =, но не дайте ему вас запутать! Например:</p>
            <img src="./1_9_2_p002.png" alt="">
            <p>Это все еще инициализация, привязывающая r к х, а не копирование значения.</p>
            <p>Различие между инициализацией и присваиванием имеет решающее значение и для многих пользовательских типов, таких как string и vector, где целевой объект присваивания владеет ресурсом, который в конечном итоге должен быть освобожден (§5.3).</p>
            <p>Базовая семантика передачи аргументов и возврата значения из функции представляет собой инициализацию (§3.6). Например, именно так мы получаем возможность передачи аргументов по ссылке.</p>
        </div>
    </div>
</body>