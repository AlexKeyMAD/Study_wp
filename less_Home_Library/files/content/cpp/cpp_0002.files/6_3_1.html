<head>
    <link rel="stylesheet" href="../../css/books_style.css">
</head>

<body>
    <div class="book-title">
        <p><a href="./6_3.html">&lArr;6.3 Параметризованные операции</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="./6_3_2.html">6.3.2 Функциональные объекты&rArr;</a></p>
        <h2>6.3.1. Шабnоны функций</h2>
        <hr>
        <div>
            <p>Мы можем написать функцию, которая вычисляет сумму значений элементов любой последовательности, которую может обойти цикл for для диапазона (например, контейнера) следующим образом: </p>
            <img src="./6_3_1_p001.png" alt="">
            <p>Аргумент шаблона Val ue и аргумент функции v предназначены для того, чтобы вызывающая функция могла указать тип и начальное значение аккумулятора (переменной, в которой нужно накапливать сумму): </p>
            <img src="./6_3_1_p002.png" alt="">
            <p>Цель суммирования значений типа int с аккумулятором типа douЫe может состоять в том, чтобы успешно справиться с числом, большим, чем наибольшее допустимое значение int. Обратите внимание, как из аргументов функции выводятся аргументы типов
                шаблона для sum&lt;Sequence, Value&gt;. К счастью, нам не нужно явно указывать эти типы.</p>
            <p>Эта функция sum () представляет собой упрощенную версию алгоритма accumula te () стандартной библиотеки(§ 14.3).</p>
            <p>Шаблон функции может быть функцией-членом, но не виртуальной функцией - компилятор не в состоянии знать все инстанцирования такого шаблона в программе, а потому не в состоянии корректно генерировать vtЫ в данной ситуации (§4.4). </p>
        </div>
    </div>
</body>