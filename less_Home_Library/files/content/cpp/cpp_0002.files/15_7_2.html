<head>
    <link rel="stylesheet" href="../../css/books_style.css">
</head>

<body>
    <div class="book-title">
        <p><a href="./15_7_1.html">&lArr;15.7.1 future и promise</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="./15_7_3.html">15.7.3 async()&rArr;</a></p>
        <h2>15.7.2. packaged_task</h2>
        <hr>
        <div>
            <p>Как мы можем получить future в задании, которому нужен результат, и соответствующий promise в потоке, который должен этот результат вычислить? Тип packaged_task предназначен для упрощения настройки заданий, связанных с работой с future и promise
                в потоках. packaged_task предоставляет код-обертку для размещения возвращаемого значения или исключения из задачи в promise (подобно коду из §15.7.1). Если вы попросите об этом, вызвав get_future, packaged_task выдаст вам future, соответствующее
                его promise. Например, мы можем настроить два задания так, чтобы каждое суммировало половину элементов vector&lt;double&gt;, используя алгоритм стандартной библиотеки accumula te () (§ 14.3):</p>
            <img src="./15_7_2_p001.png" alt="">
            <p>Шаблон packaged _ task принимает в качестве аргумента шаблона тип задания (здесь - Task_type, псевдоним для douЫe (double*,double*, douЫe)) и задание в качестве аргумента конструктора (в данном случае - accurn). Операция move () необходима
                потому, что packaged task не может быть скопирован. Причина, по которой packaged_task не может быть скопирован, заключается в том, что он является дескриптором ресурса: он владеет своим promise и (косвенно) ответственен за любые ресурсы,
                которыми может владеть его задание.</p>
            <p>Обратите внимание на отсутствие явного упоминания блокировок в этом коде: мы можем сосредоточиться на заданиях, которые необходимо выполнить, а не на механизмах, используемых для управления связью между ними. Эти две задачи будут выполняться
                в отдельных потоках, а следовательно, потенциально параллельно.</p>
        </div>
    </div>
</body>