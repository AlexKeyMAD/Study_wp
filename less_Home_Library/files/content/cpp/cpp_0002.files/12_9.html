<head>
    <link rel="stylesheet" href="../../css/books_style.css">
</head>

<body>
    <div class="book-title">
        <p><a href="./12_8.html">&lArr;12.8 Алгоритмы над контейнерами</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="./12_10.html">12.10 Советы&rArr;</a></p>
        <h2>12.9. Параллельные алгоритмы</h2>
        <hr>
        <div>
            <p>Если одна и та же задача должна быть выполнена для многих элементов данных, можно выполнять ее параллельно для каждого элемента данных при условии, что вычисления для различных элементов данных независимы:</p>
            <ul>
                <li>параллельное выполнение: задания выполняются несколькими потоками выполнения (зачастую работающими на разных ядрах процессора);</li>
                <li>векторизованное выполнение: задания выполняются на одном потоке с использованием векторизации, известной как SIMD ("Single Instruction, Multiple Data" - одна команда, много данных).</li>
            </ul>
            <p>Стандартная библиотека предлагает поддержку для обоих вариантов, и мы можем точно указать требование последовательного выполнения; в заголовочном файле &lt;execution&gt; имеются следующие индикаторы стратегий:</p>
            <ul>
                <li>seq: последовательное выполнение;</li>
                <li>par: параллельное выполнение (если таковое возможно);</li>
                <li>par_unseq: параллельное и/или непоследовательное (векторизованное) выполнение (если таковое возможно).</li>
            </ul>
            <p>Рассмотрим std::sort():</p>
            <p>Стоит ли распараллеливать и/или векторизовать выполнение, зависит от алгоритма, количества элементов в последовательности, аппаратного обеспечения и использования этого аппаратного обеспечения программами, работающими на нем. Следовательно,
                индикаторы стратегии выполнения являются просто подсказками. Компилятор и/или планировщик времени выполнения решат, какой параллелизм использовать. Это все очень нетривиальные задачи, и очень важно не делать никаких утверждений об эффективности
                применения параллельности без проведения детальных измерений.</p>
            <p>Для большинства алгоритмов стандартной библиотеки, включая все таблицы в §12.6, за исключением equal Range, может быть запрошено распараллеливание и векторизация с использованием par и par_unseq, как в случае sort() . Почему не equal_Range()?
                Потому что до сих пор никто не придумал для него достойного параллельного алгоритма.</p>
            <p>Многие параллельные алгоритмы используются в основном для числовых данных; см. § 14.3.1. </p>
            <p>При запросе параллельного выполнения следует убедиться в отсутствии возможности гонки данных(§ 15.2) и взаимоблокировки(§ 15.5).</p>
        </div>
    </div>
</body>