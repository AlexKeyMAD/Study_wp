<head>
    <link rel="stylesheet" href="../../css/books_style.css">
</head>

<body>
    <div class="book-title">
        <p><a href="./15_5.html">&lArr;15.5 Совместное использование данных</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="./15_7.html">15.7 Обмен информацией с заданиями&rArr;</a></p>
        <h2>15.6. Ожидание событий</h2>
        <hr>
        <div>
            <p>Иногда поток должен ожидать какого-то внешнего события, например завершения задания другим потоком, или пока не пройдет определенное количество времени. Самое простое "событие" - это просто прошедшее время. Используя средства для работы со
                временем, найденные в заголовочном файле &lt;chrono&gt;, можно написать:</p>
            <img src="./15_6_p001.png" alt="">
            <p>Обратите внимание, что мне даже не надо запускать thread; по умолчанию this thread относится к одному и только к одному потоку.</p>
            <p>Я использовал dura tion_cast, чтобы настроить единицы измерения времени в нужные мне наносекунды.</p>
            <p>Базовая поддержка взаимодействия с использованием внешних событий обеспечивается условными переменными condition_variable, описанными в заголовочном файле &lt;condition variable&gt;. Такая переменная представляет собой механизм, позволяющий
                одному потоку ожидать другого. В частности, он позволяет потоку ожидать выполнения некоторого условия (часто называемого событием) в результате работы, выполняемой другими потоками.
            </p>
            <p>condition_variaЫe поддерживает множество форм элегантного и эффективного совместного использования информации, но может быть довольно сложным. Рассмотрим классический пример взаимодействия двух потоков путем передачи сообщений через очередь
                queue. Для простоты я объявляю очередь и механизм предотвращения условий гонки в этой очереди глобальными для производителя и потребителя:</p>
            <img src="./15_6_p002.png" alt="">
            <p>Типы queue, condition_variable и rnutex предоставляются стандартной библиотекой.
            </p>
            <p>Потребитель consurner() читает и обрабатывает сообщения Message: </p>
            <img src="./15_6_p003.png" alt="">
            <p>Здесь я явно защищаю операции с очередью и условной переменной с помощью блокировки unique_lock для мьютекса. Ожидание condition_variable освобождает свой аргумент-блокировку до тех пор, пока ожидание не закончится (пока очередь не перестанет
                быть пустой), а затем повторно захватывает ее. Явная проверка условия (в данном случае - !mqueue. ernpty ())защищает от пробуждения просто для того, чтобы обнаружить, что какое-то другое задание пробудилось раньше, так что условие больше
                не выполняется. </p>
            <p>Я использовал unique lock, а не scoped_lock по двум причинам. </p>
            <ul>
                <li>Нам нужно передать блокировку функции wait() условной переменной condition_variable. Блокировка scoped_lock, в отличие от unique_lock, не может копироваться.</li>
                <li>Мы хотим разблокировать rnutex, защищающий условную переменную, перед обработкой сообщения. unique lock предлагает такие операции, как lock () и unlock (), для низкоуровневого управления синхронизацией.
                </li>
            </ul>
            <p>С другой стороны, unique_lock может работать только с одним мьютексом. </p>
            <p>Соответствующий производитель producer() имеет следующий вид: </p>
            <img src="./15_6_p004.png" alt="">
        </div>
    </div>
</body>