<head>
    <link rel="stylesheet" href="../../css/books_style.css">
</head>

<body>
    <div class="book-title">
        <p><a href="./7_4_2.html">&lArr;7.4.2 Передача аргументов</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="./7_6.html">7.6 Советы&rArr;</a></p>
        <h2>7.5. Модеnь компиnяции wабnонов</h2>
        <hr>
        <div>
            <p>В предположении наличия концептов (§7.2), аргументы шаблона проверяются на соответствие его концептам. Об обнаруженных ошибках компилятор сообщает программисту, который должен решить указанные проблемы. Проверка того, что в данный момент не
                может быть проверено, например аргументы для неограниченных шаблонных параметров, переносится на то время, когда будет сгенерирован код для шаблона и его набора аргументов - "во время инстанцирования шаблона". В случае кода, разработанного
                до появления концептов, именно в этот момент и происходит проверка всех типов. При использовании концептов эта проверка выполняется только после того, как успешно завершена проверка концептов.</p>
            <p>Неприятный побочный эффект (поздней) проверки типов времени инстанцирования заключается в том, что ошибка типа может быть обнаружена слишком поздно и привести к поразительно плохим сообщениям об ошибках, поскольку компилятор обнаруживает проблему
                только после объединения информации из нескольких мест программы.</p>
            <p>Проверка типа времени инстанцирования, предоставляемая для шаблонов, проверяет использование аргументов в определении шаблона. Это обеспечивает неявную типизацию времени компиляции, часто именуемую утиной типизацией ("Если нечто выглядит,
                как утка, плавает, как утка, и крякает, как утка, то это, вероятно, и есть утка"). Используя более техническую терминологию, мы работаем со значениями, а наличие и смысл операции зависят исключительно от значений операндов. Это отличается
                от альтернативного представления о том, что объекты имеют типы, которые определяют наличие и смысл операций. Значения "живут" в объектах. Это способ работы объектов (например, переменных) в С++, и только значения, соответствующие требованиям
                объекта, могут быть в него помещены. То, что делается во время компиляции с использованием шаблонов, в основном не касается объектов и имеет дело только со значениями. Исключение составляют локальные переменные в соnstехрr-функции (§ 1.6),
                которые используются внутри компилятора как объекты.
            </p>
            <p>Чтобы использовать неограниченный шаблон, его определение (а не только его объявление) должно быть в области видимости в точке использования. Например, стандартный заголовочный файл &lt;vector&gt; содержит определение vector. На практике это
                означает, что определения шаблонов обычно находятся в заголовочных файлах, а не в . срр-файлах. Все изменяется, когда мы начинаем использовать модули (§3.3). При использовании модулей исходный текст организован одинаково как для обычных
                функций, так и для шаблонных. В обоих случаях определения будут защищены от проблем, связанных с включением текста.
            </p>
        </div>
    </div>
</body>