<head>
    <link rel="stylesheet" href="../../../css/books_style.css">
</head>

<body>
    <div>
        <p><a href="./02_02.html">&lArr;Глава 2. Приложение "Круг"</a></p>
        <h1>ГЛАВА 3</h1>
        <h2>Создание приложения "Тетрис"</h2>
        <hr>
        <p>В этой главе мы разрабатываем классический тетрис. Мы смотрим дальше в класс Window, включая написание текста и рисование более сложных фигур. Мы также смотрим на сроки, случайные числа и графические обновления, такие как падающие фигуры и эффекты
            вспышки. Иллюстрация показана ниже: </p>
        <img src="03_01_01.png" alt="" class="img-center">
        <h3>Функция MainWindow</h3>
        <p>Функция MainWindow аналогична методам из главы 2, Hello, Small World !. Он устанавливает имя приложения и возвращает указатель на главное окно, которое в данном случае является экземпляр класса TetrisWindow. Как сказано в главе 2 «Привет, маленький
            мир!» то имя приложения используется при доступе к реестру, при открытии или сохранении файла, а также пункт меню «О программе». Однако ни одна из этих функций не используется в этом приложении: </p>
        <h4>MainWindow.cpp</h4>
        <p class="cpp_code">#include "..\\SmallWindows\\SmallWindows.h"</p>
        <p class="cpp_code">#include "GameGrid.h"</p>
        <p class="cpp_code">#include "TetrisFigure.h"</p>
        <p class="cpp_code">#include "RedFigure.h"</p>
        <p class="cpp_code">#include "BrownFigure.h"</p>
        <p class="cpp_code">#include "TurquoiseFigure.h"</p>
        <p class="cpp_code">#include "GreenFigure.h"</p>
        <p class="cpp_code">#include "YellowFigure.h"</p>
        <p class="cpp_code">#include "BlueFigure.h"</p>
        <p class="cpp_code">#include "PurpleFigure.h"</p>
        <p class="cpp_code">#include "TetrisWindow.h"</p><br>
        <p class="cpp_code">void MainWindow(vector &lt;String&gt; /* argumentList */, WindowShow windowShow) {</p>
        <p class="cpp_code_1t">Application::ApplicationName() = TEXT("Tetris");</p>
        <p class="cpp_code_1t">Application::MainWindowPtr() = new TetrisWindow(windowShow);</p>
        <p class="cpp_code">}</p>
        <h3>Окно тетриса</h3>
        <p>В этом приложении мы не используем структуру StandardDocument из Главы 2, Привет, маленький мир !. Вместо этого класс TetrisWindow расширяет корневой класс Small Windows. Окно прямо. Причина в том, что нам не нужна функциональность Платформа StandardDocument
            или ее базовый класс Document. Мы не используем меню или ускорители, и мы не сохраняем и не загружаем файлы: </p>
        <h4>TetrisWindow.h</h4>
        <p class="cpp_code">class TetrisWindow : public Window {</p>
        <p class="cpp_code_1t">public:</p>
        <p class="cpp_code_2t">TetrisWindow(WindowShow windowShow);</p>
        <p class="cpp_code_2t">~TetrisWindow();</p>
        <p>В этом приложении мы игнорируем мышь. Вместо этого мы рассмотрим работу с клавиатурой. В Метод OnKeyDown вызывается, когда пользователь нажимает или отпускает клавишу: </p>
        <p class="cpp_code_2t">bool OnKeyDown(WORD key, bool shiftPressed, bool controlPressed);</p>
        <p>Подобно круглому приложению, метод OnDraw вызывается каждый раз, когда клиент окна область нужно перерисовать: </p>
        <p class="cpp_code_2t">void OnDraw(Graphics& graphics, DrawMode drawMode) const;</p>
        <p>Методы OnGainFocus и OnLoseFocus вызываются, когда окно получает или теряет фокус ввода соответственно. Когда окно теряет фокус ввода, оно не получает никаких ввод с клавиатуры и таймер отключается, предотвращая перемещение падающей фигуры: </p>
        <p class="cpp_code_2t">void OnGainFocus();</p>
        <p class="cpp_code_2t">void OnLoseFocus();</p>
        <p>Метод OnTimer вызывается каждую секунду, когда окно находится в фокусе. Он пытается переместить падающая фигура на один шаг вниз. Он вызывает метод NewFigure, если не удается переместить фигура вниз. Метод NewFigure пытается представить новую
            фигуру в игре доска. Если это не удается, вызывается метод GameOver, который спрашивает пользователя, хочет ли он новый игра. Метод NewGame вызывается, если пользователь хочет новую игру. Если пользователь не хотите новую игру, выходит из
            приложения: </p>
        <p class="cpp_code_2t">void OnTimer(int timerId);</p>
        <p class="cpp_code_2t">void EndOfFigure();</p>
        <p class="cpp_code_2t">void GameOver();</p>
        <p class="cpp_code_2t">void NewGame();</p>
        <p>DeleteFullRows проверяет каждую строку, вызывая метод IsRowFull, и вызывает Методы FlashRow и DeleteRow для каждой полной строки: </p>
        <p class="cpp_code_2t">void DeleteFullRows();</p>
        <p class="cpp_code_2t">bool IsRowFull(int row);</p>
        <p class="cpp_code_2t">void FlashRow(int row);</p>
        <p class="cpp_code_2t">void DeleteRow(int markedRow);</p>
        <p>Метод TryClose вызывается, если пользователь пытается закрыть окно, щелкнув значок крестик в правом верхнем углу окна. Он отображает окно сообщения, которое спрашивает пользователя, если они действительно хотят бросить курить: </p>
        <p class="cpp_code_2t">bool TryClose();</p>
        <p>Поле gameGrid содержит сетку, на которой отображаются фигуры (см. Следующий раздел). Падающая фигура (падающая фигура) падает на сетку, а следующая фигура падает down (nextFigure) отображается в правом верхнем углу. Каждый раз, когда игрок заполняет
            строку, оценка (currScore) увеличивается. Идентификатор таймера (TimerId) необходим для отслеживания таймер и получает произвольное значение 1000. Наконец, список фигур (figureList) будет быть заполненным семью фигурами, по одной каждого цвета.
            Каждый раз, когда требуется новая фигура, случайным образом выбранная фигура из списка будет выбрана и скопирована: </p>
        <p class="cpp_code_1t">private:</p>
        <p class="cpp_code_2t">GameGrid gameGrid;</p>
        <p class="cpp_code_2t">TetrisFigure fallingFigure, nextFigure;</p><br>
        <p class="cpp_code_2t">int currScore = 0;</p>
        <p class="cpp_code_2t">bool timerActive = true, inverse = false;</p><br>
        <p class="cpp_code_2t">static const int TimerId = 1000;</p>
        <p class="cpp_code_2t">vector&lt;TetrisFigure&gt; figureList;</p>
        <p class="cpp_code">};</p>
        <p>Параметр PreviewCoordinate в вызове конструктора Window указывает, что размер окна фиксированный, а второй параметр указывает, что размер составляет 100 * 100 единиц. Это означает, что, в отличие от приложения круга, размер фигур и игровых полей
            будет изменить, когда пользователь изменяет размер окна: </p>
        <h4>TetrisWindow.cpp</h4>
        <p class="cpp_code">#include "..\\SmallWindows\\SmallWindows.h"</p>
        <p class="cpp_code">#include "GameGrid.h"</p>
        <p class="cpp_code">#include "TetrisFigure.h"</p>
        <p class="cpp_code">#include "RedFigure.h"</p>
        <p class="cpp_code">#include "BrownFigure.h"</p>
        <p class="cpp_code">#include "TurquoiseFigure.h"</p>
        <p class="cpp_code">#include "GreenFigure.h"</p>
        <p class="cpp_code">#include "YellowFigure.h"</p>
        <p class="cpp_code">#include "BlueFigure.h"</p>
        <p class="cpp_code">#include "PurpleFigure.h"</p>
        <p class="cpp_code">#include "TetrisWindow.h"</p><br>
        <p class="cpp_code">TetrisWindow::TetrisWindow(WindowShow windowShow)</p>
        <p class="cpp_code_3t">:Window(PreviewCoordinate, Rect(0, 0, 100, 100),</p>
        <p class="cpp_code_5t">nullptr, OverlappedWindow, NoStyle, Normal),</p>
        <p>Верхние 20 процентов клиентской области зарезервированы для оценки и следующей цифры. А игровая сетка покрывает нижние 80 процентов клиентской области (от 20 до 100 единиц высоты): </p>
        <p class="cpp_code_5t">gameGrid(Rect(0, 20, 100, 100)) {</p>
        <p>Поскольку мы расширяем класс Window, нам нужно установить заголовок окна вручную: </p>
        <p class="cpp_code_1t">SetHeader(TEXT("Tetris"));</p>
        <p>Интервал таймера установлен на 1000 миллисекунд, что означает, что будет вызываться OnTimer. каждую секунду. Генератор случайных чисел инициализируется вызовом стандартных функций языка Си. srand и время: </p>
        <p class="cpp_code_1t">SetTimer(TimerId, 1000);</p>
        <p class="cpp_code_1t">srand((unsigned int) time(nullptr));</p>
        <p>Список фигур инициализируется одной фигурой каждого цвета; падающая и следующая фигура случайно выбранный из этого списка. Одна из фигур в списке будет копироваться каждый раз, когда мы нужна новая фигура: </p>
        <p class="cpp_code_1t">figureList.push_back(RedFigure(this, &gameGrid));</p>
        <p class="cpp_code_1t">figureList.push_back(BrownFigure(this, &gameGrid));</p>
        <p class="cpp_code_1t">figureList.push_back(TurquoiseFigure(this, &gameGrid));</p>
        <p class="cpp_code_1t">figureList.push_back(GreenFigure(this, &gameGrid));</p>
        <p class="cpp_code_1t">figureList.push_back(YellowFigure(this, &gameGrid));</p>
        <p class="cpp_code_1t">figureList.push_back(BlueFigure(this, &gameGrid));</p>
        <p class="cpp_code_1t">figureList.push_back(PurpleFigure(this, &gameGrid));</p><br>
        <p class="cpp_code_1t">fallingFigure = figureList[rand() % figureList.size()];</p>
        <p class="cpp_code_1t">nextFigure = figureList[rand() % figureList.size()];</p>
        <p class="cpp_code">}</p>
        <p>Строго говоря, не обязательно сбрасывать таймер при закрытии окна Тетриса. В деструктор включен только для полноты: </p>
        <p class="cpp_code">TetrisWindow::~TetrisWindow() {</p>
        <p class="cpp_code_1t">DropTimer(TimerId);</p>
        <p class="cpp_code">}</p>
        <h3>Ввод с клавиатуры </h3>
        <p>Метод OnKeyDown переопределяет метод в классе Window и вызывается каждый раз. пользователь нажимает клавишу. Падающую фигуру стараемся перемещать в соответствии с нажатой клавишей. Нам все равно, нажал ли пользователь клавишу Shift или Ctrl: </p>
        <p class="cpp_code">bool TetrisWindow::OnKeyDown(WORD key, bool /* shiftPressed */,</p>
        <p class="cpp_code_5t">bool /* controlPressed */) {</p>
        <p class="cpp_code_1t">switch (key) {</p>
        <p class="cpp_code_2t">case KeyLeft:</p>
        <p class="cpp_code_3t">fallingFigure.TryMoveLeft();</p>
        <p class="cpp_code_3t">break;</p>
        <p class="cpp_code_2t">case KeyRight:</p>
        <p class="cpp_code_3t">fallingFigure.TryMoveRight();</p>
        <p class="cpp_code_3t">break;</p>
        <p class="cpp_code_2t">case KeyUp:</p>
        <p class="cpp_code_3t">fallingFigure.TryRotateAnticlockwise();</p>
        <p class="cpp_code_3t">break;</p>
        <p class="cpp_code_2t">case KeyDown:</p>
        <p class="cpp_code_3t">fallingFigure.TryRotateAnticlockwise();</p>
        <p class="cpp_code_3t">break;</p>
        <p>Когда пользователь нажимает клавишу пробела, падающая фигура падает с видимой скоростью, создавая иллюзия падения. Мы пытаемся перемещать падающую фигуру на один шаг вниз каждые 10 миллисекунд на вызов функции Win32 API Sleep. Метод TryMoveDown
            возвращает false, если он больше невозможно переместить фигуру вниз: </p>
        <p class="cpp_code_2t">case KeySpace:</p>
        <p class="cpp_code_3t">while (fallingFigure.TryMoveDown()) {</p>
        <p class="cpp_code_4t">::Sleep(10);</p>
        <p class="cpp_code_3t">}</p>
        <p class="cpp_code_3t">break;</p>
        <p class="cpp_code_1t">}</p>
        <p class="cpp_code_1t">return true;</p>
        <p class="cpp_code">}</p>
        <h3>Рисование</h3>
        <p>Метод OnDraw начинается с рисования игровой сетки и двух линий, разделяющих клиентскую область. на три части. В верхнем левом углу отображается текущий счет, в правом верхнем углу отображается следующий рисунок, а в нижней части отображается фактическая
            игровая сетка: </p>
        <p class="cpp_code">void TetrisWindow::OnDraw(Graphics& graphics,</p>
        <p class="cpp_code_5t"> DrawMode /* drawMode */) const {</p>
        <p class="cpp_code_1t">gameGrid.DrawGameGrid(graphics, inverse);</p>
        <p class="cpp_code_1t">graphics.FillRectangle(Rect(Point(0, 0), Point(100,20)), White, White);</p>
        <p class="cpp_code_1t">graphics.DrawLine(Point(40, 0), Point(40, 20), Black);</p>
        <p class="cpp_code_1t">graphics.DrawLine(Point(0, 20), Point(100, 20), Black);</p>
        <p>Обратите внимание, что мы добавляем смещение при рисовании следующей фигуры, чтобы выйти из игры. сетку в верхний правый угол. Значение 25 перемещает фигуру из середины сетки в середину его правой половины, а значение -18 перемещается из сетки
            вверх в область, предшествующую сетки: </p>
        <p class="cpp_code_1t">fallingFigure.DrawFigure(graphics);</p>
        <p class="cpp_code_1t">nextFigure.DrawFigure(graphics, Size(25, -18));</p>
        <p>Шрифт партитуры установлен на Times New Roman, размер 10. Здесь размер не относится к типографские точки, но до логических единиц. Поскольку в вызове конструктора Window указано, что мы дал систему координат PreviewCoordinate и размер 100 * 100,
            высоту text будет 10 единиц, что составляет десятую часть высоты текстовой клиентской области. Это тоже половина высоты части клиентской области, где написана оценка: </p>
        <p class="cpp_code_1t">Font scoreFont(TEXT("Times New Roman"), 10);</p>
        <p>Последний параметр false в вызове метода DrawText указывает, что размер текст не будет пересчитан. В следующих главах мы будем отображать текст, сохраняющий тот же размер, независимо от размера окна и разрешения экрана. Однако в этой главе размер
            текста будет изменен, когда пользователь изменит размер окна: </p>
        <p class="cpp_code_1t">graphics.DrawText(Rect(0, 0, 40, 20), to_String(currScore), </p>
        <p class="cpp_code_5t">scoreFont, Black, White, false);</p>
        <p class="cpp_code">}</p>
        <h3>Фокус ввода</h3>
        <p>Методы OnGainFocus и OnLoseFocus запускают и останавливают таймер соответственно, чтобы падающая фигура не падает, когда окно не в фокусе: </p>
        <p class="cpp_code">void TetrisWindow::OnGainFocus() {</p>
        <p class="cpp_code_1t">SetTimer(TimerId, 1000);</p>
        <p class="cpp_code">}</p><br>
        <p class="cpp_code">void TetrisWindow::OnLoseFocus() {</p>
        <p class="cpp_code_1t">DropTimer(TimerId);</p>
        <p class="cpp_code">}</p>
        <h3>Таймер</h3>
        <p>Таймер активен, когда он находится в фокусе ввода. Когда он активен, метод TryMoveDown будет вызываться каждый раз при вызове метода OnTimer (раз в секунду). Когда фигура больше не может упасть (метод TryMoveDown возвращает false), EndOfFigure
            метод называется: </p>
        <p class="cpp_code">void TetrisWindow::OnTimer(int /* timerId */) {</p>
        <p class="cpp_code_1t">if (timerActive) {</p>
        <p class="cpp_code_2t">if (!fallingFigure.TryMoveDown()) {</p>
        <p class="cpp_code_3t">EndOfFigure();</p>
        <p class="cpp_code_2t">}</p>
        <p class="cpp_code_1t">}</p>
        <p class="cpp_code">}</p>
        <h3>Новые фигуры</h3>
        <p>Когда падающая фигура не может двигаться вниз, метод OnTimer вызывает метод NewFigure. Во-первых, нам нужно сохранить падающую фигуру в игровой сетке, вызвав метод AddToGrid. Затем мы позволяем следующей фигуре стать новой падающей фигурой, и
            мы случайным образом выбрать новую следующую фигуру из списка фигур. Мы аннулируем площадь новая падающая фигура и область правого верхнего угла, где нарисована следующая фигура: </p>
        <p class="cpp_code">void TetrisWindow::NewFigure() {</p>
        <p class="cpp_code_1t">fallingFigure.AddToGrid();</p>
        <p class="cpp_code_1t">fallingFigure = nextFigure;</p>
        <p class="cpp_code_1t">fallingFigure.InvalidateFigure();</p>
        <p class="cpp_code_1t">nextFigure = figureList[rand() % figureList.size()];</p>
        <p class="cpp_code_1t">Rect nextArea(40, 0, 100, 20);</p>
        <p class="cpp_code_1t">Invalidate(nextArea);</p>
        <p class="cpp_code_1t">UpdateWindow();</p>
        <p>Удаляем возможные полные строки и обновляем окно: </p>
        <p class="cpp_code_1t">DeleteFullRows();</p>
        <p class="cpp_code_1t">UpdateWindow();</p>
        <p>Если новая падающая фигура не действительна с самого начала, игра окончена и GameOver называется: </p>
        <p class="cpp_code_1t">if (!fallingFigure.IsFigureValid()) {</p>
        <p class="cpp_code_2t">GameOver();</p>
        <p class="cpp_code_1t">}</p>
        <p class="cpp_code">}</p>
        <h3>Игра окончена</h3>
        <p>Метод GameOver представляет счет и позволяет пользователю решить, хочет ли он новый игра. Если они хотят новую игру, она инициализируется вызовом NewGame. Если пользователь не хотите новую игру, вызов функции Win32 API PostQuitMessage завершает
            оформление заявки.</p>
        <p>Обратите внимание, что мы вызываем другую версию метода Invalidate без параметров. Это делает недействительной всю клиентскую область: </p>
        <p class="cpp_code">void TetrisWindow::GameOver() {</p>
        <p class="cpp_code_1t">Invalidate();</p>
        <p class="cpp_code_1t">UpdateWindow();</p>
        <p>Таймер неактивен, пока отображается сообщение: </p>
        <p class="cpp_code_1t">timerActive = false;</p>
        <p class="cpp_code_1t">String message = TEXT("Game Over.\nYou scored ") +</p>
        <p class="cpp_code_5t">to_String(currScore) + </p>
        <p class="cpp_code_5t">TEXT(" points.\nAnother game?");</p>
        <p class="cpp_code_1t">if (MessageBox(message, TEXT("Tetris"), YesNo, Question)==Yes) {</p>
        <p class="cpp_code_2t">NewGame();</p>
        <p class="cpp_code_1t">}</p>
        <p class="cpp_code_1t">else {</p>
        <p class="cpp_code_2t">::PostQuitMessage(0);</p>
        <p class="cpp_code_1t">}</p>
        <p class="cpp_code">}</p>
        <h3>Новая игра</h3>
        <p>Метод NewGame инициализирует случайно выбранные новые падающие и следующие фигуры, сбрасывает счет и очищает игровую сетку перед активацией таймера, а также делает недействительными и обновляет окно, в результате чего новая падающая фигура начинает
            падать, а новая игра начать: </p>
        <p class="cpp_code">void TetrisWindow::NewGame() {</p>
        <p class="cpp_code_1t">fallingFigure = figureList[rand() % figureList.size()];</p>
        <p class="cpp_code_1t">nextFigure = figureList[rand() % figureList.size()];</p><br>
        <p class="cpp_code_1t">currScore = 0;</p>
        <p class="cpp_code_1t">gameGrid.ClearGameGrid();</p>
        <p class="cpp_code_1t">timerActive = true;</p>
        <p class="cpp_code_1t">Invalidate();</p>
        <p class="cpp_code_1t">UpdateWindow();</p>
        <p class="cpp_code">}</p>
        <h3>Удаление и мигание строк</h3>
        <p>При удалении полных строк мы перебираем строки, мигая и удаляя каждую полную строку. Увеличиваем оценку и обновляем площадь строки. Обратите внимание, что строки начинаются сверху сетки. Это означает, что мы должны пройти цикл от самой высокой
            строки к самой низкой строке, чтобы удалите строку в правильном порядке.</p>
        <p>Обратите внимание: если строка мигает и удаляется, мы не обновляем переменную строки, так как удаленная строка будет заменена на строку выше, которую также необходимо изучить: </p>
        <p class="cpp_code">void TetrisWindow::DeleteFullRows() {</p>
        <p class="cpp_code_1t">int row = Rows - 1;</p>
        <p class="cpp_code_1t">while (row >= 0) {</p>
        <p class="cpp_code_2t">if (IsRowFull(row)) {</p>
        <p class="cpp_code_3t">FlashRow(row);</p>
        <p class="cpp_code_3t">DeleteRow(row);</p><br>
        <p class="cpp_code_3t">++currScore;</p>
        <p class="cpp_code_3t">Rect scoreArea(0, 0, 40, 20);</p>
        <p class="cpp_code_3t">Invalidate(scoreArea);</p>
        <p class="cpp_code_3t">UpdateWindow();</p>
        <p class="cpp_code_2t">}</p>
        <p class="cpp_code_2t">else {</p>
        <p class="cpp_code_3t">--row;</p>
        <p class="cpp_code_2t">}</p>
        <p class="cpp_code_1t">}</p>
        <p class="cpp_code">}</p>
        <p>Строка считается полной, если в ней нет белого квадрата: </p>
        <p class="cpp_code">bool TetrisWindow::IsRowFull(int row) {</p>
        <p class="cpp_code_1t">for (int col = 0; col &lt; Cols; ++col) {</p>
        <p class="cpp_code_2t">if (gameGrid[row][col] == White) {</p>
        <p class="cpp_code_3t">return false;</p>
        <p class="cpp_code_2t">}</p>
        <p class="cpp_code_1t">}</p>
        <p class="cpp_code_1t">return true;</p>
        <p class="cpp_code">}</p>
        <p>Эффект вспышки выполняется путем перерисовки строки в нормальном и инвертированном цвете ( установлен обратный метод) трижды с интервалом 50 миллисекунд. При этом он особенно важно, чтобы мы аннулировали только область выбранной строки. В противном
            случае вся клиентская область окна будет мигать: </p>
        <p class="cpp_code">void TetrisWindow::FlashRow(int row) {</p>
        <p class="cpp_code_1t">Rect gridArea = gameGrid.GridArea();</p>
        <p class="cpp_code_1t">int colWidth = gridArea.Width() / Cols, rowHeight = gridArea.Height() / Rows;</p>
        <p class="cpp_code_1t">Rect rowArea(0, row * rowHeight, Cols * colWidth, (row + 1) * rowHeight);</p><br>
        <p class="cpp_code_1t">for (int count = 0; count &lt; 3; ++count) {</p>
        <p class="cpp_code_2t">inverse = true;</p>
        <p class="cpp_code_2t">Invalidate(rowArea + gridArea.Top()Left());</p>
        <p class="cpp_code_2t">UpdateWindow();</p>
        <p class="cpp_code_2t">::Sleep(50);</p><br>
        <p class="cpp_code_2t">inverse = false;</p>
        <p class="cpp_code_2t">Invalidate(rowArea + gridArea.Top()Left());</p>
        <p class="cpp_code_2t">UpdateWindow();</p>
        <p class="cpp_code_2t">::Sleep(50);</p>
        <p class="cpp_code_1t">}</p>
        <p class="cpp_code">}</p>
        <p>При удалении строки мы ее не удаляем. Вместо этого мы перемещаем каждую строку над удалите строку на один шаг вниз и заполните верхнюю строку белыми квадратами. Осложнение что мы считаем строки сверху. Это делает нижнюю строку на экране строкой
            с самый высокий индекс. Создается впечатление, что мы начинаем снизу и удаляем все полный ряд, пока не дойдем до вершины: </p>
        <p class="cpp_code">void TetrisWindow::DeleteRow(int markedRow) {</p>
        <p class="cpp_code_1t">for (int row = markedRow; row &gt; 0; --row) {</p>
        <p class="cpp_code_2t">for (int col = 0; col &lt; Cols; ++col) {</p>
        <p class="cpp_code_3t">gameGrid[row][col] = gameGrid[row - 1][col];</p>
        <p class="cpp_code_2t">}</p>
        <p class="cpp_code_1t">}</p>
        <p class="cpp_code_1t">for (int col = 0; col &lt; Cols; ++col) {</p>
        <p class="cpp_code_2t">gameGrid[0][col] = White;</p>
        <p class="cpp_code_1t">}</p>
        <p class="cpp_code_1t">Invalidate(gameGrid.GridArea());</p>
        <p class="cpp_code_1t">Invalidate(g);</p>
        <p class="cpp_code_1t">UpdateWindow();</p>
        <p class="cpp_code">}</p>
        <h3>Закрытие окна</h3>
        <p>Наконец, когда пользователь хочет закрыть окно, щелкнув крестик в правом верхнем углу углу, нам нужно подтвердить, что они действительно хотят бросить курить. Если метод TryClose возвращает правда, окно закрыто: </p>
        <p class="cpp_code">bool TetrisWindow::TryClose() {</p>
        <p class="cpp_code_1t">timerActive = false;</p>
        <p class="cpp_code_1t">if (MessageBox(TEXT("Quit?"), TEXT("Tetris"), YesNo, Question) == Yes) {</p>
        <p class="cpp_code_2t">return true;</p>
        <p class="cpp_code_1t">}</p>
        <p class="cpp_code_1t">timerActive = true;</p>
        <p class="cpp_code_1t">return false;</p>
        <p class="cpp_code">}</p>
        <h3>Класс TetrisFigure </h3>
        <p>В этом приложении есть класс корневых фигур и один подкласс для каждого типа падения. фигура. Все фигурки можно двигать боком или поворачивать в ответ на запросы пользователя. Они также перемещаются вниз по таймеру.</p>
        <p>Есть семь цифр, по одной для каждого цвета: красный, коричневый, бирюзовый, зеленый, желтый, синий и фиолетовый. Каждый из них также имеет уникальную форму. Однако все они содержат четыре квадрата. Они далее можно разделить на три группы в зависимости
            от их способности вращаться. Красная цифра - это самый простой. Это квадрат и он вообще не вращается. Коричневая, бирюзовая и зеленая фигура можно вращать в вертикальном и горизонтальном направлениях, а желтый, синий и фиолетовый фигуры можно
            вращать в северном, восточном, южном и западном направлениях. Для красной фигуры это не имеет особого значения, так как он не вращается.</p>
        <p>Поля row и col класса TetrisFigure содержат центр фигуры, т.е. помечены крестиком на иллюстрациях этого раздела. Цветовое поле содержит цвет figure, а direction - текущее направление фигуры.</p>
        <p>Наконец, массив направлений содержит относительные положения трех квадратов, окружающих отмеченный квадрат. Максимум четыре направления. В каждом направлении по три квадрата, которые представляют собой три оставшихся квадрата, которые не являются
            центром фигуры. Каждый квадрат содержит два целых числа: относительное положение центральной строки и столбца.</p>
        <p>Конструктор по умолчанию необходим для инициализации FallFigure и nextFigure. методы в классе TetrisWindow. Второй конструктор защищен, поскольку он только вызывается его подклассами. У каждой фигуры есть свой подкласс TetrisFigure. Их конструкторы
            наведите указатель на цветовую сетку и определите ее цвет, начальную позицию и образцы рисунка: </p>
        <h4>TetrisFigure.h</h4>
        <p class="cpp_code">class TetrisFigure {</p>
        <p class="cpp_code_1t">public:</p>
        <p class="cpp_code_2t">TetrisFigure();</p><br>
        <p class="cpp_code_1t">protected:</p>
        <p class="cpp_code_2t">TetrisFigure(Window* windowPtr, GameGrid* colorGridPtr,</p>
        <p class="cpp_code_5t">Color color, int row, int col, Direction direction,</p>
        <p class="cpp_code_5t">IntPair* northList, IntPair* eastList, </p>
        <p class="cpp_code_5t">IntPair* southList, IntPair* westList);</p><br>
        <p class="cpp_code_1t">public:</p>
        <p class="cpp_code_2t">TetrisFigure& operator=(const TetrisFigure& figure);</p>
        <p>TryMoveLeft, TryMoveRight, TryRotateClockwise, TryRotateClockwise, Все методы TryRotateAnticlockwise и TryMoveDown пытаются переместить фигуру. Они вызвать метод IsFigureValid, который проверяет, допустимо ли новое местоположение, то есть не находится
            за пределами игровой сетки или в уже занятой локации. IsFigureValid , в свою очередь, вызывает метод IsSquareValid для каждого из четырех квадратов: </p>
        <p class="cpp_code_2t">void TryMoveLeft();</p>
        <p class="cpp_code_2t">void TryMoveRight();</p>
        <p class="cpp_code_2t">void TryRotateClockwise();</p>
        <p class="cpp_code_2t">void TryRotateAnticlockwise();</p>
        <p class="cpp_code_2t">bool TryMoveDown();</p>
        <p>Существует две версии метода IsFigureValid, первая из которых вызывается метод TetrisWindow, а другая версия вызывается предыдущими методами try в чтобы проверить, действительно ли новое местоположение падающей фигуры: </p>
        <p class="cpp_code_2t">bool IsFigureValid();</p>
        <p class="cpp_code_2t">static bool IsFigureValid(int direction, int row, int col, </p>
        <p class="cpp_code_5t">GameGrid* gameGridPtr, IntPair* figureInfo[]);</p>
        <p class="cpp_code_2t">static bool IsSquareValid(int row, int col, GameGrid* gameGridPtr);</p>
        <p>Метод AddToGrid добавляет четыре квадрата фигуры в игровую сетку: </p>
        <p class="cpp_code_2t">void AddToGrid();</p>
        <p>Метод InvalidateFigure аннулирует область, занимаемую фигурой, и Метод DrawFigure рисует фигуру: </p>
        <p class="cpp_code_2t">void InvalidateFigure(Size offsetSize = ZeroSize);</p>
        <p class="cpp_code_2t">void DrawFigure(Graphics& graphics, Size offsetSize = ZeroSize) const;</p>
        <p>Поле gameGridPtr - это указатель на игровую сетку, к которой мы обращаемся, когда пытаемся переместить фигура, чтобы решить, действительно ли ее новое местоположение. Цветное поле - это цвет фигура (красный, коричневый, бирюзовый, зеленый, желтый,
            синий или фиолетовый). Строка, столбец и Поля направления содержат текущее местоположение и направление фигуры.</p>
        <p>Поле figureInfo содержит форму фигуры. Фигура может вместить до четырех направления: север, восток, юг и запад. Помните, что строка и столбец содержат расположение цифры. В частности, они определяют расположение центрального квадрата из четырех
            квадратов. составляющие рисунок (отмечены крестиком на следующих рисунках). Остальные три квадраты определяются парами целых чисел, определяющими их положение относительно центрального квадрата. </p>
        <p>Технически figureInfo представляет собой массив из четырех указателей (по одному для направлений север, восток, юг и запад). Каждый указатель указывает на массив из трех целочисленных пар, содержащих ячейки из трех квадратов относительно центрального
            квадрата: </p>
        <p class="cpp_code_1t">protected:</p>
        <p class="cpp_code_2t">Window* windowPtr;</p>
        <p class="cpp_code_2t">GameGrid* gameGridPtr;</p>
        <p class="cpp_code_2t">Color color;</p>
        <p class="cpp_code_2t">int row, col;</p>
        <p class="cpp_code_2t">Direction direction;</p>
        <p class="cpp_code_2t">IntPair* figureInfo[4];</p>
        <p class="cpp_code">};</p>
        <p>Конструктор по умолчанию необходим, потому что FallFigure и nextFigure являются членами объекты класса TetrisWindow. Однако их не нужно инициализировать, так как их значениям присваивается одна из семи цифр в массиве figureList: </p>
        <h4>TetrisFigure.cpp</h4>
        <p class="cpp_code">#include "..\\SmallWindows\\SmallWindows.h"</p>
        <p class="cpp_code">#include "GameGrid.h"</p>
        <p class="cpp_code">#include "TetrisFigure.h"</p>
        <p class="cpp_code">#include "TetrisWindow.h"</p><br>
        <p class="cpp_code">TetrisFigure::TetrisFigure() {</p>
        <p class="cpp_code_1t">// Empty</p>
        <p class="cpp_code">}</p>
        <p>Второй конструктор вызывается конструктором подкласса цветного рисунка, чтобы инициализировать фигуру. Требуется указатель на главное окно и игровую сетку, цвет фигура, ее начальное местоположение и направление, а также списки ее местоположений
            на севере, востоке, юге и западные направления. Каждый из списков содержит три пары целых чисел, представляющих расположение квадраты относительно центрального квадрата: </p>
        <p class="cpp_code">TetrisFigure::TetrisFigure(Window*windowPtr, GameGrid*gameGridPtr,</p>
        <p class="cpp_code_5t">Color color, int row, int col, Direction direction,</p>
        <p class="cpp_code_5t">IntPair* northList, IntPair* eastList,</p>
        <p class="cpp_code_5t">IntPair* southList, IntPair* westList)</p>
        <p class="cpp_code_1t">:windowPtr(windowPtr),</p>
        <p class="cpp_code_1t">gameGridPtr(gameGridPtr),</p>
        <p class="cpp_code_1t">color(color),</p>
        <p class="cpp_code_1t">row(row),</p>
        <p class="cpp_code_1t">col(col),</p>
        <p class="cpp_code_1t">direction(direction) {</p>
        <p class="cpp_code_2t">figureInfo[North] = northList;</p>
        <p class="cpp_code_2t">figureInfo[East] = eastList;</p>
        <p class="cpp_code_2t">figureInfo[South] = southList;</p>
        <p class="cpp_code_2t">figureInfo[West] = westList;</p>
        <p class="cpp_code">}</p>
        <p>Оператор присваивания необходим, потому что падающие рисунки и nextFigure методы в классе TetrisWindow копируются из списка рисунков: </p>
        <p class="cpp_code">TetrisFigure& TetrisFigure::operator=(const TetrisFigure& figure) {</p>
        <p class="cpp_code_1t">if (this != &figure) {</p>
        <p class="cpp_code_2t">windowPtr = figure.windowPtr;</p>
        <p class="cpp_code_2t">gameGridPtr = figure.gameGridPtr;</p>
        <p class="cpp_code_2t">color = figure.color;</p>
        <p class="cpp_code_2t">row = figure.row;</p>
        <p class="cpp_code_2t">col = figure.col;</p>
        <p class="cpp_code_2t">direction = figure.direction;</p>
        <p class="cpp_code_2t">figureInfo[North] = figure.figureInfo[North];</p>
        <p class="cpp_code_2t">figureInfo[East] = figure.figureInfo[East];</p>
        <p class="cpp_code_2t">figureInfo[South] = figure.figureInfo[South];</p>
        <p class="cpp_code_2t">figureInfo[West] = figure.figureInfo[West];</p>
        <p class="cpp_code_1t">}</p>
        <p class="cpp_code_1t">return *this;</p>
        <p class="cpp_code">}</p>
        <p>TryMoveLeft, TryMoveRight, TryRotateClockwise и Методы TryRotateAnticlockwise вызываются, когда пользователь нажимает клавиши со стрелками. Они попробуйте переместить фигуру и аннулировать ее предыдущую и текущую области, если им это удастся:</p>
        <p class="cpp_code">void TetrisFigure::TryMoveLeft() {</p>
        <p class="cpp_code_1t">if (IsFigureValid(direction, row, col - 1 gameGridPtr, figureInfo)) {</p>
        <p class="cpp_code_2t">windowPtr-&gt;Invalidate(Area());</p>
        <p class="cpp_code_2t">--col;</p>
        <p class="cpp_code_2t">windowPtr-&gt;Invalidate(Area());</p>
        <p class="cpp_code_2t">windowPtr-&gt;UpdateWindow();</p>
        <p class="cpp_code_1t">}</p>
        <p class="cpp_code">}</p><br>
        <p class="cpp_code">void TetrisFigure::TryMoveRight() {</p>
        <p class="cpp_code_1t">if (IsFigureValid(direction, row, col + 1 gameGridPtr, figureInfo)) {</p>
        <p class="cpp_code_2t">windowPtr->Invalidate(Area());</p>
        <p class="cpp_code_2t">++col;</p>
        <p class="cpp_code_2t">windowPtr->Invalidate(Area());</p>
        <p class="cpp_code_2t">windowPtr->UpdateWindow();</p>
        <p class="cpp_code_1t">}</p>
        <p class="cpp_code">}</p><br>
        <p class="cpp_code">void TetrisFigure::TryRotateClockwise() {</p>
        <p class="cpp_code_1t">Direction newDirection = (direction == West) ? North : ((Direction) (direction + 1));</p>
        <p class="cpp_code_1t">if (IsFigureValid(newDirection, row, col, gameGridPtr, figureInfo)) {</p>
        <p class="cpp_code_2t">InvalidateFigure();</p>
        <p class="cpp_code_2t">direction = newDirection;</p>
        <p class="cpp_code_2t">InvalidateFigure();</p>
        <p class="cpp_code_2t">windowPtr->UpdateWindow();</p>
        <p class="cpp_code_1t">}</p>
        <p class="cpp_code">}</p><br>
        <p class="cpp_code">void TetrisFigure::TryRotateAnticlockwise() {</p>
        <p class="cpp_code_1t">Direction newDirection = (this->direction == North) ? West : ((Direction) (direction - 1));</p>
        <p class="cpp_code_1t">if (IsFigureValid(newDirection, row, col, gameGridPtr, figureInfo)) {</p>
        <p class="cpp_code_2t">InvalidateFigure();</p>
        <p class="cpp_code_2t">direction = newDirection;</p>
        <p class="cpp_code_2t">InvalidateFigure();</p>
        <p class="cpp_code_2t">windowPtr->UpdateWindow();</p>
        <p class="cpp_code_1t">}</p>
        <p class="cpp_code">}</p>
        <p>Метод TryMoveDown вызывается таймером, когда игрок нажимает клавишу пробела. это также вызывается методом OnTimer в классе TetrisWindow; возвращает логическое значение указывает, удалось ли движение: </p>
        <p class="cpp_code">bool TetrisFigure::TryMoveDown() {</p>
        <p class="cpp_code_1t">if (IsFigureValid(direction, row + 1, col gameGridPtr, figureInfo)) {</p>
        <p class="cpp_code_2t">windowPtr->Invalidate(Area());</p>
        <p class="cpp_code_2t">++row;</p>
        <p class="cpp_code_2t">windowPtr->Invalidate(Area());</p>
        <p class="cpp_code_2t">windowPtr->UpdateWindow();</p>
        <p class="cpp_code_2t">return true;</p>
        <p class="cpp_code_1t">}</p>
        <p class="cpp_code_1t">return false;</p>
        <p class="cpp_code">}</p>
        <p>Первая версия метода IsFigureValid вызывается классом TetrisWindow и вызывает вторую статическую версию с текущим расположением и направлением фигуры: </p>
        <p class="cpp_code">bool TetrisFigure::IsFigureValid() {</p>
        <p class="cpp_code_1t">return IsFigureValid(direction, row, col gameGridPtr, figureInfo);</p>
        <p class="cpp_code">}</p>
        <p>Вторая версия метода IsFigureValid вызывается предыдущими методами try и проверяет правильность цифры, вызывая метод IsSquareValid для каждого квадрата в фигура. Для этого ему необходимо найти относительные положения включенных квадраты в методе
            figureInfo. Первое значение целочисленных пар - это строка, а второе значение - столбец: </p>
        <p class="cpp_code">bool TetrisFigure::IsFigureValid(int direction, int row, int col,</p>
        <p class="cpp_code_5t">GameGrid* gameGridPtr, IntPair* figureInfo[]) {</p>
        <p class="cpp_code_1t">int relRow0 = row + figureInfo[direction][0].first,</p>
        <p class="cpp_code_2t">relCol0 = col + figureInfo[direction][0].second,</p>
        <p class="cpp_code_2t">relRow1 = row + figureInfo[direction][1].first,</p>
        <p class="cpp_code_2t">relCol1 = col + figureInfo[direction][1].second,</p>
        <p class="cpp_code_2t">relRow2 = row + figureInfo[direction][2].first,</p>
        <p class="cpp_code_2t">relCol2 = col + figureInfo[direction][2].second;</p><br>
        <p class="cpp_code_1t">return IsSquareValid(row, col, gameGridPtr) &&</p>
        <p class="cpp_code_3t">IsSquareValid(relRow0, relCol0, gameGridPtr) &&</p>
        <p class="cpp_code_3t">IsSquareValid(relRow1, relCol1, gameGridPtr) &&</p>
        <p class="cpp_code_3t">IsSquareValid(relRow2, relCol2, gameGridPtr);</p>
        <p class="cpp_code">}</p>
        <p>Метод IsSquareValid возвращает true, если данный квадрат находится внутри игры. сетка и еще не занята. Квадрат на игровом поле считается незанятым, если он белый: </p>
        <p class="cpp_code">bool TetrisFigure::IsSquareValid(int row, int col, GameGrid* gameGridPtr) {</p>
        <p class="cpp_code_1t">return (row &gt;= 0) && (row &lt; Rows) &&</p>
        <p class="cpp_code_3t">(col &gt;= 0) && (col &lt; Cols) &&</p>
        <p class="cpp_code_3t">((*gameGridPtr)[row][col] == White);</p>
        <p class="cpp_code">}</p>
        <p>Когда падающая фигура достигает своего конечного положения, она добавляется в игровую сетку. это выполняется путем установки цвета фигурки квадратов в игровой сетке в ее текущем местоположении. Падающая фигура достигла своего окончательного положения,
            когда она больше не может падать без сталкивается с более ранней фигурой или достиг нижней границы игровой сетки: </p>
        <p class="cpp_code">void TetrisFigure::AddToGrid() {</p>
        <p class="cpp_code_1t">(*gameGridPtr)[row][col] = color;</p>
        <p class="cpp_code_1t">{ int relRow = row + figureInfo[direction][0].first, relCol = col + figureInfo[direction][0].second;</p>
        <p class="cpp_code_2t">(*gameGridPtr)[relRow][relCol] = color;</p>
        <p class="cpp_code_1t">}</p><br>
        <p class="cpp_code_1t">{ int relRow = row + figureInfo[direction][1].first, relCol = col + figureInfo[direction][1].second;</p>
        <p class="cpp_code_2t">(*gameGridPtr)[relRow][relCol] = color;</p>
        <p class="cpp_code_1t">}</p><br>
        <p class="cpp_code_1t">{ int relRow = row + figureInfo[direction][2].first, relCol = col + figureInfo[direction][2].second;</p>
        <p class="cpp_code_2t">(*gameGridPtr)[relRow][relCol] = color;</p>
        <p class="cpp_code_1t">}</p>
        <p class="cpp_code">}</p>
        <p>Когда фигура была перемещена, нам нужно ее перерисовать. Чтобы избежать ослепления, мы хотим сделать недействительной только его область, что выполняется методом InvalidateFigure. Мы смотрим вверх строк и столбцов четырех квадратов фигуры и вызовите
            метод InvalidateSquare в игровая сетка для каждого из них: </p>
        <p class="cpp_code">void TetrisFigure::InvalidateFigure(Size offsetSize/*=ZeroSize*/){</p>
        <p class="cpp_code_1t">gameGridPtr->InvalidateSquare(windowPtr, row, col, offsetSize);</p>
        <p class="cpp_code_1t">{ int relRow = row + figureInfo[direction][0].first, relCol = col + figureInfo[direction][0].second;</p>
        <p class="cpp_code_2t">gameGridPtr->InvalidateSquare(windowPtr, relRow, relCol, offsetSize);</p>
        <p class="cpp_code_1t">}</p><br>
        <p class="cpp_code_1t">{ int relRow = row + figureInfo[direction][1].first, relCol = col + figureInfo[direction][1].second;</p>
        <p class="cpp_code_2t">gameGridPtr->InvalidateSquare(windowPtr, relRow, relCol, offsetSize);</p>
        <p class="cpp_code_1t">}</p><br>
        <p class="cpp_code_1t">{ int relRow = row + figureInfo[direction][2].first, relCol = col + figureInfo[direction][2].second;</p>
        <p class="cpp_code_2t">gameGridPtr->InvalidateSquare(windowPtr, relRow, relCol, offsetSize);</p>
        <p class="cpp_code_1t">}</p>
        <p class="cpp_code">}</p>
        <p>При рисовании фигуры нам нужно найти расположение квадратов фигуры. прежде чем рисовать их аналогично методу InvalidateFigure: </p>
        <p class="cpp_code">void TetrisFigure::DrawFigure(Graphics& graphics,Size offsetSize) const {</p>
        <p class="cpp_code_1t">gameGridPtr->DrawSquare(graphics, row, col, Black, color, offsetSize);</p>
        <p class="cpp_code_1t">{ int relRow = row + figureInfo[direction][0].first, relCol = col + figureInfo[direction][0].second;</p>
        <p class="cpp_code_2t">gameGridPtr->DrawSquare(graphics, relRow, relCol, Black, color, offsetSize);</p>
        <p class="cpp_code_1t">}</p><br>
        <p class="cpp_code_1t">{ int relRow = row + figureInfo[direction][1].first, relCol = col + figureInfo[direction][1].second;</p>
        <p class="cpp_code_2t">gameGridPtr->DrawSquare(graphics, relRow, relCol, Black, color, offsetSize);</p>
        <p class="cpp_code_1t">}</p><br>
        <p class="cpp_code_1t">{ int relRow = row + figureInfo[direction][2].first, relCol = col + figureInfo[direction][2].second;</p>
        <p class="cpp_code_2t">gameGridPtr->DrawSquare(graphics, relRow, relCol, Black, color, offsetSize);</p>
        <p class="cpp_code_1t">}</p>
        <p class="cpp_code">}</p>
        <h3>Красная фигура</h3>
        <p>Красная фигура представляет собой один большой квадрат, состоящий из четырех меньших правильных квадратов. Это самый простой фигурка игры, так как она не меняет форму при вращении. Это означает, что мы просто нужно посмотреть на одну цифру, показанную
            следующим образом: </p>
        <img src="03_01_02.png" alt="" class="img-center">
        <p>Это также означает, что достаточно определить квадраты для одного направления, и это позволяет определить форма фигуры во всех четырех направлениях: </p>
        <h4>RedFigure.h</h4>
        <p class="cpp_code">class RedFigure : public TetrisFigure {</p>
        <p class="cpp_code_1t">public:</p>
        <p class="cpp_code_2t">static IntPair GenericList[];</p>
        <p class="cpp_code_2t">RedFigure(Window* windowPtr, GameGrid* gameGridPtr);</p>
        <p class="cpp_code">};</p>
        <h4>RedFigure.cpp</h4>
        <p class="cpp_code">#include "..\\SmallWindows\\SmallWindows.h"</p>
        <p class="cpp_code">#include "GameGrid.h"</p>
        <p class="cpp_code">#include "TetrisFigure.h"</p>
        <p class="cpp_code">#include "RedFigure.h"</p><br>
        <p class="cpp_code">IntPair RedFigure::GenericList[] = {IntPair(0,1), IntPair(1,0), IntPair(1,1)};</p><br>
        <p class="cpp_code">RedFigure::RedFigure(Window* windowPtr, GameGrid* gameGridPtr) </p>
        <p class="cpp_code_1t">:TetrisFigure(windowPtr, gameGridPtr, Red, 1, (Cols / 2) - 1, </p>
        <p class="cpp_code_2t">North, GenericList, GenericList, GenericList, GenericList) {</p>
        <p class="cpp_code_3t">// Empty.</p>
        <p class="cpp_code">}</p>
        <p>Первая пара целых чисел (rel row 0, rel col 1) общего списка представляет квадрат для справа от отмеченного квадрата вторая пара целых чисел (rel row 1, rel col 0) представляет квадрат под отмеченным квадратом и третья пара целых чисел (отн. строка
            1, отн. столбец 1) представляет квадрат ниже и правее отмеченного квадрата. Обратите внимание, что строки увеличиваются вниз, а столбцы увеличиваются вправо. </p>
        <h3>Коричневая фигура </h3>
        <p>Коричневая фигура может быть ориентирована в горизонтальном или вертикальном направлении. Он инициализируется вертикальный режим, так как его можно повернуть только в двух направлениях. Северный и южный массивы инициализируются вертикальным массивом,
            а массивы восток и запад инициализируются горизонтальный массив, как показано на следующем изображении: </p>
        <img src="03_01_03.png" alt="" class="img-center">
        <p>Поскольку номера строк увеличиваются вниз, а номера столбцов - вправо, самый верхний квадрат в вертикальном направлении (и крайний левый квадрат в горизонтальном направление) представлены отрицательными значениями: </p>
        <h4>BrownFigure.h</h4>
        <p class="cpp_code">class BrownFigure : public TetrisFigure {</p>
        <p class="cpp_code_1t">public:</p>
        <p class="cpp_code_2t">static IntPair HorizontalList[], VerticalList[];</p>
        <p class="cpp_code_2t">BrownFigure(Window* windowPtr, GameGrid* gameGridPtr);</p>
        <p class="cpp_code">};</p>
        <h4>BrownFigure.cpp</h4>
        <p class="cpp_code">#include "..\\SmallWindows\\SmallWindows.h"</p>
        <p class="cpp_code">#include "GameGrid.h"</p>
        <p class="cpp_code">#include "TetrisFigure.h"</p>
        <p class="cpp_code">#include "BrownFigure.h"</p><br>
        <p class="cpp_code">IntPair BrownFigure::HorizontalList[] = {IntPair(-1,0), IntPair(1,0), IntPair(2,0)}, </p>
        <p class="cpp_code_2t">BrownFigure::VerticalList[] = {IntPair(0,-1), IntPair(0,1), IntPair(0,2)};</p><br>
        <p class="cpp_code">BrownFigure::BrownFigure(Window* windowPtr, GameGrid* gameGridPtr) </p>
        <p class="cpp_code_1t">:TetrisFigure(windowPtr, gameGridPtr, Brown, 1, (Cols / 2) - 1, </p>
        <p class="cpp_code_5t">North, HorizontalList, VerticalList, HorizontalList, VerticalList) {</p>
        <p class="cpp_code_2t">// Empty.</p>
        <p class="cpp_code">}</p>
        <h3>Бирюзовая фигура</h3>
        <p>Подобно коричневой фигуре, бирюзовую фигуру можно вращать по вертикали и горизонтали. направление, как показано на следующем рисунке: </p>
        <img src="03_01_04.png" alt="" class="img-center">
        <h4>TurquoiseFigure.h</h4>
        <p class="cpp_code">class TurquoiseFigure : public TetrisFigure {</p>
        <p class="cpp_code_1t">public:</p>
        <p class="cpp_code_2t">static IntPair HorizontalList[], VerticalList[];</p>
        <p class="cpp_code_2t">TurquoiseFigure(Window* windowPtr, GameGrid* gameGridPtr);</p>
        <p class="cpp_code">};</p>
        <h4>TurquoiseFigure cpp</h4>
        <p class="cpp_code">#include "..\\SmallWindows\\SmallWindows.h"</p>
        <p class="cpp_code">#include "GameGrid.h"</p>
        <p class="cpp_code">#include "TetrisFigure.h"</p>
        <p class="cpp_code">#include "TurquoiseFigure.h"</p><br>
        <p class="cpp_code">IntPair TurquoiseFigure::HorizontalList[] = {IntPair(-1,0), IntPair(0,1), IntPair(1,1)}, </p>
        <p class="cpp_code_2t">TurquoiseFigure::VerticalList[] = {IntPair(1,-1), IntPair(1,0), IntPair(0,1)};</p><br>
        <p class="cpp_code">TurquoiseFigure::TurquoiseFigure(Window* windowPtr, GameGrid* gameGridPtr)</p>
        <p class="cpp_code_1t">:TetrisFigure(windowPtr, gameGridPtr, Turquoise, 1, (Cols/2) - 1, </p>
        <p class="cpp_code_3t">North, HorizontalList, VerticalList, HorizontalList, VerticalList) {</p>
        <p class="cpp_code_4t">// Empty.</p>
        <p class="cpp_code">}</p>
        <h3>Зеленая фигура </h3>
        <p>Зеленая фигура зеркально отражена по отношению к бирюзовой фигуре, как показано ниже: </p>
        <img src="03_01_05.png" alt="" class="img-center">
        <h4>GreenFigure.h</h4>
        <p class="cpp_code">class GreenFigure : public TetrisFigure {</p>
        <p class="cpp_code_1t">public:</p>
        <p class="cpp_code_2t">static IntPair HorizontalList[], VerticalList[];</p>
        <p class="cpp_code_2t">GreenFigure(Window* windowPtr, GameGrid* gameGridPtr);</p>
        <p class="cpp_code">};</p>
        <h4>GreenFigure.cpp</h4>
        <p class="cpp_code">#include "..\\SmallWindows\\SmallWindows.h"</p>
        <p class="cpp_code">#include "GameGrid.h"</p>
        <p class="cpp_code">#include "TetrisFigure.h"</p>
        <p class="cpp_code">#include "GreenFigure.h"</p><br>
        <p class="cpp_code">IntPair GreenFigure::HorizontalList[] = {IntPair(1,-1), IntPair(0,-1), IntPair(-1,0)}, </p>
        <p class="cpp_code_2t">GreenFigure::VerticalList[] = {IntPair(0,-1), IntPair(1,0), IntPair(1,1)};</p><br>
        <p class="cpp_code">GreenFigure::GreenFigure(Window* windowPtr, GameGrid* gameGridPtr) </p>
        <p class="cpp_code_1t">:TetrisFigure(windowPtr, gameGridPtr, Green, 1, Cols / 2, North, </p>
        <p class="cpp_code_3t">HorizontalList, VerticalList, HorizontalList, VerticalList) {</p>
        <p class="cpp_code_4t">// Empty.</p>
        <p class="cpp_code">}</p>
        <h3>Желтая фигура</h3>
        <p>Желтую фигуру можно вращать в северном, восточном, южном и западном направлениях. Он инициализируется юг, как показано на следующем рисунке: </p>
        <img src="03_01_06.png" alt="" class="img-center">
        <h4>YellowFigure.h</h4>
        <p class="cpp_code">class YellowFigure : public TetrisFigure {</p>
        <p class="cpp_code_1t">public:</p>
        <p class="cpp_code_2t">static IntPair NorthList[], EastList[], SouthList[], WestList[];</p>
        <p class="cpp_code_2t">YellowFigure(Window* windowPtr, GameGrid* gameGridPtr);</p>
        <p class="cpp_code">};</p>
        <h4>YellowFigure.cpp</h4>
        <p class="cpp_code">#include "..\\SmallWindows\\SmallWindows.h"</p>
        <p class="cpp_code">#include "GameGrid.h"</p>
        <p class="cpp_code">#include "TetrisFigure.h"</p>
        <p class="cpp_code">#include "YellowFigure.h"</p><br>
        <p class="cpp_code">IntPair YellowFigure::NorthList[] = {IntPair(0,-1), IntPair(-1,0), IntPair(0,1)},</p>
        <p class="cpp_code_2t">YellowFigure::EastList[] = {IntPair(-1,0),IntPair(0,1),IntPair(1,0)},</p>
        <p class="cpp_code_2t">YellowFigure::SouthList[] = {IntPair(0,-1),IntPair(1,0),IntPair(0,1)},</p>
        <p class="cpp_code_2t">YellowFigure::WestList[] = {IntPair(-1,0),IntPair(0,-1),IntPair(1,0)};</p>
        <p class="cpp_code_2t">YellowFigure::YellowFigure(Window* windowPtr, GameGrid* gameGridPtr)</p>
        <p class="cpp_code_3t">:TetrisFigure(windowPtr, gameGridPtr, Yellow, 1, (Cols / 2) - 1, </p>
        <p class="cpp_code_5t">South, NorthList, EastList, SouthList, WestList) {</p>
        <p class="cpp_code_4t">// Empty.</p>
        <p class="cpp_code">}</p>
        <h3>Синяя фигура</h3>
        <p>Синяя фигура также может быть направлена во все четыре направления. Он инициализируется на юг, так как показано на следующем рисунке: </p>
        <img src="03_01_07.png" alt="" class="img-center">
        <h4>BlueFigure.h</h4>
        <p class="cpp_code">class BlueFigure : public TetrisFigure {</p>
        <p class="cpp_code_1t">public:</p>
        <p class="cpp_code_2t">static IntPair NorthList[], EastList[], SouthList[], WestList[];</p>
        <p class="cpp_code_2t">BlueFigure(Window* windowPtr, GameGrid* gameGridPtr);</p>
        <p class="cpp_code">};</p>
        <h4>BlueFigure.cpp</h4>
        <p class="cpp_code">#include "..\\SmallWindows\\SmallWindows.h"</p>
        <p class="cpp_code">#include "GameGrid.h"</p>
        <p class="cpp_code">#include "TetrisFigure.h"</p>
        <p class="cpp_code">#include "BlueFigure.h"</p><br>
        <p class="cpp_code">IntPair BlueFigure::NorthList[] = {IntPair(0,-2),IntPair(0,-1),IntPair(-1,0)},</p>
        <p class="cpp_code_2t">BlueFigure::EastList[] = {IntPair(-2,0), IntPair(-1,0), IntPair(0,1)},</p>
        <p class="cpp_code_2t">BlueFigure::SouthList[] = {IntPair(1,0), IntPair(0,1), IntPair(0,2)},</p>
        <p class="cpp_code_2t">BlueFigure::WestList[] = {IntPair(0,-1), IntPair(1,0), IntPair(2,0)};</p><br>
        <p class="cpp_code">BlueFigure::BlueFigure(Window* windowPtr, GameGrid* gameGridPtr)</p>
        <p class="cpp_code_2t">:TetrisFigure(windowPtr, gameGridPtr, Blue, 1, (Cols / 2) - 1, </p>
        <p class="cpp_code_5t">South, NorthList, EastList, SouthList, WestList) {</p>
        <p class="cpp_code_2t">// Empty.</p>
        <p class="cpp_code">}</p>
        <h3>Фиолетовая фигура </h3>
        <p>Наконец, фиолетовая фигура зеркально отображается относительно синей фигуры, а также инициализируется юг, как показано на следующем изображении: </p>
        <img src="03_01_08.png" alt="" class="img-center">
        <h4>PurpleFigure.h</h4>
        <p class="cpp_code">class PurpleFigure : public TetrisFigure {</p>
        <p class="cpp_code_1t">public:</p>
        <p class="cpp_code_2t">static IntPair NorthList[], EastList[], SouthList[], WestList[];</p>
        <p class="cpp_code_2t">PurpleFigure(Window* windowPtr, GameGrid* gameGridPtr);</p>
        <p class="cpp_code">};</p>
        <h4>PurpleFigure.cpp</h4>
        <p class="cpp_code">#include "..\\SmallWindows\\SmallWindows.h"</p>
        <p class="cpp_code">#include "GameGrid.h"</p>
        <p class="cpp_code">#include "TetrisFigure.h"</p>
        <p class="cpp_code">#include "PurpleFigure.h"</p><br>
        <p class="cpp_code">IntPair PurpleFigure::NorthList[] = {IntPair(-1,0),IntPair(0,1),IntPair(0,2)},</p>
        <p class="cpp_code_2t">PurpleFigure::EastList[] = {IntPair(1,0), IntPair(2,0), IntPair(0,1)},</p>
        <p class="cpp_code_2t">PurpleFigure::SouthList[] = {IntPair(0,-2),IntPair(0,-1),IntPair(1,0)},</p>
        <p class="cpp_code_2t">PurpleFigure::WestList[] = {IntPair(0,-1),IntPair(-2,0),IntPair(-1,0)};</p><br>
        <p class="cpp_code">PurpleFigure::PurpleFigure(Window* windowPtr, GameGrid* gameGridPtr)</p>
        <p class="cpp_code_2t">:TetrisFigure(windowPtr, gameGridPtr, Purple, 1, Cols / 2, South,</p>
        <p class="cpp_code_5t">NorthList, EastList, SouthList, WestList) {</p>
        <p class="cpp_code_2t">// Empty.</p>
        <p class="cpp_code">}</p>
        <h3>Класс GameGrid</h3>
        <p>Наконец, класс GameGrid довольно прост. Он отслеживает квадраты на игровом поле. Поле gridArea - это часть общей клиентской области, которая занята сеткой: </p>
        <h4>GameGrid.h</h4>
        <p class="cpp_code">const int Rows = 20, Cols = 10;</p><br>
        <p class="cpp_code">class GameGrid {</p>
        <p class="cpp_code_1t">public:</p>
        <p class="cpp_code_2t">GameGrid(Rect gridArea);</p>
        <p class="cpp_code_2t">void ClearGameGrid();</p><br>
        <p class="cpp_code_2t">Color* operator[](int row) {return gameGrid[row];}</p>
        <p class="cpp_code_2t">void InvalidateSquare(Window* windowPtr, int row, int col, Size offsetSize);</p>
        <p class="cpp_code_2t">void DrawGameGrid(Graphics& graphics, bool inverse) const;</p>
        <p class="cpp_code_2t">void DrawSquare(Graphics& graphics, int row, int col,</p>
        <p class="cpp_code_5t">Color penColor, Color brushColor, Size offsetSize = ZeroSize) const;</p>
        <p class="cpp_code_2t">Rect GridArea() const {return gridArea;}</p>
        <p class="cpp_code_1t">private:</p>
        <p class="cpp_code_2t">Rect gridArea;</p>
        <p class="cpp_code_2t">Color gameGrid[Rows][Cols];</p>
        <p class="cpp_code">};</p>
        <p>При вызове конструктором TetrisWindow область сетки будет установлена в (0, 20, 100, 100) единиц, поместив его в нижние 80 процентов клиентской области окна: </p>
        <h4>GameGrid.cpp</h4>
        <p class="cpp_code">#include "..\\SmallWindows\\SmallWindows.h"</p>
        <p class="cpp_code">#include "GameGrid.h"</p><br>
        <p class="cpp_code">GameGrid::GameGrid(Rect gridArea):gridArea(gridArea) {</p>
        <p class="cpp_code_1t">ClearGameGrid();</p>
        <p class="cpp_code">}</p>
        <p>При очистке сетки мы фактически устанавливаем белый цвет для каждого квадрата: </p>
        <p class="cpp_code">void GameGrid::ClearGameGrid () {</p>
        <p class="cpp_code_1t">for (int row = 0; row &lt; Rows; ++row) {</p>
        <p class="cpp_code_2t">for (int col = 0; col &lt; Cols; ++col) {</p>
        <p class="cpp_code_3t">gameGrid[row][col] = White;</p>
        <p class="cpp_code_2t">}</p>
        <p class="cpp_code_1t">}</p>
        <p class="cpp_code">}</p>
        <h3>Признание недействительными и рисование квадратов </h3>
        <p>DrawGameGrid выполняет итерацию по квадратам сетки. Белые квадраты окружены белой рамкой, а квадраты любого другого цвета - черной рамкой. Если Параметр inverseColor имеет значение true, цвет квадрата перед отрисовкой инвертируется. Это полезно
            при прошивке строк: </p>
        <p class="cpp_code">void GameGrid::DrawGameGrid(Graphics& graphics, bool inverse) const {</p>
        <p class="cpp_code_1t">for (int row = 0; row &lt; Rows; ++row) {</p>
        <p class="cpp_code_2t">for (int col = 0; col &lt; Cols; ++col) {</p>
        <p class="cpp_code_3t">Color squareColor = gameGrid[row][col];</p>
        <p class="cpp_code_3t">Color penColor = (squareColor == White) ? White : Black;</p>
        <p class="cpp_code_3t">Color brushColor = inverse ? squareColor.Inverse() : squareColor;</p>
        <p class="cpp_code_3t">DrawSquare(graphics, row, col, penColor, brushColor);</p>
        <p class="cpp_code_2t">}</p>
        <p class="cpp_code_1t">}</p>
        <p class="cpp_code">}</p>
        <p>Обратите внимание, что методы InvalidateSquare и DrawSquare добавляют смещение. Это ноль во всех случаев, кроме случаев, когда недействителен или отрисовывается следующая фигура в классе TetrisWindow. Обе методы вычисляют размер строк и столбцов
            сетки и определяют площадь квадрат аннулирован или нарисован: </p>
        <p class="cpp_code">void GameGrid::InvalidateSquare(Window* windowPtr, int row, int col, Size offsetSize) {</p>
        <p class="cpp_code_1t">int colWidth = gridArea.Width() / Cols, rowHeight = gridArea.Height() / Rows;</p>
        <p class="cpp_code_1t">Rect squareArea(col * colWidth, row * rowHeight, (col + 1) * colWidth, (row + 1) * rowHeight);</p>
        <p class="cpp_code_1t">windowPtr->Invalidate(gridArea.TopLeft() + squareArea + offsetSize);</p>
        <p class="cpp_code">}</p><br>
        <p class="cpp_code">void GameGrid::DrawSquare(Graphics& graphics, int row, int col, Color penColor, </p>
        <p class="cpp_code_5t">Color brushColor, Size offsetSize /* = ZeroSize */) const{</p>
        <p class="cpp_code_1t">int colWidth = gridArea.Width() / Cols, rowHeight = gridArea.Height() / Rows;</p>
        <p class="cpp_code_1t">Rect squareArea (col * colWidth, row * rowHeight, (col + 1) * colWidth, (row + 1) * rowHeight);</p>
        <p class="cpp_code_1t">graphics.FillRectangle(gridArea.TopLeft() + squareArea + offsetSize, penColor, brushColor);</p>
        <p class="cpp_code">}</p>
        <h3>Резюме</h3>
        <p>В этой главе мы разработали игру Тетрис. Вы изучили тайминг и рандомизацию, поскольку а также новую систему координат, более продвинутый рисунок, как улавливать события клавиатуры, и как писать текст.</p>
        <p>В главе 4, Работа с фигурами и фигурами, мы разработаем программу рисования, способную рисования линий, стрелок, прямоугольников и эллипсов. </p>
        <p><a href="./04_01.html">Глава 4. Работа с фигурами и цифрами&rArr;</a></p>
    </div>
</body>