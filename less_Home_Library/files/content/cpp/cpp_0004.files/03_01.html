<head>
    <link rel="stylesheet" href="../../../css/books_style.css">
</head>

<body>
    <div>
        <p><a href="./02_02.html">&lArr;Глава 2. Приложение "Круг"</a></p>
        <h1>ГЛАВА 3</h1>
        <h2>Создание приложения "Тетрис"</h2>
        <hr>
        <p>В этой главе мы разрабатываем классический тетрис. Мы смотрим дальше в класс Window, включая написание текста и рисование более сложных фигур. Мы также смотрим на сроки, случайные числа и графические обновления, такие как падающие фигуры и эффекты
            вспышки. Иллюстрация показана ниже: </p>
        <img src="03_01_01.png" alt="" class="img-center">
        <h3>Функция MainWindow</h3>
        <p>Функция MainWindow аналогична методам из главы 2, Hello, Small World !. Он устанавливает имя приложения и возвращает указатель на главное окно, которое в данном случае является экземпляр класса TetrisWindow. Как сказано в главе 2 «Привет, маленький
            мир!» то имя приложения используется при доступе к реестру, при открытии или сохранении файла, а также пункт меню «О программе». Однако ни одна из этих функций не используется в этом приложении: </p>
        <h4>MainWindow.cpp</h4>
        <p class="cpp_code">#include "..\\SmallWindows\\SmallWindows.h"</p>
        <p class="cpp_code">#include "GameGrid.h"</p>
        <p class="cpp_code">#include "TetrisFigure.h"</p>
        <p class="cpp_code">#include "RedFigure.h"</p>
        <p class="cpp_code">#include "BrownFigure.h"</p>
        <p class="cpp_code">#include "TurquoiseFigure.h"</p>
        <p class="cpp_code">#include "GreenFigure.h"</p>
        <p class="cpp_code">#include "YellowFigure.h"</p>
        <p class="cpp_code">#include "BlueFigure.h"</p>
        <p class="cpp_code">#include "PurpleFigure.h"</p>
        <p class="cpp_code">#include "TetrisWindow.h"</p><br>
        <p class="cpp_code">void MainWindow(vector &lt;String&gt; /* argumentList */, WindowShow windowShow) {</p>
        <p class="cpp_code_1t">Application::ApplicationName() = TEXT("Tetris");</p>
        <p class="cpp_code_1t">Application::MainWindowPtr() = new TetrisWindow(windowShow);</p>
        <p class="cpp_code">}</p>
        <h3>Окно тетриса</h3>
        <p>В этом приложении мы не используем структуру StandardDocument из Главы 2, Привет, маленький мир !. Вместо этого класс TetrisWindow расширяет корневой класс Small Windows. Окно прямо. Причина в том, что нам не нужна функциональность Платформа StandardDocument
            или ее базовый класс Document. Мы не используем меню или ускорители, и мы не сохраняем и не загружаем файлы: </p>
        <h4>TetrisWindow.h</h4>
        <p class="cpp_code">class TetrisWindow : public Window {</p>
        <p class="cpp_code_1t">public:</p>
        <p class="cpp_code_2t">TetrisWindow(WindowShow windowShow);</p>
        <p class="cpp_code_2t">~TetrisWindow();</p>
        <p>В этом приложении мы игнорируем мышь. Вместо этого мы рассмотрим работу с клавиатурой. В Метод OnKeyDown вызывается, когда пользователь нажимает или отпускает клавишу: </p>
        <p class="cpp_code_2t">bool OnKeyDown(WORD key, bool shiftPressed, bool controlPressed);</p>
        <p>Подобно круглому приложению, метод OnDraw вызывается каждый раз, когда клиент окна область нужно перерисовать: </p>
        <p class="cpp_code_2t">void OnDraw(Graphics& graphics, DrawMode drawMode) const;</p>
        <p>Методы OnGainFocus и OnLoseFocus вызываются, когда окно получает или теряет фокус ввода соответственно. Когда окно теряет фокус ввода, оно не получает никаких ввод с клавиатуры и таймер отключается, предотвращая перемещение падающей фигуры: </p>
        <p class="cpp_code_2t">void OnGainFocus();</p>
        <p class="cpp_code_2t">void OnLoseFocus();</p>
        <p>Метод OnTimer вызывается каждую секунду, когда окно находится в фокусе. Он пытается переместить падающая фигура на один шаг вниз. Он вызывает метод NewFigure, если не удается переместить фигура вниз. Метод NewFigure пытается представить новую
            фигуру в игре доска. Если это не удается, вызывается метод GameOver, который спрашивает пользователя, хочет ли он новый игра. Метод NewGame вызывается, если пользователь хочет новую игру. Если пользователь не хотите новую игру, выходит из
            приложения: </p>
        <p class="cpp_code_2t">void OnTimer(int timerId);</p>
        <p class="cpp_code_2t">void EndOfFigure();</p>
        <p class="cpp_code_2t">void GameOver();</p>
        <p class="cpp_code_2t">void NewGame();</p>
        <p>DeleteFullRows проверяет каждую строку, вызывая метод IsRowFull, и вызывает Методы FlashRow и DeleteRow для каждой полной строки: </p>
        <p class="cpp_code_2t">void DeleteFullRows();</p>
        <p class="cpp_code_2t">bool IsRowFull(int row);</p>
        <p class="cpp_code_2t">void FlashRow(int row);</p>
        <p class="cpp_code_2t">void DeleteRow(int markedRow);</p>
        <p>Метод TryClose вызывается, если пользователь пытается закрыть окно, щелкнув значок крестик в правом верхнем углу окна. Он отображает окно сообщения, которое спрашивает пользователя, если они действительно хотят бросить курить: </p>
        <p class="cpp_code_2t">bool TryClose();</p>
        <p>Поле gameGrid содержит сетку, на которой отображаются фигуры (см. Следующий раздел). Падающая фигура (падающая фигура) падает на сетку, а следующая фигура падает down (nextFigure) отображается в правом верхнем углу. Каждый раз, когда игрок заполняет
            строку, оценка (currScore) увеличивается. Идентификатор таймера (TimerId) необходим для отслеживания таймер и получает произвольное значение 1000. Наконец, список фигур (figureList) будет быть заполненным семью фигурами, по одной каждого цвета.
            Каждый раз, когда требуется новая фигура, случайным образом выбранная фигура из списка будет выбрана и скопирована: </p>
        <p class="cpp_code_1t">private:</p>
        <p class="cpp_code_2t">GameGrid gameGrid;</p>
        <p class="cpp_code_2t">TetrisFigure fallingFigure, nextFigure;</p><br>
        <p class="cpp_code_2t">int currScore = 0;</p>
        <p class="cpp_code_2t">bool timerActive = true, inverse = false;</p><br>
        <p class="cpp_code_2t">static const int TimerId = 1000;</p>
        <p class="cpp_code_2t">vector&lt;TetrisFigure&gt; figureList;</p>
        <p class="cpp_code">};</p>
        <p>Параметр PreviewCoordinate в вызове конструктора Window указывает, что размер окна фиксированный, а второй параметр указывает, что размер составляет 100 * 100 единиц. Это означает, что, в отличие от приложения круга, размер фигур и игровых полей
            будет изменить, когда пользователь изменяет размер окна: </p>
        <h4>TetrisWindow.cpp</h4>
        <p class="cpp_code">#include "..\\SmallWindows\\SmallWindows.h"</p>
        <p class="cpp_code">#include "GameGrid.h"</p>
        <p class="cpp_code">#include "TetrisFigure.h"</p>
        <p class="cpp_code">#include "RedFigure.h"</p>
        <p class="cpp_code">#include "BrownFigure.h"</p>
        <p class="cpp_code">#include "TurquoiseFigure.h"</p>
        <p class="cpp_code">#include "GreenFigure.h"</p>
        <p class="cpp_code">#include "YellowFigure.h"</p>
        <p class="cpp_code">#include "BlueFigure.h"</p>
        <p class="cpp_code">#include "PurpleFigure.h"</p>
        <p class="cpp_code">#include "TetrisWindow.h"</p><br>
        <p class="cpp_code">TetrisWindow::TetrisWindow(WindowShow windowShow)</p>
        <p class="cpp_code_3t">:Window(PreviewCoordinate, Rect(0, 0, 100, 100),</p>
        <p class="cpp_code_5t">nullptr, OverlappedWindow, NoStyle, Normal),</p>
        <p>Верхние 20 процентов клиентской области зарезервированы для оценки и следующей цифры. А игровая сетка покрывает нижние 80 процентов клиентской области (от 20 до 100 единиц высоты): </p>
        <p class="cpp_code_5t">gameGrid(Rect(0, 20, 100, 100)) {</p>
        <p>Поскольку мы расширяем класс Window, нам нужно установить заголовок окна вручную: </p>
        <p class="cpp_code_1t">SetHeader(TEXT("Tetris"));</p>
        <p>Интервал таймера установлен на 1000 миллисекунд, что означает, что будет вызываться OnTimer. каждую секунду. Генератор случайных чисел инициализируется вызовом стандартных функций языка Си. srand и время: </p>
        <p class="cpp_code_1t">SetTimer(TimerId, 1000);</p>
        <p class="cpp_code_1t">srand((unsigned int) time(nullptr));</p>
        <p>Список фигур инициализируется одной фигурой каждого цвета; падающая и следующая фигура случайно выбранный из этого списка. Одна из фигур в списке будет копироваться каждый раз, когда мы нужна новая фигура: </p>
        <p class="cpp_code_1t">figureList.push_back(RedFigure(this, &gameGrid));</p>
        <p class="cpp_code_1t">figureList.push_back(BrownFigure(this, &gameGrid));</p>
        <p class="cpp_code_1t">figureList.push_back(TurquoiseFigure(this, &gameGrid));</p>
        <p class="cpp_code_1t">figureList.push_back(GreenFigure(this, &gameGrid));</p>
        <p class="cpp_code_1t">figureList.push_back(YellowFigure(this, &gameGrid));</p>
        <p class="cpp_code_1t">figureList.push_back(BlueFigure(this, &gameGrid));</p>
        <p class="cpp_code_1t">figureList.push_back(PurpleFigure(this, &gameGrid));</p><br>
        <p class="cpp_code_1t">fallingFigure = figureList[rand() % figureList.size()];</p>
        <p class="cpp_code_1t">nextFigure = figureList[rand() % figureList.size()];</p>
        <p class="cpp_code">}</p>
        <p>Строго говоря, не обязательно сбрасывать таймер при закрытии окна Тетриса. В деструктор включен только для полноты: </p>
        <p class="cpp_code">TetrisWindow::~TetrisWindow() {</p>
        <p class="cpp_code_1t">DropTimer(TimerId);</p>
        <p class="cpp_code">}</p>
        <h3>Ввод с клавиатуры </h3>
        <p>Метод OnKeyDown переопределяет метод в классе Window и вызывается каждый раз. пользователь нажимает клавишу. Падающую фигуру стараемся перемещать в соответствии с нажатой клавишей. Нам все равно, нажал ли пользователь клавишу Shift или Ctrl: </p>
        <p class="cpp_code">bool TetrisWindow::OnKeyDown(WORD key, bool /* shiftPressed */,</p>
        <p class="cpp_code_5t">bool /* controlPressed */) {</p>
        <p class="cpp_code_1t">switch (key) {</p>
        <p class="cpp_code_2t">case KeyLeft:</p>
        <p class="cpp_code_3t">fallingFigure.TryMoveLeft();</p>
        <p class="cpp_code_3t">break;</p>
        <p class="cpp_code_2t">case KeyRight:</p>
        <p class="cpp_code_3t">fallingFigure.TryMoveRight();</p>
        <p class="cpp_code_3t">break;</p>
        <p class="cpp_code_2t">case KeyUp:</p>
        <p class="cpp_code_3t">fallingFigure.TryRotateAnticlockwise();</p>
        <p class="cpp_code_3t">break;</p>
        <p class="cpp_code_2t">case KeyDown:</p>
        <p class="cpp_code_3t">fallingFigure.TryRotateAnticlockwise();</p>
        <p class="cpp_code_3t">break;</p>
        <p>Когда пользователь нажимает клавишу пробела, падающая фигура падает с видимой скоростью, создавая иллюзия падения. Мы пытаемся перемещать падающую фигуру на один шаг вниз каждые 10 миллисекунд на вызов функции Win32 API Sleep. Метод TryMoveDown
            возвращает false, если он больше невозможно переместить фигуру вниз: </p>
        <p class="cpp_code_2t">case KeySpace:</p>
        <p class="cpp_code_3t">while (fallingFigure.TryMoveDown()) {</p>
        <p class="cpp_code_4t">::Sleep(10);</p>
        <p class="cpp_code_3t">}</p>
        <p class="cpp_code_3t">break;</p>
        <p class="cpp_code_1t">}</p>
        <p class="cpp_code_1t">return true;</p>
        <p class="cpp_code">}</p>
        <h3>Рисование</h3>
        <p>Метод OnDraw начинается с рисования игровой сетки и двух линий, разделяющих клиентскую область. на три части. В верхнем левом углу отображается текущий счет, в правом верхнем углу отображается следующий рисунок, а в нижней части отображается фактическая
            игровая сетка: </p>
        <p class="cpp_code">void TetrisWindow::OnDraw(Graphics& graphics,</p>
        <p class="cpp_code_5t"> DrawMode /* drawMode */) const {</p>
        <p class="cpp_code_1t">gameGrid.DrawGameGrid(graphics, inverse);</p>
        <p class="cpp_code_1t">graphics.FillRectangle(Rect(Point(0, 0), Point(100,20)), White, White);</p>
        <p class="cpp_code_1t">graphics.DrawLine(Point(40, 0), Point(40, 20), Black);</p>
        <p class="cpp_code_1t">graphics.DrawLine(Point(0, 20), Point(100, 20), Black);</p>
        <p>Обратите внимание, что мы добавляем смещение при рисовании следующей фигуры, чтобы выйти из игры. сетку в верхний правый угол. Значение 25 перемещает фигуру из середины сетки в середину его правой половины, а значение -18 перемещается из сетки
            вверх в область, предшествующую сетки: </p>
        <p class="cpp_code_1t">fallingFigure.DrawFigure(graphics);</p>
        <p class="cpp_code_1t">nextFigure.DrawFigure(graphics, Size(25, -18));</p>
        <p>Шрифт партитуры установлен на Times New Roman, размер 10. Здесь размер не относится к типографские точки, но до логических единиц. Поскольку в вызове конструктора Window указано, что мы дал систему координат PreviewCoordinate и размер 100 * 100,
            высоту text будет 10 единиц, что составляет десятую часть высоты текстовой клиентской области. Это тоже половина высоты части клиентской области, где написана оценка: </p>
        <p class="cpp_code_1t">Font scoreFont(TEXT("Times New Roman"), 10);</p>
        <p>Последний параметр false в вызове метода DrawText указывает, что размер текст не будет пересчитан. В следующих главах мы будем отображать текст, сохраняющий тот же размер, независимо от размера окна и разрешения экрана. Однако в этой главе размер
            текста будет изменен, когда пользователь изменит размер окна: </p>
        <p class="cpp_code_1t">graphics.DrawText(Rect(0, 0, 40, 20), to_String(currScore), </p>
        <p class="cpp_code_5t">scoreFont, Black, White, false);</p>
        <p class="cpp_code">}</p>
        <h3>Фокус ввода</h3>
        <p>Методы OnGainFocus и OnLoseFocus запускают и останавливают таймер соответственно, чтобы падающая фигура не падает, когда окно не в фокусе: </p>
        <p class="cpp_code">void TetrisWindow::OnGainFocus() {</p>
        <p class="cpp_code_1t">SetTimer(TimerId, 1000);</p>
        <p class="cpp_code">}</p><br>
        <p class="cpp_code">void TetrisWindow::OnLoseFocus() {</p>
        <p class="cpp_code_1t">DropTimer(TimerId);</p>
        <p class="cpp_code">}</p>
        <h3>Таймер</h3>
        <p>Таймер активен, когда он находится в фокусе ввода. Когда он активен, метод TryMoveDown будет вызываться каждый раз при вызове метода OnTimer (раз в секунду). Когда фигура больше не может упасть (метод TryMoveDown возвращает false), EndOfFigure
            метод называется: </p>
        <p class="cpp_code">void TetrisWindow::OnTimer(int /* timerId */) {</p>
        <p class="cpp_code_1t">if (timerActive) {</p>
        <p class="cpp_code_2t">if (!fallingFigure.TryMoveDown()) {</p>
        <p class="cpp_code_3t">EndOfFigure();</p>
        <p class="cpp_code_2t">}</p>
        <p class="cpp_code_1t">}</p>
        <p class="cpp_code">}</p>
        <h3>Новые фигуры</h3>
        <p>Когда падающая фигура не может двигаться вниз, метод OnTimer вызывает метод NewFigure. Во-первых, нам нужно сохранить падающую фигуру в игровой сетке, вызвав метод AddToGrid. Затем мы позволяем следующей фигуре стать новой падающей фигурой, и
            мы случайным образом выбрать новую следующую фигуру из списка фигур. Мы аннулируем площадь новая падающая фигура и область правого верхнего угла, где нарисована следующая фигура: </p>
        <p class="cpp_code">void TetrisWindow::NewFigure() {</p>
        <p class="cpp_code_1t">fallingFigure.AddToGrid();</p>
        <p class="cpp_code_1t">fallingFigure = nextFigure;</p>
        <p class="cpp_code_1t">fallingFigure.InvalidateFigure();</p>
        <p class="cpp_code_1t">nextFigure = figureList[rand() % figureList.size()];</p>
        <p class="cpp_code_1t">Rect nextArea(40, 0, 100, 20);</p>
        <p class="cpp_code_1t">Invalidate(nextArea);</p>
        <p class="cpp_code_1t">UpdateWindow();</p>
        <p>Удаляем возможные полные строки и обновляем окно: </p>
        <p class="cpp_code_1t">DeleteFullRows();</p>
        <p class="cpp_code_1t">UpdateWindow();</p>
        <p>Если новая падающая фигура не действительна с самого начала, игра окончена и GameOver называется: </p>
        <p class="cpp_code_1t">if (!fallingFigure.IsFigureValid()) {</p>
        <p class="cpp_code_2t">GameOver();</p>
        <p class="cpp_code_1t">}</p>
        <p class="cpp_code">}</p>
        <h3>Игра окончена</h3>
        <p>Метод GameOver представляет счет и позволяет пользователю решить, хочет ли он новый игра. Если они хотят новую игру, она инициализируется вызовом NewGame. Если пользователь не хотите новую игру, вызов функции Win32 API PostQuitMessage завершает
            оформление заявки.</p>
        <p>Обратите внимание, что мы вызываем другую версию метода Invalidate без параметров. Это делает недействительной всю клиентскую область: </p>
        <p class="cpp_code">void TetrisWindow::GameOver() {</p>
        <p class="cpp_code_1t">Invalidate();</p>
        <p class="cpp_code_1t">UpdateWindow();</p>
        <p>Таймер неактивен, пока отображается сообщение: </p>
        <p class="cpp_code_1t">timerActive = false;</p>
        <p class="cpp_code_1t">String message = TEXT("Game Over.\nYou scored ") +</p>
        <p class="cpp_code_5t">to_String(currScore) + </p>
        <p class="cpp_code_5t">TEXT(" points.\nAnother game?");</p>
        <p class="cpp_code_1t">if (MessageBox(message, TEXT("Tetris"), YesNo, Question)==Yes) {</p>
        <p class="cpp_code_2t">NewGame();</p>
        <p class="cpp_code_1t">}</p>
        <p class="cpp_code_1t">else {</p>
        <p class="cpp_code_2t">::PostQuitMessage(0);</p>
        <p class="cpp_code_1t">}</p>
        <p class="cpp_code">}</p>
        <h3>Новая игра</h3>
        <p>Метод NewGame инициализирует случайно выбранные новые падающие и следующие фигуры, сбрасывает счет и очищает игровую сетку перед активацией таймера, а также делает недействительными и обновляет окно, в результате чего новая падающая фигура начинает
            падать, а новая игра начать: </p>
        <p class="cpp_code">void TetrisWindow::NewGame() {</p>
        <p class="cpp_code_1t">fallingFigure = figureList[rand() % figureList.size()];</p>
        <p class="cpp_code_1t">nextFigure = figureList[rand() % figureList.size()];</p><br>
        <p class="cpp_code_1t">currScore = 0;</p>
        <p class="cpp_code_1t">gameGrid.ClearGameGrid();</p>
        <p class="cpp_code_1t">timerActive = true;</p>
        <p class="cpp_code_1t">Invalidate();</p>
        <p class="cpp_code_1t">UpdateWindow();</p>
        <p class="cpp_code">}</p>
        <h3>Удаление и мигание строк</h3>
        <p>При удалении полных строк мы перебираем строки, мигая и удаляя каждую полную строку. Увеличиваем оценку и обновляем площадь строки. Обратите внимание, что строки начинаются сверху сетки. Это означает, что мы должны пройти цикл от самой высокой
            строки к самой низкой строке, чтобы удалите строку в правильном порядке.</p>
        <p>Обратите внимание: если строка мигает и удаляется, мы не обновляем переменную строки, так как удаленная строка будет заменена на строку выше, которую также необходимо изучить: </p>
        <p class="cpp_code">void TetrisWindow::DeleteFullRows() {</p>
        <p class="cpp_code_1t">int row = Rows - 1;</p>
        <p class="cpp_code_1t">while (row >= 0) {</p>
        <p class="cpp_code_2t">if (IsRowFull(row)) {</p>
        <p class="cpp_code_3t">FlashRow(row);</p>
        <p class="cpp_code_3t">DeleteRow(row);</p><br>
        <p class="cpp_code_3t">++currScore;</p>
        <p class="cpp_code_3t">Rect scoreArea(0, 0, 40, 20);</p>
        <p class="cpp_code_3t">Invalidate(scoreArea);</p>
        <p class="cpp_code_3t">UpdateWindow();</p>
        <p class="cpp_code_2t">}</p>
        <p class="cpp_code_2t">else {</p>
        <p class="cpp_code_3t">--row;</p>
        <p class="cpp_code_2t">}</p>
        <p class="cpp_code_1t">}</p>
        <p class="cpp_code">}</p>
        <p>Строка считается полной, если в ней нет белого квадрата: </p>
        <p class="cpp_code">bool TetrisWindow::IsRowFull(int row) {</p>
        <p class="cpp_code_1t">for (int col = 0; col &lt; Cols; ++col) {</p>
        <p class="cpp_code_2t">if (gameGrid[row][col] == White) {</p>
        <p class="cpp_code_3t">return false;</p>
        <p class="cpp_code_2t">}</p>
        <p class="cpp_code_1t">}</p>
        <p class="cpp_code_1t">return true;</p>
        <p class="cpp_code">}</p>
        <p>Эффект вспышки выполняется путем перерисовки строки в нормальном и инвертированном цвете ( установлен обратный метод) трижды с интервалом 50 миллисекунд. При этом он особенно важно, чтобы мы аннулировали только область выбранной строки. В противном
            случае вся клиентская область окна будет мигать: </p>
        <p class="cpp_code">void TetrisWindow::FlashRow(int row) {</p>
        <p class="cpp_code_1t">Rect gridArea = gameGrid.GridArea();</p>
        <p class="cpp_code_1t">int colWidth = gridArea.Width() / Cols, rowHeight = gridArea.Height() / Rows;</p>
        <p class="cpp_code_1t">Rect rowArea(0, row * rowHeight, Cols * colWidth, (row + 1) * rowHeight);</p><br>
        <p class="cpp_code_1t">for (int count = 0; count &lt; 3; ++count) {</p>
        <p class="cpp_code_2t">inverse = true;</p>
        <p class="cpp_code_2t">Invalidate(rowArea + gridArea.Top()Left());</p>
        <p class="cpp_code_2t">UpdateWindow();</p>
        <p class="cpp_code_2t">::Sleep(50);</p><br>
        <p class="cpp_code_2t">inverse = false;</p>
        <p class="cpp_code_2t">Invalidate(rowArea + gridArea.Top()Left());</p>
        <p class="cpp_code_2t">UpdateWindow();</p>
        <p class="cpp_code_2t">::Sleep(50);</p>
        <p class="cpp_code_1t">}</p>
        <p class="cpp_code">}</p>
        <p>При удалении строки мы ее не удаляем. Вместо этого мы перемещаем каждую строку над удалите строку на один шаг вниз и заполните верхнюю строку белыми квадратами. Осложнение что мы считаем строки сверху. Это делает нижнюю строку на экране строкой
            с самый высокий индекс. Создается впечатление, что мы начинаем снизу и удаляем все полный ряд, пока не дойдем до вершины: </p>
        <p class="cpp_code">void TetrisWindow::DeleteRow(int markedRow) {</p>
        <p class="cpp_code_1t">for (int row = markedRow; row &gt; 0; --row) {</p>
        <p class="cpp_code_2t">for (int col = 0; col &lt; Cols; ++col) {</p>
        <p class="cpp_code_3t">gameGrid[row][col] = gameGrid[row - 1][col];</p>
        <p class="cpp_code_2t">}</p>
        <p class="cpp_code_1t">}</p>
        <p class="cpp_code_1t">for (int col = 0; col &lt; Cols; ++col) {</p>
        <p class="cpp_code_2t">gameGrid[0][col] = White;</p>
        <p class="cpp_code_1t">}</p>
        <p class="cpp_code_1t">Invalidate(gameGrid.GridArea());</p>
        <p class="cpp_code_1t">Invalidate(g);</p>
        <p class="cpp_code_1t">UpdateWindow();</p>
        <p class="cpp_code">}</p>
        <h3>Закрытие окна</h3>
        <p class="cpp_code_2t"></p>
        <p class="cpp_code_2t"></p>
        <p class="cpp_code_2t"></p>
        <p class="cpp_code_2t"></p>
        <p class="cpp_code_2t"></p>
        <p class="cpp_code_2t"></p>
        <p class="cpp_code_2t"></p>
        <p class="cpp_code_2t"></p>
        <p class="cpp_code_2t"></p>
        <p class="cpp_code_2t"></p>
        <p class="cpp_code_2t"></p>
        <p></p>
        <p><a href="./03_01.html">Глава 3. &rArr;</a></p>
    </div>
</body>