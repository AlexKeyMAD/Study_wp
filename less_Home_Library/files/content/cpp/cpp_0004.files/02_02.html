<head>
    <link rel="stylesheet" href="../../../css/books_style.css">
</head>

<body>
    <div>
        <p><a href="./01_02.html">&lArr;Глава 2. Привет, маленький мир!</a></p>
        <h1>ГЛАВА 2</h1>
        <h2>Приложение "Круг"</h2>
        <hr>
        <p>В этом разделе мы рассмотрим простое круговое приложение. Как следует из названия, он позволяет пользователь для обработки кругов в графическом приложении. Пользователь может добавить новый круг, нажав левая кнопка мыши. Пользователь также может
            перемещать существующий круг, перетаскивая его. Более того, пользователь может изменить цвет круга, а также сохранить и открыть документ: </p>
        <img src="02_02_01.png" alt="" class="img-center">
        <h3>Главное окно</h3>
        <p>Как мы увидим в этой книге, функция MainWindow всегда делает одно и то же: он устанавливает имя приложения и создает главное окно приложения. Имя используется стандартными диалоговыми окнами «Сохранить» и «Открыть», пунктом меню «О программе»
            и реестром.</p>
        <p>Отличие главного окна от других окон приложения в том, что когда пользователь закрывает главное окно, приложение закрывается. Более того, когда пользователь выбирает пункт меню Exit, главное окно закрывается и вызывается его деструктор: </p>
        <h4>MainWindow.cpp</h4>
        <p class="cpp_code">#include "..\\SmallWindows\\SmallWindows.h"</p>
        <p class="cpp_code">#include "Circle.h"</p>
        <p class="cpp_code">#include "CircleDocument.h"</p>
        <p class="cpp_code">void MainWindow(vector &lt;String&gt; /* argumentList */, WindowShow windowShow) {</p>
        <p class="cpp_code_1t">Application::ApplicationName() = TEXT("Circle");</p>
        <p class="cpp_code_1t">Application::MainWindowPtr() = new CircleDocument(windowShow);</p>
        <p class="cpp_code">}</p>
        <h3>Класс CircleDocument</h3>
        <p>Класс CircleDocument расширяет класс Small Windows StandardDocument, который, в свою очередь, расширяет классы Document и Window. Фактически, класс StandardDocument представляет собой фреймворк, то есть базовый класс с набором виртуальных методов
            с функциональностью что мы можем переопределить и дополнительно указать.</p>
        <p>Методы OnMouseDown и OnMouseUp переопределяются из класса Window и являются вызывается, когда пользователь нажимает или отпускает одну из кнопок мыши. OnMouseMove метод вызывается, когда пользователь перемещает мышь. Метод OnDraw также переопределяется
            из класса Window и вызывается каждый раз, когда окно необходимо перерисовать.</p>
        <p>ClearDocument, ReadDocumentFromStream и WriteDocumentToStream методы переопределяются из класса StandardDocument и вызываются, когда пользователь создает новый файл, открывает файл или сохраняет файл: </p>
        <h4>CircleDocument.h</h4>
        <p class="cpp_code">class CircleDocument : public StandardDocument {</p>
        <p class="cpp_code_1t">public:</p>
        <p class="cpp_code_2t">CircleDocument(WindowShow windowShow);</p>
        <p class="cpp_code_2t">~CircleDocument();</p>
        <p class="cpp_code_2t">void OnMouseDown(MouseButton mouseButtons, Point mousePoint,</p>
        <p class="cpp_code_5t">bool shiftPressed, bool controlPressed);</p>
        <p class="cpp_code_2t">void OnMouseUp(MouseButton mouseButtons, Point mousePoint,</p>
        <p class="cpp_code_5t">bool shiftPressed, bool controlPressed);</p>
        <p class="cpp_code_2t">void OnMouseMove(MouseButton mouseButtons, Point mousePoint,</p>
        <p class="cpp_code_5t">bool shiftPressed, bool controlPressed);</p>
        <p class="cpp_code_2t">void OnDraw(Graphics& graphics, DrawMode drawMode) const;</p>
        <p class="cpp_code_2t">bool ReadDocumentFromStream(String name, istream& inStream);</p>
        <p class="cpp_code_2t">bool WriteDocumentToStream(String name, ostream& outStream) const;</p>
        <p class="cpp_code_2t">void ClearDocument();</p>
        <p>Макросы DEFINE_BOOL_LISTENER и DEFINE_VOID_LISTENER определяют слушателей, которые - это методы без параметров, которые вызываются, когда пользователь выбирает пункт меню. Единственный Разница между макросами заключается в типе возвращаемого значения
            определенных методов: bool или void.</p>
        <p>В приложениях этой книги мы используем общий стандарт, согласно которому слушатели вызывают реакция на действия пользователя имеет префикс On, например OnRed, как показано ниже. фрагмент кода. Методы, которые решают, следует ли включать пункт
            меню: с суффиксом Enable, и методы, которые решают, должен ли пункт меню быть отмеченные галочкой или радиокнопкой, имеют суффикс Check или Radio.</p>
        <p>В следующем приложении мы определяем пункты меню для красного, зеленого и синего цветов. Мы также определите пункт меню для стандартного диалога цвета: </p>
        <p class="cpp_code_2t">DEFINE_VOID_LISTENER(CircleDocument,OnRed);</p>
        <p class="cpp_code_2t">DEFINE_VOID_LISTENER(CircleDocument,OnGreen);</p>
        <p class="cpp_code_2t">DEFINE_VOID_LISTENER(CircleDocument,OnBlue);</p>
        <p class="cpp_code_2t">DEFINE_VOID_LISTENER(CircleDocument,OnColorDialog);</p>
        <p>Когда пользователь выбрал один из цветов, красный, зеленый или синий, соответствующее меню элемент отмечен переключателем. RedRadio, GreenRadio и BlueRadio параметры вызываются до того, как пункты меню становятся видимыми и возвращают логическое
            значение указывает, должен ли пункт меню быть отмечен переключателем: </p>
        <p class="cpp_code_2t">DEFINE_BOOL_LISTENER(CircleDocument, RedRadio);</p>
        <p class="cpp_code_2t">DEFINE_BOOL_LISTENER(CircleDocument, GreenRadio);</p>
        <p class="cpp_code_2t">DEFINE_BOOL_LISTENER(CircleDocument, BlueRadio);</p>
        <p>Радиус круга всегда составляет 500 единиц, что соответствует 5 мм: </p>
        <p class="cpp_code_2t">static const int CircleRadius = 500;</p>
        <p>Поле circleList содержит круги, причем самый верхний круг находится в начале. списка. Поле nextColor содержит цвет следующего круга, который будет добавлен пользователем. Это инициализируется минус 0ne, чтобы указать, что вначале круг не перемещается.
            В Поля moveIndex и movePoint используются OnMouseDown и OnMouseMove. методы, позволяющие отслеживать перемещение круга пользователем: </p>
        <p class="cpp_code_1t">private:</p>
        <p class="cpp_code_2t">vector&lt;Circle&gt; circleList;</p>
        <p class="cpp_code_2t">Color nextColor;</p>
        <p class="cpp_code_2t">int moveIndex = -1;</p>
        <p class="cpp_code_2t">Point movePoint;</p>
        <p class="cpp_code">};</p>
        <p>В вызове конструктора StandardDocument первые два параметра: LogicalWithScroll и USLetterPortrait. Они указывают, что логический размер сотые доли миллиметра и что клиентская область вмещает логический размер американской буквы: 215,9 * 279,4
            миллиметра (8,5 * 11 дюймов). Если размер окна изменить так, чтобы клиентская область становится меньше буквы США, в окно добавляются полосы прокрутки.</p>
        <p>Третий параметр устанавливает информацию о файле, используемую стандартными диалогами сохранения и открытия; текстовое описание имеет значение Circle Files, а суффикс файла - cle. Nullptr Параметр указывает, что у окна нет родительского окна.
            В Параметр константы OverlappedWindow указывает, что окно должно перекрывать другие windows, а параметр windowShow - это исходный внешний вид окна, передаваемый в из окружающей системы классом MainWindow: </p>
        <h4>CircleDocument.cpp</h4>
        <p class="cpp_code">#include "..\\SmallWindows\\SmallWindows.h"</p>
        <p class="cpp_code">#include "Circle.h"</p>
        <p class="cpp_code">#include "CircleDocument.h"</p><br>
        <p class="cpp_code">CircleDocument::CircleDocument(WindowShow windowShow):StandardDocument(LogicalWithScroll,</p>
        <p class="cpp_code_5t">USLetterPortrait,TEXT("Circle Files, cle"),</p>
        <p class="cpp_code_5t">nullptr,OverlappedWindow, windowShow) {</p>
        <p>Класс StandardDocument добавляет в окно стандартные меню File, Edit и Help. строка меню. В меню «Файл» находятся пункты «Создать», «Открыть», «Сохранить», «Сохранить как», «Параметры страницы», «Предварительный просмотр» и Выйти из пунктов. Параметры
            страницы и предварительный просмотр не являются обязательными. Седьмой параметр Конструктор StandardDocument (значение по умолчанию - false) указывает на их наличие. В В меню «Правка» находятся пункты «Вырезать», «Копировать», «Вставить» и
            «Удалить». По умолчанию они отключены; мы не будет использовать их в этом приложении. В меню «Справка» есть элемент «О программе», а имя приложения, установленное в MainWindow, используется для отображения окна сообщения со стандартным сообщение
            Circle, версия 1.0.</p>
        <p>Мы добавляем в строку меню стандартные меню File и Edit. Затем мы добавляем Цветное меню, которое является меню этого приложения для конкретного приложения. Наконец, добавляем стандартный Справочное меню и установите строку меню документа. </p>
        <p>В меню «Цвет» находятся пункты меню, используемые для установки цвета круга. OnRed, OnGreen, и OnBlue методы вызываются, когда пользователь выбирает пункт меню, а RedRadio, Методы GreenRadio и BlueRadio вызываются до того, как пользователь выберет
            меню Color в чтобы решить, следует ли отмечать элементы с помощью переключателя. OnColorDialog открывает стандартный диалог цвета.</p>
        <p>В тексте & Red\tCtrl+R в следующем фрагменте кода амперсанд (&) указывает, что в пункте меню есть мнемоника; то есть буква R будет подчеркнута, и можно выберите пункт меню, нажав R после того, как меню было открыто. Персонаж табулятора (\t) указывает,
            что вторая часть текста определяет ускоритель; то есть текст Ctrl + R появится в пункте меню с выравниванием по правому краю, и этот элемент можно выбрать, нажав Ctrl + R: </p>
        <p class="cpp_code_1t">Menu menuBar(this);</p>
        <p>Параметр false для StandardFileMenu указывает, что мы не хотим включать пункты меню файла. </p>
        <p class="cpp_code_1t">menuBar.AddMenu(StandardFileMenu(false));</p>
        <p>Метод AddItem в классе Menu также принимает еще два параметра для включения пункт меню и установка флажка. Однако мы не используем их в этом приложении. Поэтому отправляем нулевые указатели: </p>
        <p class="cpp_code_1t">Menu colorMenu(this, TEXT("&Color"));</p>
        <p class="cpp_code_1t">colorMenu.AddItem(TEXT("&Red\tCtrl+R"), OnRed, nullptr, nullptr, RedRadio);</p>
        <p class="cpp_code_1t">colorMenu.AddItem(TEXT("&Green\tCtrl+G"), OnGreen, nullptr, nullptr, GreenRadio);</p>
        <p class="cpp_code_1t">colorMenu.AddItem(TEXT("&Blue\tCtrl+B"), OnBlue, nullptr, nullptr, BlueRadio);</p>
        <p class="cpp_code_1t">colorMenu.AddSeparator();</p>
        <p class="cpp_code_1t">colorMenu.AddItem(TEXT("&Dialog ..."), OnColorDialog);</p>
        <p class="cpp_code_1t">menuBar.AddMenu(colorMenu);</p><br>
        <p class="cpp_code_1t">menuBar.AddMenu(StandardHelpMenu());</p>
        <p class="cpp_code_1t">SetMenuBar(menuBar);</p>
        <p>Наконец, мы считываем текущий цвет (цвет следующего добавляемого круга) из реестра; красный - это цвет по умолчанию, если в реестре нет цвета: </p>
        <p class="cpp_code_1t">nextColor.ReadColorFromRegistry(TEXT("NextColor"), Red);</p>
        <p class="cpp_code">}</p>
        <p>Деструктор сохраняет текущий цвет в реестре. В этом приложении нам не нужно выполнять обычные задачи деструктора, такие как освобождение памяти или закрытие файлов: </p>
        <p class="cpp_code">CircleDocument::~CircleDocument() {</p>
        <p class="cpp_code_1t">nextColor.WriteColorToRegistry(TEXT("NextColor"));</p>
        <p class="cpp_code">}</p>
        <p>Метод ClearDocument вызывается, когда пользователь выбирает пункт меню New. В этом В этом случае мы просто очищаем круговой список. Любое другое действие, такое как перерисовка окна или изменение его заголовка выполняется классом StandardDocument:</p>
        <p class="cpp_code">void CircleDocument::ClearDocument() {</p>
        <p class="cpp_code_1t">circleList.clear();</p>
        <p class="cpp_code">}</p>
        <p class="cpp_code_2t"></p>
        <p class="cpp_code_2t"></p>
        <p class="cpp_code_2t"></p>
        <p class="cpp_code_2t"></p>
        <p class="cpp_code_2t"></p>
        <p class="cpp_code_2t"></p>
        <p class="cpp_code_2t"></p>
        <p class="cpp_code_2t"></p>
        <p class="cpp_code_2t"></p>
        <p class="cpp_code_2t"></p>
        <p class="cpp_code_2t"></p>
        <p class="cpp_code_2t"></p>
        <p class="cpp_code_2t"></p>
        <p class="cpp_code_2t"></p>
        <p class="cpp_code_2t"></p>
        <p class="cpp_code_2t"></p>
        <p class="cpp_code_2t"></p>
        <p class="cpp_code_2t"></p>
        <p class="cpp_code_2t"></p>
        <p class="cpp_code_2t"></p>
        <p class="cpp_code_2t"></p>
        <p class="cpp_code_2t"></p>
        <p class="cpp_code_2t"></p>
        <p class="cpp_code_2t"></p>
        <p class="cpp_code_2t"></p>
        <p class="cpp_code_2t"></p>
        <p><a href="./02_02.html">Глава 2.&rArr;</a></p>
    </div>
</body>