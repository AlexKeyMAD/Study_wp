<head>
    <link rel="stylesheet" href="../../css/books_style.css">
    <link rel="stylesheet" href="../../css/codeblocks.css">
</head>

<body>
    <div class="book-title">
        <h1>Сборник вопросов с ответами</h1>
    </div>
    <div class="book-content">
        <div class="slide">
            <label for="slide-null_pointer">
                <h3>Null Pointers / Нулевые указатели</h3> 
            </label>
            <input type="checkbox" id="slide-null_pointer" />
            <div class="slide-text">
                <table class="table-td-left">
                    <tr>
                        <th id="table-num">#</th>
                        <th class="table-en-ru">English</th>
                        <th class="table-en-ru">Русский</th>
                    </tr>
                    <tr>
                        <td>
                            <h4>1</h4>
                        </td>
                        <td>
                            <h4>What is this infamous null pointer, anyway?</h4>
                        </td>
                        <td>
                            <h4>Что это за печально известный нулевой указатель?</h4>
                        </td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>
                            <p>The language definition states that for each pointer type, there is a special value--the "null pointer"--which is distinguishable from all other pointer values and which is "guaranteed to compare unequal to a pointer to any
                                object or function". That is, a null pointer points definitively nowhere; it is not the address of any object or function. The address-of operator & will never yield a null pointer, nor will a successful call to malloc.
                                (malloc does return a null pointer when it fails, and this is a typical use of null pointers: as a "special" pointer value with some other meaning, usually "not allocated" or "not pointing anywhere yet".)
                            </p>
                            <p>A null pointer is conceptually different from an uninitialized pointer. A null pointer is known not to point to any object or function; an uninitialized pointer might point anywhere.</p>
                            <p>As mentioned above, there is a null pointer for each pointer type, and the internal values of null pointers for different types may be different. Although programmers need not know the internal values, the compiler must always
                                be informed which type of null pointer is required, so that it can make the distinction if necessary.</p>
                        </td>
                        <td>
                            <p>В определении языка говорится, что для каждого типа указателя существует специальное значение - "нулевой указатель" - которое можно отличить от всех других значений указателя и которое "гарантированно сравнивает неравное с
                                указателем на любой объект или функцию". То есть, нулевой указатель нигде не указывает; это не адрес какого-либо объекта или функции. Оператор address-of & никогда не выдаст нулевой указатель, как и успешный вызов malloc.
                                (malloc действительно возвращает нулевой указатель в случае сбоя, и это типичное использование нулевых указателей: в качестве "специального" значение указателя с некоторым другим значением, обычно "не выделено" или "еще
                                нигде не указывает".)</p>
                            <p>Нулевой указатель концептуально отличается от неинициализированного указателя. Известно, что нулевой указатель не указывает на какой-либо объект или функцию; неинициализированный указатель может указывать куда угодно.</p>
                            <p>Как упомянуто выше, для каждого типа указателя существует нулевой указатель, и внутренние значения нулевых указателей для разных типов могут быть разными. Хотя программистам не нужно знать внутренние значения, компилятор всегда
                                должен быть информирован о том, какой тип нулевого указателя требуется, чтобы он мог провести различие при необходимости.</p>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <h4>2</h4>
                        </td>
                        <td>
                            <h4>How do I get a null pointer in my programs?</h4>
                        </td>
                        <td>
                            <h4>Как получить нулевой указатель в моих программах?</h4>
                        </td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>
                            <p>According to the language definition, an "integral constant expression with the value 0" in a pointer context is converted into a null pointer at compile time. That is, in an initialization, assignment, or comparison when one
                                side is a variable or expression of pointer type, the compiler can tell that a constant 0 on the other side requests a null pointer, and generate the correctly-typed null pointer value. Therefore, the following fragments
                                are perfectly legal:
                            </p>
                            <p>char *p = 0;</p>
                            <p>if(p != 0)</p>
                            <p>(See also question 3.)</p>
                            <p>However, an argument being passed to a function is not necessarily recognizable as a pointer context, and the compiler may not be able to tell that an unadorned 0 ``means'' a null pointer. To generate a null pointer in a function
                                call context, an explicit cast may be required, to force the 0 to be recognized as a pointer. For example, the Unix system call execl takes a variable-length, null-pointer-terminated list of character pointer arguments,
                                and is correctly called like this:</p>
                            <p>execl("/bin/sh", "sh", "-c", "date", (char *)0);</p>
                            <p>If the (char *) cast on the last argument were omitted, the compiler would not know to pass a null pointer, and would pass an integer 0 instead. (Note that many Unix manuals get this example wrong; see also question 11.)
                            </p>
                            <p>When function prototypes are in scope, argument passing becomes an ``assignment context,'' and most casts may safely be omitted, since the prototype tells the compiler that a pointer is required, and of which type, enabling
                                it to correctly convert an unadorned 0. Function prototypes cannot provide the types for variable arguments in variable-length argument lists however, so explicit casts are still required for those arguments. It is probably
                                safest to properly cast all null pointer constants in function calls, to guard against varargs functions or those without prototypes.</p>
                        </td>
                        <td>
                            <p>Согласно определению языка, "целочисленное константное выражение со значением 0" в контексте указателя преобразуется в нулевой указатель во время компиляции. То есть при инициализации, присваивании или сравнении, когда одна
                                сторона является переменной или выражением типа указателя, компилятор может сказать, что константа 0 на другой стороне запрашивает нулевой указатель, и сгенерировать правильное значение нулевого указателя. Поэтому следующие
                                фрагменты абсолютно законны:</p>
                            <p>char *p = 0;</p>
                            <p>if(p != 0)</p>
                            <p>(См. вопрос 3.)</p>
                            <p>Однако аргумент, передаваемый в функцию, не обязательно распознается как контекст указателя, и компилятор может быть не в состоянии сказать, что неукрашенный 0 "означает" нулевой указатель. Чтобы сгенерировать нулевой указатель
                                в контексте вызова функции, может потребоваться явное приведение, чтобы заставить 0 быть распознанным как указатель. Например, системный вызов Unix execl принимает список аргументов указателей символов переменной длины,
                                заканчивающийся нулевым указателем, и корректно вызывается так:</p>
                            <p>execl("/bin/sh", "sh", "-c", "date", (char *)0);</p>
                            <p>Если бы (char *) приведение к последнему аргументу было опущено, компилятор не знал бы, чтобы передать нулевой указатель, и вместо этого передал бы целое число 0. (Обратите внимание, что во многих руководствах по Unix этот
                                пример неверен; см. Также вопрос 11.)</p>
                            <p>Когда прототипы функций находятся в области видимости, передача аргументов становится `` контекстом присваивания '', и большинство приведений может быть безопасно опущено, так как прототип сообщает компилятору, что указатель
                                необходим и какого типа, что позволяет ему правильно преобразовывать неукрашенные 0. Прототипы функций не могут предоставлять типы для переменных аргументов в списках аргументов переменной длины, поэтому для этих аргументов
                                все еще требуется явное приведение. Вероятно, наиболее безопасным является правильное приведение всех констант нулевого указателя в вызовах функций для защиты от функций varargs или функций без прототипов.
                            </p>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <h4>3</h4>
                        </td>
                        <td>
                            <h4>Is the abbreviated pointer comparison "if(p)" to test for non-null pointers valid? What if the internal representation for null pointers is nonzero?</h4>
                        </td>
                        <td>
                            <h4>Допустимо ли сокращенное сравнение указателей "if (p)" для проверки ненулевых указателей? Что если внутреннее представление для нулевых указателей отлично от нуля?</h4>
                        </td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>
                            <p>When C requires the Boolean value of an expression, a false value is inferred when the expression compares equal to zero, and a true value otherwise. That is, whenever one writes</p>
                            <p>if(expr)</p>
                            <p>where "expr" is any expression at all, the compiler essentially acts as if it had been written as</p>
                            <p>if((expr) != 0)</p>
                            <p>Substituting the trivial pointer expression "p" for "expr", we have</p>
                            <p>if(p) is equivalent to if(p != 0)</p>
                            <p>and this is a comparison context, so the compiler can tell that the (implicit) 0 is actually a null pointer constant, and use the correct null pointer value. There is no trickery involved here; compilers do work this way, and
                                generate identical code for both constructs. The internal representation of a null pointer does not matter.</p>
                            <p>The boolean negation operator, !, can be described as follows:</p>
                            <p>!expr is essentially equivalent to (expr)?0:1</p>
                            <p>or to ((expr) == 0)</p>
                            <p>which leads to the conclusion that</p>
                            <p>if(!p) is equivalent to if(p == 0)</p>
                        </td>
                        <td>
                            <p>Когда C требует логического значения выражения, ложное значение выводится, когда выражение сравнивается равным нулю, и истинное значение в противном случае. То есть всякий раз, когда кто-то пишет</p>
                            <p>if(expr)</p>
                            <p>где "expr" - любое выражение вообще, компилятор по существу действует так, как если бы он был записан как</p>
                            <p>if((expr) != 0)</p>
                            <p>Подставляя тривиальное выражение-указатель «p» вместо «expr», получим</p>
                            <p>if(p) эквивалентно if(p != 0)</p>
                            <p>и это контекст сравнения, поэтому компилятор может сказать, что (неявный) 0 на самом деле является константой нулевого указателя, и использовать правильное значение нулевого указателя. Здесь нет хитрости; компиляторы работают
                                таким образом и генерируют идентичный код для обеих конструкций. Внутреннее представление нулевого указателя не имеет значения.</p>
                            <p>Оператор логического отрицания (!) может быть описан следующим образом:</p>
                            <p>!expr по существу эквивалентно (expr)?0:1</p>
                            <p>или ((expr) == 0)</p>
                            <p>Что приводит к выводу, что</p>
                            <p>if(!p) эквивалентно if(p == 0)</p>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <h4>4</h4>
                        </td>
                        <td>
                            <h4>What is NULL and how is it defined?</h4>
                        </td>
                        <td>
                            <h4>Что такое NULL и как оно определяется?</h4>
                        </td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>
                            <p>As a matter of style, many programmers prefer not to have unadorned 0's scattered through their programs, some representing numbers and some representing pointers. Therefore, the preprocessor macro NULL is defined (by several
                                headers, including &lt;stdio.h&gt; and &lt;stddef.h&gt;) as a null pointer constant, typically 0 or ((void *)0) (see also question 5.6). A programmer who wishes to make explicit the distinction between 0 the integer and
                                0 the null pointer constant can then use NULL whenever a null pointer is required.</p>
                            <p>Using NULL is a stylistic convention only; the preprocessor turns NULL back into 0 which is then recognized by the compiler, in pointer contexts, as before. In particular, a cast may still be necessary before NULL (as before
                                0) in a function call argument. The table under question 2 above applies for NULL as well as 0 (an unadorned NULL is equivalent to an unadorned 0).</p>
                            <p>NULL should be used only as a pointer constant; see question 9</p>
                        </td>
                        <td>
                            <p>В качестве стиля многие программисты предпочитают не разбрасывать по своим программам неукрашенные нули, некоторые из которых представляют числа, а некоторые представляют указатели. Поэтому макрос препроцессора NULL определяется
                                (несколькими заголовками, включая &lt;stdio.h&gt; и &lt;stddef.h&gt;) как константа нулевого указателя, обычно 0 или ((void *) 0) (см. Также вопрос 5.6). Программист, желающий сделать явное различие между 0 целым числом
                                и 0 константой нулевого указателя, может затем использовать NULL всякий раз, когда требуется нулевой указатель.</p>
                            <p>Использование NULL является только стилистическим соглашением; препроцессор превращает NULL обратно в 0, который затем распознается компилятором в контексте указателя, как и раньше. В частности, приведение может быть необходимо
                                до NULL (как и до 0) в аргументе вызова функции. Таблица под вопросом 2 выше применяется как к NULL, так и к 0 (неукрашенный NULL эквивалентен неукрашенному 0).</p>
                            <p>NULL должен использоваться только как указатель константы; см вопрос 9</p>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <h4>5</h4>
                        </td>
                        <td>
                            <h4>How should NULL be defined on a machine which uses a nonzero bit pattern as the internal representation of a null pointer?</h4>
                        </td>
                        <td>
                            <h4>Как определить NULL на машине, которая использует ненулевой битовый шаблон как внутреннее представление нулевого указателя?</h4>
                        </td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>
                            <p>The same as on any other machine: as 0 (or some version of 0; see question 4).</p>
                            <p>Whenever a programmer requests a null pointer, either by writing "0" or "NULL", it is the compiler's responsibility to generate whatever bit pattern the machine uses for that null pointer. (Again, the compiler can tell that
                                an unadorned 0 requests a null pointer when the 0 is in a pointer context; see question 2.) Therefore, #defining NULL as 0 on a machine for which internal null pointers are nonzero is as valid as on any other: the compiler
                                must always be able to generate the machine's correct null pointers in response to unadorned 0's seen in pointer contexts. A constant 0 is a null pointer constant; NULL is just a convenient name for it (see also question
                                13).
                            </p>
                            <p>(Section 4.1.5 of the C Standard states that NULL "expands to an implementation-defined null pointer constant," which means that the implementation gets to choose which form of 0 to use and whether to use a void * cast; see
                                questions 6 and 7. "Implementation-defined" here does not mean that NULL might be #defined to match some implementation-specific nonzero internal null pointer value.)</p>
                            <p>See also questions 2, 10 and 17</p>
                        </td>
                        <td>
                            <p>То же, что и на любом другом компьютере: 0 (или некоторая версия 0; см. Вопрос 4).</p>
                            <p>Всякий раз, когда программист запрашивает нулевой указатель, записывая «0» или «NULL», компилятор несет ответственность за генерацию любого битового шаблона, который машина использует для этого нулевого указателя. (Опять же,
                                компилятор может сказать, что незакрашенный 0 запрашивает нулевой указатель, когда 0 находится в контексте указателя; см. Вопрос 2.) Следовательно, # определение NULL как 0 на машине, для которой внутренние нулевые указатели
                                отличны от нуля, так же верно, как на любом другом: компилятор должен всегда иметь возможность генерировать правильные нулевые указатели машины в ответ на неукрашенные 0, видимые в контекстах указателей. Константа 0 является
                                константой нулевого указателя; NULL - просто удобное название для него (см. Также вопрос 13).</p>
                            <p>(Раздел 4.1.5 Стандарта C гласит, что NULL «расширяется до определенной в реализации константы нулевого указателя», что означает, что реализация может выбирать, какую форму 0 использовать и использовать ли приведение типа void
                                *; см. Вопросы 6). и 7. «Определено реализацией» в данном случае не означает, что NULL может быть #defined, чтобы соответствовать некоторому значению, зависящему от реализации, от ненулевого значения внутреннего нулевого
                                указателя.)
                            </p>
                            <p>Смотрите также вопросы 2, 10 и 17</p>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <h4>6</h4>
                        </td>
                        <td>
                            <h4>If NULL were defined as follows:<span><br></span> #define NULL ((char *)0)<span><br></span> wouldn't that make function calls which pass an uncast NULL work?</h4>
                        </td>
                        <td>
                            <h4>Если NULL были определены следующим образом:<span><br></span> #define NULL ((char *)0)<span><br></span> не заставит ли это работать вызовы функций, которые передают uncast NULL?</h4>
                        </td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>
                            <p>Not in the most general case. The complication is that there are machines which use different internal representations for pointers to different types of data. The suggested definition would make uncast NULL arguments to functions
                                expecting pointers to characters work correctly, but pointer arguments of other types could still (in the absence of prototypes) require explicit casts. Furthermore, legal constructions such as</p>
                            <p>FILE *fp = NULL;</p>
                            <p>could fail.</p>
                            <p>Nevertheless, ANSI C allows the alternate definition</p>
                            <p>#define NULL ((void *)0)</p>
                            <p>for NULL. Besides potentially helping incorrect programs to work (but only on machines with homogeneous pointers, thus questionably valid assistance), this definition may catch programs which use NULL incorrectly (e.g. when
                                the ASCII NUL character was really intended; see question 9). See also question 7.</p>
                            <p>At any rate, ANSI function prototypes ensure that most (though not quite all; see question 2) pointer arguments are converted correctly when passed as function arguments, so the question is largely moot.</p>
                            <p>Programmers who are accustomed to modern, "flat" memory architectures may find the idea of "different kinds of pointers" very difficult to accept. See question 17 for some examples.</p>
                        </td>
                        <td>
                            <p>Не в самом общем случае. Сложность состоит в том, что существуют машины, которые используют разные внутренние представления для указателей на разные типы данных. Предложенное определение будет приводить к тому, что нерассчитанные
                                NULL-аргументы для функций, ожидающих, что указатели на символы будут работать правильно, но аргументы-указатели других типов все же могут (при отсутствии прототипов) требовать явного приведения. Кроме того, правовые конструкции,
                                такие как</p>
                            <p>FILE *fp = NULL;</p>
                            <p>может потерпеть неудачу.</p>
                            <p>Тем не менее, в ANSI C позволяет альтернативное определение</p>
                            <p>#define NULL ((void *)0)</p>
                            <p>для NULL. Помимо потенциальной помощи в работе некорректных программ (но только на машинах с однородными указателями, что, следовательно, сомнительно допустимая помощь), это определение может отлавливать программы, которые
                                используют NULL неправильно (например, когда символ ASCII NUL действительно был задуман; см. Вопрос 9). Смотрите также вопрос 7.</p>
                            <p>В любом случае, прототипы функций ANSI гарантируют, что большинство (хотя и не все; см. Вопрос 2) аргументы указателя будут правильно преобразованы при передаче в качестве аргументов функции, поэтому вопрос в значительной степени
                                спорный.
                            </p>
                            <p>Программистам, которые привыкли к современной «плоской» архитектуре памяти, может быть очень трудно принять идею «различных указателей». Смотрите вопрос 17 для некоторых примеров.</p>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <h4>7</h4>
                        </td>
                        <td>
                            <h4>My vendor provides header files that #define NULL as 0L. Why?</h4>
                        </td>
                        <td>
                            <h4>Мой поставщик предоставляет заголовочные файлы, которые #define NULL равны 0L. Зачем?</h4>
                        </td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>
                            <p>Some programs carelessly attempt to generate null pointers by using the NULL macro, without casts, in non-pointer contexts. (Doing so is not guaranteed to work; see questions 2 and 11.) On machines which have pointers larger
                                than integers (such as PC compatibles in "large" model; see also question 17), a particular definition of NULL such as 0L can help these incorrect programs to work. (0L is a perfectly valid definition of NULL; it is an
                                "integral constant expression with value 0.") Whether it is wise to coddle incorrect programs is debatable; see also question 6 and section 17.</p>
                        </td>
                        <td>
                            <p>Некоторые программы небрежно пытаются генерировать нулевые указатели с помощью макроса NULL без приведения в контекстах без указателей. (Это не гарантированно сработает; см. Вопросы 2 и 11.) На машинах, у которых указатели
                                больше целых чисел (например, совместимые с ПК в «большой» модели; см. Также вопрос 17), конкретное определение NULL, такое как 0L, может помогите этим некорректным программам работать. (0L это вполне допустимо определение
                                NULL, это «интегральное выражение постоянной со значением 0») Будь мудр нянчиться неправильных программ является спорным; см. также вопрос 6 и раздел 17.</p>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <h4>8</h4>
                        </td>
                        <td>
                            <h4>Is NULL valid for pointers to functions?</h4>
                        </td>
                        <td>
                            <h4>Допустимо ли значение NULL для указателей на функции?</h4>
                        </td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>
                            <p>Yes</p>
                        </td>
                        <td>
                            <p>Да</p>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <h4>9</h4>
                        </td>
                        <td>
                            <h4>If NULL and 0 are equivalent as null pointer constants, which should I use?</h4>
                        </td>
                        <td>
                            <h4>Если NULL и 0 эквивалентны как константы нулевого указателя, что я должен использовать?</h4>
                        </td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>
                            <p>Many programmers believe that NULL should be used in all pointer contexts, as a reminder that the value is to be thought of as a pointer. Others feel that the confusion surrounding NULL and 0 is only compounded by hiding 0
                                behind a macro, and prefer to use unadorned 0 instead.</p>
                            <p>There is no one right answer. C programmers must understand that NULL and 0 are interchangeable in pointer contexts, and that an uncast 0 is perfectly acceptable. Any usage of NULL (as opposed to 0) should be considered a gentle
                                reminder that a pointer is involved; programmers should not depend on it (either for their own understanding or the compiler's) for distinguishing pointer 0's from integer 0's.</p>
                            <p>It is only in pointer contexts that NULL and 0 are equivalent. NULL should not be used when another kind of 0 is required, even though it might work, because doing so sends the wrong stylistic message. (Furthermore, ANSI allows
                                the definition of NULL to be ((void *)0), which will not work at all in non-pointer contexts.) In particular, do not use NULL when the ASCII null character (NUL) is desired. Provide your own definition</p>
                            <p>#define NUL '\0'</p>
                            <p>if you must.</p>
                        </td>
                        <td>
                            <p>Многие программисты считают, что NULL следует использовать во всех контекстах указателя, как напоминание о том, что значение следует рассматривать как указатель. Другие считают, что путаница, связанная с NULL и 0, усугубляется
                                только скрытием 0 за макросом, и предпочитают вместо этого использовать неукрашенный 0.</p>
                            <p>Там нет ни одного правильного ответа. Программисты C должны понимать, что NULL и 0 являются взаимозаменяемыми в контексте указателя, и что uncast 0 вполне приемлем. Любое использование NULL (в отличие от 0) должно рассматриваться
                                как мягкое напоминание о том, что указатель задействован; программисты не должны зависеть от этого (ни для собственного понимания, ни для компилятора), чтобы отличать указатели 0 от целых 0.</p>
                            <p>Только в контекстах указателя NULL и 0 эквивалентны. NULL не следует использовать, когда требуется другой тип 0, даже если он может работать, потому что это отправляет неправильное стилистическое сообщение. (Кроме того, ANSI
                                позволяет определять значение NULL как ((void *) 0), что не будет работать вообще в контекстах без указателей.) В частности, не используйте NULL, когда требуется нулевой символ ASCII (NUL). Укажите свое собственное определение</p>
                            <p>#define NUL '\0'</p>
                            <p>если вы должны.</p>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <h4>10</h4>
                        </td>
                        <td>
                            <h4>But wouldn't it be better to use NULL (rather than 0), in case the value of NULL changes, perhaps on a machine with nonzero internal null pointers?</h4>
                        </td>
                        <td>
                            <h4>Но не лучше ли использовать NULL (а не 0), если значение NULL изменится, возможно, на машине с ненулевыми внутренними нулевыми указателями?</h4>
                        </td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>
                            <p>No. (Using NULL may be preferable, but not for this reason.) Although symbolic constants are often used in place of numbers because the numbers might change, this is not the reason that NULL is used in place of 0. Once again,
                                the language guarantees that source-code 0's (in pointer contexts) generate null pointers. NULL is used only as a stylistic convention. See questions 5</p>
                        </td>
                        <td>
                            <p>Нет. (Использование NULL может быть предпочтительным, но не по этой причине.) Хотя символические константы часто используются вместо чисел, потому что числа могут меняться, это не причина, по которой NULL используется вместо
                                0. Еще раз, язык гарантирует, что исходные коды 0 (в контексте указателя) генерируют нулевые указатели. NULL используется только как стилистическое соглашение. Смотрите вопросы 5</p>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <h4>11</h4>
                        </td>
                        <td>
                            <h4>I once used a compiler that wouldn't work unless NULL was used.</h4>
                        </td>
                        <td>
                            <h4>Однажды я использовал компилятор, который не работал бы, если не был использован NULL.</h4>
                        </td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>
                            <p>Unless the code being compiled was nonportable, that compiler was probably broken.</p>
                            <p>Perhaps the code used something like this nonportable version of an example from question 2:</p>
                            <p>execl("/bin/sh", "sh", "-c", "date", NULL); /* WRONG */</p>
                            <p>Under a compiler which defines NULL to ((void *)0) (see question 6), this code will happen to work. However, if pointers and integers have different sizes or representations, the (equally incorrect) code</p>
                            <p>execl("/bin/sh", "sh", "-c", "date", 0); /* WRONG */</p>
                            <p>may not work.</p>
                            <p>Correct, portable code uses an explicit cast:</p>
                            <p>execl("/bin/sh", "sh", "-c", "date", (char *)NULL);</p>
                            <p>With the cast, the code works correctly no matter what the machine's integer and pointer representations are, and no matter which form of null pointer constant the compiler has chosen as the definition of NULL. (The code fragment
                                in question 2, which used 0 instead of NULL, is equally correct; see also question 9.) (In general, making decisions about a language based on the behavior of one particular compiler is likely to be counterproductive.)</p>
                        </td>
                        <td>
                            <p>Если компилируемый код не был переносимым, этот компилятор, вероятно, был сломан.</p>
                            <p>Возможно, код использовал что-то вроде этой непереносимой версии примера из вопроса 2:</p>
                            <p>execl("/bin/sh", "sh", "-c", "date", NULL); /* WRONG */</p>
                            <p>В компиляторе, который определяет NULL для ((void *) 0) (см. Вопрос 6), этот код будет работать. Однако, если указатели и целые числа имеют разные размеры или представления, (одинаково неверный) код</p>
                            <p>execl("/bin/sh", "sh", "-c", "date", 0); /* WRONG */</p>
                            <p>может не работать.</p>
                            <p>Правильный, переносимый код использует явное приведение:</p>
                            <p>execl("/bin/sh", "sh", "-c", "date", (char *)NULL);</p>
                            <p>При приведении код работает правильно, независимо от того, каковы представления целого и указателя машины, и независимо от того, какую форму константы нулевого указателя компилятор выбрал в качестве определения NULL. (Фрагмент
                                кода в вопросе 2, который использовал 0 вместо NULL, одинаково корректен; см. Также вопрос 9.) (В общем, принятие решений о языке, основанном на поведении одного конкретного компилятора, может быть контрпродуктивным.)</p>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <h4>12</h4>
                        </td>
                        <td>
                            <h4>I use the preprocessor macro<span><br></span>#define Nullptr(type) (type *)0<span><br></span>to help me build null pointers of the correct type.</h4>
                        </td>
                        <td>
                            <h4>Я использую макрос препроцессора<span><br></span>#define Nullptr(type) (type *)0<span><br></span>чтобы помочь мне построить нулевые указатели правильного типа.</h4>
                        </td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>
                            <p>This trick, though popular and superficially attractive, does not buy much. It is not needed in assignments or comparisons; see question 2. (It does not even save keystrokes.)</p>
                        </td>
                        <td>
                            <p>Этот трюк, хотя и популярен и внешне привлекателен, мало что покупает. Это не нужно в заданиях или сравнениях; см. вопрос 2. (Он даже не сохраняет нажатия клавиш.)</p>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <h4>13</h4>
                        </td>
                        <td>
                            <h4>This is strange. NULL is guaranteed to be 0, but the null pointer is not?</h4>
                        </td>
                        <td>
                            <h4>Это странно. NULL гарантированно будет 0, но нулевой указатель - нет?</h4>
                        </td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>
                            <p>When the term "null" or "NULL" is casually used, one of several things may be meant:</p>
                            <ol>
                                <li>The conceptual null pointer, the abstract language concept defined in question 1. It is implemented with.</li>
                                <li>The internal (or run-time) representation of a null pointer, which may or may not be all-bits-0 and which may be different for different pointer types. The actual values should be of concern only to compiler writers. Authors
                                    of C programs never see them, since they use.</li>
                                <li>The null pointer constant, which is a constant integer 0 (see question 2). It is often hidden behind.</li>
                                <li>The NULL macro, which is #defined to be 0 (see question 4). Finally, as red herrings, we have.</li>
                                <li>The ASCII null character (NUL), which does have all bits zero, but has no necessary relation to the null pointer except in name;</li>
                                <li>The "null string", which is another name for the empty string (""). Using the term "null string" can be confusing in C, because an empty string involves a null ('\0') character, but not a null pointer, which brings us full
                                    circle.
                                </li>
                            </ol>
                            <p>In other words, to paraphrase the White Knight's description of his song in Through the Looking-Glass, the name of the null pointer is "0", but the name of the null pointer is called "NULL" (and we're not sure what the null
                                pointer is).</p>
                            <p>This document uses the phrase "null pointer" (in lower case) for sense 1, the token "0" or the phrase "null pointer constant" for sense 3, and the capitalized word "NULL" for sense 4.</p>
                        </td>
                        <td>
                            <p>Когда термин «ноль» или «NULL» используется случайно, может подразумеваться одна из нескольких вещей:</p>
                            <ol>
                                <li>Концептуальный нулевой указатель, абстрактная языковая концепция, определенная в вопросе 1. Он реализуется с помощью.</li>
                                <li>Внутреннее (или во время выполнения) представление нулевого указателя, который может быть или не быть all-bits-0 и который может отличаться для разных типов указателей. Фактические значения должны интересовать только авторов
                                    компиляторов. Авторы программ на Си никогда не видят их, так как они используют.</li>
                                <li>Константа нулевого указателя, которая является константой целого числа 0 (см. Вопрос 2). Это часто скрыто позади.</li>
                                <li>Макрос NULL, который #defined определен как 0 (см. Вопрос 4). Наконец-то, как красные селедки, у нас есть.</li>
                                <li>Нулевой символ ASCII (NUL), который имеет все биты ноль, но не имеет необходимого отношения к нулевому указателю, кроме имени;</li>
                                <li>"Нулевая строка", которая является другим именем для пустой строки (""). Использование термина «пустая строка» может привести к путанице в Си, потому что пустая строка содержит нулевой символ ('\ 0'), но не нулевой указатель,
                                    что приводит нас к полному кругу.</li>
                            </ol>
                            <p>Другими словами, чтобы перефразировать описание Белого Рыцаря своей песни в «Сквозном зеркале», имя нулевого указателя равно «0», но имя нулевого указателя называется «NULL» (и мы не уверены, что такое нулевой указатель).</p>
                            <p>В этом документе используется фраза «нулевой указатель» (в нижнем регистре) для смысла 1, токен «0» или фраза «константа нулевого указателя» для смысла 3 и заглавное слово «NULL» для смысла 4.</p>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <h4>14</h4>
                        </td>
                        <td>
                            <h4>Why is there so much confusion surrounding null pointers? Why do these questions come up so often?</h4>
                        </td>
                        <td>
                            <h4>Почему так много путаницы вокруг нулевых указателей? Почему эти вопросы возникают так часто?</h4>
                        </td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>
                            <p>C programmers traditionally like to know a lot (perhaps more than they need to) about the underlying machine implementation. The fact that null pointers are represented both in source code, and internally to most machines,
                                as zero invites unwarranted assumptions. The use of a preprocessor macro (NULL) may seem to suggest that the value could change some day, or on some weird machine. The construct "if(p == 0)" is easily misread as calling
                                for conversion of p to an integral type, rather than 0 to a pointer type, before the comparison. Finally, the distinction between the several uses of the term "null" (listed in question 13) is often overlooked.</p>
                            <p>One good way to wade out of the confusion is to imagine that C used a keyword (perhaps nil, like Pascal) as a null pointer constant. The compiler could either turn nil into the appropriate type of null pointer when it could
                                unambiguously determine that type from the source code, or complain when it could not. Now in fact, in C the keyword for a null pointer constant is not nil but 0, which works almost as well, except that an uncast 0 in a
                                non-pointer context generates an integer zero instead of an error message, and if that uncast 0 was supposed to be a null pointer constant, the resulting program may not work.</p>
                        </td>
                        <td>
                            <p>Программисты на С традиционно хотят знать много (возможно, больше, чем им нужно) о базовой реализации машины. Тот факт, что нулевые указатели представлены как в исходном коде, так и внутри большинства машин, как ноль, приводит
                                к необоснованным предположениям. Использование макроса препроцессора (NULL) может указывать на то, что значение может измениться когда-нибудь или на какой-то странной машине. Конструкция "if (p == 0)" легко неверно истолковывается
                                как вызов преобразования p в целочисленный тип, а не 0 в тип указателя, перед сравнением. Наконец, различие между несколькими употреблениями термина «ноль» (перечисленного в вопросе 13) часто упускается из виду.</p>
                            <p>Один хороший способ избежать путаницы - представить, что C использовал ключевое слово (возможно, nil, как Pascal) в качестве константы нулевого указателя. Компилятор может либо превратить ноль в соответствующий тип нулевого
                                указателя, когда он может однозначно определить этот тип из исходного кода, либо жаловаться, когда не может. Теперь фактически, в C ключевое слово для константы нулевого указателя не nil, а 0, что работает почти так же
                                хорошо, за исключением того, что uncast 0 в контексте без указателя генерирует целое ноль вместо сообщения об ошибке, и если это uncast 0 должен был быть нулевой константой указателя, результирующая программа может не работать.</p>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <h4>15</h4>
                        </td>
                        <td>
                            <h4>I'm confused. I just can't understand all this null pointer stuff.</h4>
                        </td>
                        <td>
                            <h4>Я запутался. Я просто не могу понять все эти вещи с нулевым указателем.</h4>
                        </td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>
                            <p>Here are two simple rules you can follow:</p>
                            <ol>
                                <li>When you want a null pointer constant in source code, use "0" or "NULL"</li>
                                <li>If the usage of "0" or "NULL" is an argument in a function call, cast it to the pointer type expected by the function being called.</li>
                            </ol>
                            <p>The rest of the discussion has to do with other people's misunderstandings, with the internal representation of null pointers (which you shouldn't need to know), and with the complexities of function prototypes. (Taking those
                                complexities into account, we find that rule 2 is conservative , of course; but it doesn't hurt.) Understand questions 1, 2, and 4, and consider 3, 9, 13, and 14, and you'll do fine.</p>
                        </td>
                        <td>
                            <p>Вот два простых правила, которым вы можете следовать:</p>
                            <ol>
                                <li>Если вы хотите, чтобы в исходном коде была константа нулевого указателя, используйте «0» или «NULL»</li>
                                <li>Если использование «0» или «NULL» является аргументом в вызове функции, приведите его к типу указателя, ожидаемому вызываемой функцией.</li>
                            </ol>
                            <p>Остальная часть обсуждения связана с недопониманием других людей, с внутренним представлением нулевых указателей (что вам не нужно знать), а также со сложностями прототипов функций. (Принимая во внимание эти сложности, мы находим,
                                что правило 2, конечно, консервативно; но это не повредит.) Поймите вопросы 1, 2 и 4, рассмотрите 3, 9, 13 и 14, и вы делать хорошо.</p>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <h4>16</h4>
                        </td>
                        <td>
                            <h4> Given all the confusion surrounding null pointers, wouldn't it be easier simply to require them to be represented internally by zeroes?</h4>
                        </td>
                        <td>
                            <h4>Учитывая всю путаницу, связанную с нулевыми указателями, не будет ли проще просто потребовать, чтобы они были представлены внутри нулями?</h4>
                        </td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>
                            <p>Some implementations naturally represent null pointers by special, nonzero bit patterns, particularly when it can be arranged that inadvertently using those values triggers automatic hardware traps. Requiring null pointers
                                to be represented internally as 0, and therefore disallowing use of the special, nonzero values, would be an unfortunate step backwards, because catching errors which result in invalid accesses is a Good Thing.</p>
                            <p>Besides, what would such a requirement really accomplish? Proper understanding of null pointers does not require knowledge of the internal representation, whether zero or nonzero. Assuming that null pointers are internally
                                zero does not make any code easier to write (except for a certain ill-advised usage of calloc;). Known-zero internal pointers would not reduce the need for casts in function calls, because the size of the pointer might
                                still be different from that of an int. (If "nil" were used to request null pointers, as mentioned in question 14, the urge to assume an internal zero representation would not even arise.)</p>
                        </td>
                        <td>
                            <p>Некоторые реализации, естественно, представляют нулевые указатели с помощью специальных ненулевых битовых комбинаций, особенно когда это может быть организовано так, что непреднамеренное использование этих значений вызывает
                                автоматическое аппаратное прерывание. Требование, чтобы нулевые указатели были внутренне представлены как 0, и, следовательно, запрещение использования специальных ненулевых значений, было бы неудачным шагом назад, потому
                                что перехват ошибок, которые приводят к недопустимым доступам, - это хорошо.</p>
                            <p>Кроме того, что на самом деле выполнит такое требование? Правильное понимание нулевых указателей не требует знания внутреннего представления, нулевого или ненулевого. Предположение, что нулевые указатели внутренне равны нулю,
                                не облегчает написание какого-либо кода (за исключением некоторого опрометчивого использования calloc;). Известные нулевые внутренние указатели не уменьшат необходимость приведения в вызовах функций, потому что размер указателя
                                все еще может отличаться от размера int. (Если бы «ноль» использовался для запроса нулевых указателей, как упомянуто в вопросе 14, желание предположить, что внутреннее нулевое представление не возникнет).</p>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <h4>17</h4>
                        </td>
                        <td>
                            <h4>Seriously, have any actual machines really used nonzero null pointers, or different representations for pointers to different types?</h4>
                        </td>
                        <td>
                            <h4>Серьезно, на каких-нибудь реальных машинах действительно используются ненулевые нулевые указатели или разные представления для указателей на разные типы?</h4>
                        </td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>
                            <p>The Prime 50 series used segment 07777, offset 0 for the null pointer, at least for PL/I. Later models used segment 0, offset 0 for null pointers in C, necessitating new instructions such as TCNP (Test C Null Pointer), evidently
                                as a sop to all the extant poorly-written C code which made incorrect assumptions. Older, word-addressed Prime machines were also notorious for requiring larger byte pointers (char *'s) than word pointers (int *'s).</p>
                            <p>The Eclipse MV series from Data General has three architecturally supported pointer formats (word, byte, and bit pointers), two of which are used by C compilers: byte pointers for char * and void *, and word pointers for everything
                                else. For historical reasons during the evolution of the 32-bit MV line from the 16-bit Nova line, word pointers and byte pointers had the offset, indirection, and ring protection bits in different places in the word. Passing
                                a mismatched pointer format to a function resulted in protection faults. Eventually, the MV C compiler added many compatibility options to try to deal with code that had pointer type mismatch errors.</p>
                            <p>Some Honeywell-Bull mainframes use the bit pattern 06000 for (internal) null pointers.</p>
                            <p>The CDC Cyber 180 Series has 48-bit pointers consisting of a ring, segment, and offset. Most users (in ring 11) have null pointers of 0xB00000000000. It was common on old CDC ones-complement machines to use an all-one-bits
                                word as a special flag for all kinds of data, including invalid addresses.</p>
                            <p>The old HP 3000 series uses a different addressing scheme for byte addresses than for word addresses; like several of the machines above it therefore uses different representations for char * and void * pointers than for other
                                pointers.
                            </p>
                            <p>The Symbolics Lisp Machine, a tagged architecture, does not even have conventional numeric pointers; it uses the pair &lt;NIL, 0&gt; (basically a nonexistent &lt;object, offset&gt; handle) as a C null pointer.</p>
                            <p>Depending on the "memory model" in use, 8086-family processors (PC compatibles) may use 16-bit data pointers and 32-bit function pointers, or vice versa.</p>
                            <p>Some 64-bit Cray machines represent int * in the lower 48 bits of a word; char * additionally uses some of the upper 16 bits to indicate a byte address within a word.</p>
                        </td>
                        <td>
                            <p>Серия Prime 50 использовала сегмент 07777, смещение 0 для нулевого указателя, по крайней мере для PL / I. Более поздние модели использовали сегмент 0 со смещением 0 для нулевых указателей в C, что требовало новых инструкций,
                                таких как TCNP (Test C Null Pointer), очевидно, в качестве дополнения ко всему существующему плохо написанному коду C, который делал неверные предположения. Старые машины Prime с адресацией на слова также были известны
                                тем, что требовали указателей большего размера (char *), чем указатели на слова (int *).</p>
                            <p>Серия Eclipse MV от Data General имеет три архитектурно поддерживаемых формата указателей (слово, байт и битовые указатели), два из которых используются компиляторами C: байтовые указатели для char * и void * и указатели слов
                                для всего остального. По историческим причинам во время эволюции 32-битной линии MV из 16-битной строки Nova указатели слов и указатели байтов имели биты смещения, косвенности и защиты кольца в разных местах слова. Передача
                                несоответствующего формата указателя в функцию привела к сбоям защиты. В конце концов, компилятор MV C добавил множество опций совместимости, чтобы попытаться справиться с кодом, в котором были ошибки несоответствия типов
                                указателей.
                            </p>
                            <p>Некоторые мэйнфреймы Honeywell-Bull используют битовую комбинацию 06000 для (внутренних) нулевых указателей.</p>
                            <p>Серия CDC Cyber 180 имеет 48-битные указатели, состоящие из кольца, сегмента и смещения. Большинство пользователей (в кольце 11) имеют нулевые указатели 0xB00000000000. На старых CDC-машинах с одним дополнением часто использовалось
                                слово «все-один-бит» в качестве специального флага для всех типов данных, включая недопустимые адреса.</p>
                            <p>Старая серия HP 3000 использует другую схему адресации для байтовых адресов, чем для адресных слов; как и несколько машин выше, он использует разные представления для указателей char * и void *, чем для других указателей.</p>
                            <p>Symbolis Lisp Machine, помеченная архитектура, даже не имеет обычных числовых указателей; он использует пару &lt;NIL, 0&gt; (в основном несуществующий дескриптор &lt;object, offset&gt;) в качестве нулевого указателя на Си.</p>
                            <p>В зависимости от используемой «модели памяти», процессоры семейства 8086 (совместимые с ПК) могут использовать 16-битные указатели данных и 32-битные функциональные указатели или наоборот.</p>
                            <p>Некоторые 64-битные машины Cray представляют int * в младших 48 битах слова; char * дополнительно использует некоторые из старших 16 битов для указания байтового адреса в слове.</p>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <h4>18</h4>
                        </td>
                        <td>
                            <h4>Is a run-time integral value of 0, cast to a pointer, guaranteed to be a null pointer?</h4>
                        </td>
                        <td>
                            <h4>Является ли целочисленное значение времени выполнения 0, приведенное к указателю, гарантированно равным нулевому указателю?</h4>
                        </td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>
                            <p>No. Only constant integral expressions with value 0 are guaranteed to indicate null pointers. See also questions 2, and 19.</p>
                        </td>
                        <td>
                            <p>Нет. Только постоянные интегральные выражения со значением 0 гарантированно указывают на нулевые указатели. Смотрите также вопросы 2 и 19.</p>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <h4>19</h4>
                        </td>
                        <td>
                            <h4>How can I access an interrupt vector located at the machine's location 0? If I set a pointer to 0, the compiler might translate it to some nonzero internal null pointer value.</h4>
                        </td>
                        <td>
                            <h4>Как я могу получить доступ к вектору прерываний, расположенному в местоположении машины 0? Если я установлю указатель на 0, компилятор может перевести его в ненулевое значение внутреннего нулевого указателя.</h4>
                        </td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>
                            <p>Since whatever is at location 0 is obviously machine dependent, you're free to use whatever machine-dependent trick will work to get there. Read your vendor's documentation (and see section 19). It's likely that if it's at
                                all meaningful for you to be accessing location 0, the system will be set up to make it reasonably easy to do so. Some possibilities are:</p>
                            <ol>
                                <li>Simply set a pointer to 0. (This is the way that doesn't have to work, but if it's meaningful, it probably will.)</li>
                                <li>Assign the integer 0 to an int variable, and convert that int to a pointer. (This is also not guaranteed to work, but it probably will.)</li>
                                <li>Use a union to set the bits of a pointer variable to 0:
                                    <span><br></span>union {<span><br></span>&nbsp;&nbsp;&nbsp;&nbsp;int *u_p;<span><br></span>&nbsp;&nbsp;&nbsp;&nbsp;int u_i; &nbsp;&nbsp;&nbsp;&nbsp;/* assumes sizeof(int) >= sizeof(int *) */<span><br></span>} p;<span><br></span>p.u_i
                                    = 0;</li>
                                <li>Use memset to set the bits of a pointer variable to 0:<span><br></span>&nbsp;&nbsp;&nbsp;&nbsp;memset((void *)&p, 0, sizeof(p));</li>
                                <li>Declare an external variable or array<span><br></span>&nbsp;&nbsp;&nbsp;&nbsp;extern int location0;<span><br></span>and use an assembly language file, or some special linker invocation, to arrange that this symbol refers
                                    to (i.e. the variable is placed at) address 0.</li>
                            </ol>
                        </td>
                        <td>
                            <p>Поскольку все, что находится в местоположении 0, очевидно, зависит от машины, вы можете использовать любой машинно-зависимый прием, чтобы сработать. Прочитайте документацию вашего поставщика (и см. Раздел 19). Вероятно, если
                                для вас вообще имеет смысл доступ к местоположению 0, система будет настроена так, чтобы сделать это достаточно просто. Некоторые возможности:</p>
                            <ol>
                                <li>Просто установите указатель на 0. (Это способ, который не должен работать, но если он имеет смысл, он, вероятно, будет.)</li>
                                <li>Присвойте целое число 0 переменной int и преобразуйте это int в указатель. (Это также не гарантируется, но, вероятно, будет.)</li>
                                <li>Используйте объединение, чтобы установить биты переменной указателя в 0:
                                    <span><br></span>union {<span><br></span>&nbsp;&nbsp;&nbsp;&nbsp;int *u_p;<span><br></span>&nbsp;&nbsp;&nbsp;&nbsp;int u_i; &nbsp;&nbsp;&nbsp;&nbsp;/* assumes sizeof(int) >= sizeof(int *) */<span><br></span>} p;<span><br></span>p.u_i
                                    = 0;
                                </li>
                                <li>Используйте memset, чтобы установить биты переменной указателя в 0:<span><br></span>&nbsp;&nbsp;&nbsp;&nbsp;memset((void *)&p, 0, sizeof(p));</li>
                                <li>Объявите внешнюю переменную или массив<span><br></span>&nbsp;&nbsp;&nbsp;&nbsp;extern int location0;<span><br></span>и использовать файл на языке ассемблера или какой-либо специальный вызов компоновщика, чтобы организовать,
                                    что этот символ ссылается (то есть, на переменную помещается) по адресу 0.</li>
                            </ol>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <h4>20</h4>
                        </td>
                        <td>
                            <h4>What does a run-time "null pointer assignment" error mean? How can I track it down?</h4>
                        </td>
                        <td>
                            <h4>Что означает ошибка "присвоение нулевого указателя" во время выполнения? Как я могу отследить это?</h4>
                        </td>
                    </tr>
                    <tr>
                        <td></td>
                        <td>
                            <p>This message, which typically occurs with MS-DOS compilers, means that you've written, via a null pointer, to an invalid location--probably offset 0 in the default data segment. (The pointer in question might have been uninitialized,
                                not all uninitialized pointers necessarily start out as null pointers.)</p>
                            <p>A debugger may let you set some kind of data watchpoint on location 0. Alternatively, you could write a bit of code to stash away a copy of 20 or so bytes from location 0, and periodically check that the memory at location
                                0 hasn't changed.</p>
                        </td>
                        <td>
                            <p>Это сообщение, которое обычно происходит с компиляторами MS-DOS, означает, что вы записали с помощью нулевого указателя неверное местоположение - вероятно, смещение 0 в сегменте данных по умолчанию. (Указанный указатель мог
                                быть неинициализирован, не все неинициализированные указатели обязательно начинаются как нулевые указатели.)</p>
                            <p>Отладчик может позволить вам установить какую-то точку наблюдения за данными в местоположении 0. В качестве альтернативы, вы можете написать немного кода, чтобы спрятать копию примерно в 20 байтов из местоположения 0, и периодически
                                проверять, что память в местоположении 0 не имеет изменилось.</p>
                        </td>
                    </tr>
                </table>
            </div>
            <hr>
        </div>
        <div class="slide">
            <label for="slide-control_characters">
                <h3>Control characters / Управляющие символы</h3>
                <input type="checkbox" id="slide-control_characters" />
                <div class="slide-text">
                    <table class="table-td-left">
                        <tr>
                            <th class="table-w-20per">Символ</th>
                            <th>Описание</th>
                        </tr>
                        <tr>
                            <td>\r</td>
                            <td>возврат каретки в начало строки</td>
                        </tr>
                        <tr>
                            <td>\n</td>
                            <td>новая строка</td>
                        </tr>
                        <tr>
                            <td>\t</td>
                            <td>горизонтальная табуляция</td>
                        </tr>
                        <tr>
                            <td>\v</td>
                            <td>вертикальная табуляция</td>
                        </tr>
                        <tr>
                            <td>\»</td>
                            <td>двойные кавычки</td>
                        </tr>
                        <tr>
                            <td>\’</td>
                            <td>апостроф</td>
                        </tr>
                        <tr>
                            <td>\\</td>
                            <td>обратный слеш</td>
                        </tr>
                        <tr>
                            <td>\0</td>
                            <td>нулевой символ</td>
                        </tr>
                        <tr>
                            <td>\?</td>
                            <td>знак вопроса</td>
                        </tr>
                        <tr>
                            <td>\a</td>
                            <td>сигнал бипера (спикера) компьютера</td>
                        </tr>
                    </table>
                </div>
            </label>
            <hr>
        </div>
        <div class="slide">
            <label for="slide-Iterator_categories">
                <h3>Iterator categories / Категории итераторов</h3> 
            </label>
            <input type="checkbox" id="slide-Iterator_categories" />
            <div class="slide-text">
                <h2>Введение</h2>
                <p>Как известно, итератор в C++ — это абстракция: не какой-то конкретный тип или набор типов, не какой-то общий базовый класс, а всего лишь <strong>набор требований</strong> к типу: возможность итератор разыменовать (*it), увеличить (++it)
                    и т. д. При этом в разных областях применения итераторов — во всевозможных алгоритмах и методах контейнеров — набор требований к итераторам отличается: какие-то алгоритмы требуют от итераторов большего, чем другие. Так и появляются
                    <em>категории итераторов:</em> более детальные наборы требований к соответствующему типу.</p>
                <p>Чтобы выделить самые базовые категории итераторов, рассмотрим простейший алгоритм — <a href="https://en.cppreference.com/w/cpp/algorithm/copy" target="_blank" rel="noopener nofollow">copy</a>, копирующий значения из переданного диапазона
                    в новое место:</p>
                <pre contenteditable="false" data-language="c_cpp" style="opacity: 1;" tabindex="0">
                    <div>
                        <div aria-label="Блок кода: нажмите клавишу Escape, чтобы выйти из блока кода" role="textbox" tabindex="-1" class="rc-CodeBlock code-container ace_editor ace-tomorrow" style="height: 42px;"><textarea class="ace_text-input" wrap="off" autocorrect="off" autocapitalize="off" spellcheck="false" style="opacity: 0; left: 446.467px; top: 14px; height: 14px; width: 6.59781px;" role="presentation" aria-hidden="true" tabindex="-1" aria-label="Нажмите клавишу Escape, чтобы выйти из режима редактирования кода"></textarea>
                            <div class="ace_gutter"><div class="ace_layer ace_gutter-layer ace_folding-enabled" style="margin-top: 0px; height: 70px; width: 40px;">
                                <div class="ace_gutter-cell " style="height: 14px;">1</div>
                                <div class="ace_gutter-cell " style="height: 14px;">2</div>
                            </div>
                            <div class="ace_gutter-active-line" style="top: 14px; height: 14px;"></div>
                        </div>
                        <div class="ace_scroller" style="left: 40px; right: 0px; bottom: 0px;">
                            <div class="ace_content" style="margin-top: 0px; width: 796px; height: 70px; margin-left: 0px;">
                                <div class="ace_layer ace_print-margin-layer">
                                    <div class="ace_print-margin" style="left: 531.825px; visibility: visible;"></div>
                                </div>
                                <div class="ace_layer ace_marker-layer"></div>
                                <div class="ace_layer ace_text-layer" style="padding: 0px 4px;">
                                    <div class="ace_line_group" style="height:14px">
                                        <div class="ace_line" style="height:14px"><span class="ace_storage ace_type">template</span><span class="ace_keyword ace_operator">&lt;</span><span class="ace_storage ace_modifier">typename</span> <span class="ace_identifier">InputIt</span><span class="ace_punctuation ace_operator">,</span> <span class="ace_storage ace_modifier">typename</span> <span class="ace_identifier">OutputIt</span><span class="ace_keyword ace_operator">&gt;</span>
                                        </div>
                                    </div>
                                    <div class="ace_line_group" style="height:14px">
                                        <div class="ace_line" style="height:14px"><span class="ace_identifier">OutputIt</span> <span class="ace_identifier">copy</span><span class="ace_paren ace_lparen">(</span><span class="ace_identifier">InputIt</span> <span class="ace_identifier">first</span><span class="ace_punctuation ace_operator">,</span> <span class="ace_identifier">InputIt</span> <span class="ace_identifier">last</span><span class="ace_punctuation ace_operator">,</span> <span class="ace_identifier">OutputIt</span> <span class="ace_identifier">d_first</span><span class="ace_paren ace_rparen">)</span><span class="ace_punctuation ace_operator">;</span>
                                        </div>
                                    </div>
                                </div>
                                <div class="ace_layer ace_marker-layer"></div>
                                <div class="ace_layer ace_cursor-layer ace_hidden-cursors">
                                    <div class="ace_cursor" style="left: 406.467px; top: 14px; width: 6.59781px; height: 14px;"></div>
                                </div>
                            </div>
                        </div>
                        <div class="ace_scrollbar ace_scrollbar-v" style="display: none; width: 20px; bottom: 0px;">
                            <div class="ace_scrollbar-inner" style="width: 20px; height: 28px;"></div>
                        </div>
                        <div class="ace_scrollbar ace_scrollbar-h" style="display: none; height: 20px; left: 40px; right: 0px;">
                            <div class="ace_scrollbar-inner" style="height: 20px; width: 796px;"></div>
                        </div>
                        <div style="height: auto; width: auto; top: 0px; left: 0px; visibility: hidden; position: absolute; white-space: pre; font: inherit; overflow: hidden;">
                            <div style="height: auto; width: auto; top: 0px; left: 0px; visibility: hidden; position: absolute; white-space: pre; font: inherit; overflow: visible;"></div>
                            <div style="height: auto; width: auto; top: 0px; left: 0px; visibility: hidden; position: absolute; white-space: pre; font-style: inherit; font-variant: inherit; font-stretch: inherit; font-size: inherit; line-height: inherit; font-family: inherit; overflow: visible;">XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</div>
                        </div>
                            </div>
                    </div>
                </pre>
                <p>Его реализация (представленная в том числе и в документации) настолько проста, что использованию этого алгоритма обычно предпочитают самописный цикл:</p>
                <pre contenteditable="false" data-language="c_cpp" style="opacity: 1;" tabindex="0"><div><div aria-label="Блок кода: нажмите клавишу Escape, чтобы выйти из блока кода" role="textbox" tabindex="-1" class="rc-CodeBlock code-container ace_editor ace-tomorrow" style="height: 126px;"><textarea class="ace_text-input" wrap="off" autocorrect="off" autocapitalize="off" spellcheck="false" style="opacity: 0; left: 57.5978px; top: 112px; height: 14px; width: 6.59781px;" role="presentation" aria-hidden="true" tabindex="-1" aria-label="Нажмите клавишу Escape, чтобы выйти из режима редактирования кода"></textarea><div class="ace_gutter"><div class="ace_layer ace_gutter-layer ace_folding-enabled" style="margin-top: 0px; height: 154px; width: 47px;"><div class="ace_gutter-cell " style="height: 14px;">1</div><div class="ace_gutter-cell " style="height: 14px;">2</div><div class="ace_gutter-cell " style="height: 14px;">3</div><div class="ace_gutter-cell " style="height: 14px;">4<span class="ace_fold-widget ace_start ace_open" style="height: 14px;"></span></div><div class="ace_gutter-cell " style="height: 14px;">5<span class="ace_fold-widget ace_start ace_open" style="height: 14px;"></span></div><div class="ace_gutter-cell " style="height: 14px;">6</div><div class="ace_gutter-cell " style="height: 14px;">7</div><div class="ace_gutter-cell " style="height: 14px;">8</div><div class="ace_gutter-cell " style="height: 14px;">9</div></div><div class="ace_gutter-active-line" style="top: 112px; height: 14px;"></div></div><div class="ace_scroller" style="left: 47px; right: 0px; bottom: 0px;"><div class="ace_content" style="margin-top: 0px; width: 789px; height: 154px; margin-left: 0px;"><div class="ace_layer ace_print-margin-layer"><div class="ace_print-margin" style="left: 531.825px; visibility: visible;"></div></div><div class="ace_layer ace_marker-layer"><div class="ace_bracket ace_start ace_br15" style="height:14px;width:6.5978125px;top:42px;left:4px;"></div></div><div class="ace_layer ace_text-layer" style="padding: 0px 4px;"><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px"><span class="ace_storage ace_type">template</span><span class="ace_keyword ace_operator">&lt;</span><span class="ace_storage ace_modifier">typename</span> <span class="ace_identifier">InputIt</span><span class="ace_punctuation ace_operator">,</span> <span class="ace_storage ace_modifier">typename</span> <span class="ace_identifier">OutputIt</span><span class="ace_keyword ace_operator">&gt;</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px"><span class="ace_identifier">OutputIt</span> <span class="ace_identifier">copy</span><span class="ace_paren ace_lparen">(</span><span class="ace_identifier">InputIt</span> <span class="ace_identifier">first</span><span class="ace_punctuation ace_operator">,</span> <span class="ace_identifier">InputIt</span> <span class="ace_identifier">last</span><span class="ace_punctuation ace_operator">,</span> </div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px">              <span class="ace_identifier">OutputIt</span> <span class="ace_identifier">d_first</span><span class="ace_paren ace_rparen">)</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px"><span class="ace_paren ace_lparen">{</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px">    <span class="ace_keyword ace_control">while</span> <span class="ace_paren ace_lparen">(</span><span class="ace_identifier">first</span> <span class="ace_keyword ace_operator">!=</span> <span class="ace_identifier">last</span><span class="ace_paren ace_rparen">)</span> <span class="ace_paren ace_lparen">{</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px">        <span class="ace_keyword ace_operator">*</span><span class="ace_identifier">d_first</span><span class="ace_keyword ace_operator">++</span> <span class="ace_keyword ace_operator">=</span> <span class="ace_keyword ace_operator">*</span><span class="ace_identifier">first</span><span class="ace_keyword ace_operator">++</span><span class="ace_punctuation ace_operator">;</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px">    <span class="ace_paren ace_rparen">}</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px">    <span class="ace_keyword ace_control">return</span> <span class="ace_identifier">d_first</span><span class="ace_punctuation ace_operator">;</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px"><span class="ace_paren ace_rparen">}</span></div></div></div><div class="ace_layer ace_marker-layer"></div><div class="ace_layer ace_cursor-layer ace_hidden-cursors"><div class="ace_cursor" style="left: 10.5978px; top: 112px; width: 6.59781px; height: 14px;"></div></div></div></div><div class="ace_scrollbar ace_scrollbar-v" style="display: none; width: 20px; bottom: 0px;"><div class="ace_scrollbar-inner" style="width: 20px; height: 126px;"></div></div><div class="ace_scrollbar ace_scrollbar-h" style="display: none; height: 20px; left: 47px; right: 0px;"><div class="ace_scrollbar-inner" style="height: 20px; width: 789px;"></div></div><div style="height: auto; width: auto; top: 0px; left: 0px; visibility: hidden; position: absolute; white-space: pre; font: inherit; overflow: hidden;"><div style="height: auto; width: auto; top: 0px; left: 0px; visibility: hidden; position: absolute; white-space: pre; font: inherit; overflow: visible;"></div><div style="height: auto; width: auto; top: 0px; left: 0px; visibility: hidden; position: absolute; white-space: pre; font-style: inherit; font-variant: inherit; font-stretch: inherit; font-size: inherit; line-height: inherit; font-family: inherit; overflow: visible;">XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</div></div></div></div></pre>
                <p>Запись *first++ эквивалентна *(first++): по сути это разыменование итератора с <em>последующим</em> его сдвигом.</p>
                <p><em>Любители чуть менее тривиальных примеров могут с тем же успехом рассмотреть алгоритм </em><a href="https://en.cppreference.com/w/cpp/algorithm/copy" target="_blank" rel="noopener nofollow"><em>copy_if</em></a><em> или </em><a href="https://en.cppreference.com/w/cpp/algorithm/transform"
                        target="_blank" rel="noopener nofollow"><em>transform</em></a><em>.</em></p>
                <p>Поскольку функция шаблонная, она не указывает конкретный тип своих параметров, вместо этого выдвигая требования к ним через код: например, передать в неё числа не выйдет, поскольку их нельзя разыменовать с помощью *.</p>
                <p>Уже на этом примере видны различия в использовании итераторов:</p>
                <ol>
                    <li>first и last типа InputIt — итераторы, задающие исходный диапазон. Используются для <em>итерирования</em> по этому диапазону и, соответственно, должны позволять сравнение на неравенство (first != last), разыменование и инкремент (*first++).
                        Итераторы, удовлетворяющие этим требованиям, называются <em>входными</em> (input).</li>
                    <li>d_first типа OutputIt — итератор, в который копируются значения. Ему достаточно уметь лишь получать очередное значение с последующим инкрементом: *d_first++ = value. Итераторы, удовлетворяющие этим требованиям, называются <em>выходными</em>                        (output).</li>
                </ol>
                <p>Однако видно, что есть итераторы, являющиеся одновременно и входными, и выходными: например, итераторы неконстантного вектора; с их помощью можно и читать значения, и записывать их. Такие итераторы, как правило, можно отнести и к более
                    узким категориям.</p>
                <p>С другой стороны, видно, что к любым итераторам можно выдвинуть самые базовые требования:</p>
                <ol>
                    <li>Возможность сделать ++it, имея в виду перемещение итератора к следующему элементу.</li>
                    <li>Возможность сделать *it, имея в виду обращение к значению по итератору (возможно, лишь для записи туда нового значения).</li>
                    <li>Помимо этого допускается объединить разыменование и инкремент в одно выражение с помощью постфиксного инкремента: *it++.</li>
                    <li>Наконец, есть некоторый набор стандратных технических требований к типам, например, возможность копировать итераторы. <strong>Полный список</strong> можно изучить <a href="https://en.cppreference.com/w/cpp/named_req/Iterator" target="_blank"
                            rel="noopener nofollow">здесь</a>. Однако, несмотря на возможность итератор скопировать, не всегда копию итератора можно безопасно использовать. Подробнее об этом вы узнаете ниже в контексте свойства <em>многопроходности.</em></li>
                </ol>
                <h2>Входные (input) итераторы</h2>
                <p>Итак, input-итераторы позволяют проитерироваться по набору значений, не изменяя их. Например, можно вывести эти значения через пробел:</p>
                <pre contenteditable="false" data-language="c_cpp" style="opacity: 1;" tabindex="0"><div><div aria-label="Блок кода: нажмите клавишу Escape, чтобы выйти из блока кода" role="textbox" tabindex="-1" class="rc-CodeBlock code-container ace_editor ace-tomorrow" style="height: 42px;"><textarea class="ace_text-input" wrap="off" autocorrect="off" autocapitalize="off" spellcheck="false" style="opacity: 0; left: 50.5978px; top: 28px; height: 14px; width: 6.59781px;" role="presentation" aria-hidden="true" tabindex="-1" aria-label="Нажмите клавишу Escape, чтобы выйти из режима редактирования кода"></textarea><div class="ace_gutter"><div class="ace_layer ace_gutter-layer ace_folding-enabled" style="margin-top: 0px; height: 70px; width: 40px;"><div class="ace_gutter-cell " style="height: 14px;">1<span class="ace_fold-widget ace_start ace_open" style="height: 14px;"></span></div><div class="ace_gutter-cell " style="height: 14px;">2</div><div class="ace_gutter-cell " style="height: 14px;">3</div></div><div class="ace_gutter-active-line" style="top: 28px; height: 14px;"></div></div><div class="ace_scroller" style="left: 40px; right: 0px; bottom: 0px;"><div class="ace_content" style="margin-top: 0px; width: 796px; height: 70px; margin-left: 0px;"><div class="ace_layer ace_print-margin-layer"><div class="ace_print-margin" style="left: 531.825px; visibility: visible;"></div></div><div class="ace_layer ace_marker-layer"><div class="ace_bracket ace_start ace_br15" style="height:14px;width:6.5978125px;top:0px;left:201.934375px;"></div></div><div class="ace_layer ace_text-layer" style="padding: 0px 4px;"><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px"><span class="ace_keyword ace_control">for</span> <span class="ace_paren ace_lparen">(</span><span class="ace_punctuation ace_operator">;</span> <span class="ace_identifier">begin</span> <span class="ace_keyword ace_operator">!=</span> <span class="ace_identifier">end</span><span class="ace_punctuation ace_operator">;</span> <span class="ace_keyword ace_operator">++</span><span class="ace_identifier">begin</span><span class="ace_paren ace_rparen">)</span> <span class="ace_paren ace_lparen">{</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px">  <span class="ace_identifier">cout</span> <span class="ace_keyword ace_operator">&lt;&lt;</span> <span class="ace_keyword ace_operator">*</span><span class="ace_identifier">begin</span> <span class="ace_keyword ace_operator">&lt;&lt;</span> <span class="ace_string ace_start">"</span><span class="ace_string"> </span><span class="ace_string ace_end">"</span><span class="ace_punctuation ace_operator">;</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px"><span class="ace_paren ace_rparen">}</span></div></div></div><div class="ace_layer ace_marker-layer"></div><div class="ace_layer ace_cursor-layer ace_hidden-cursors"><div class="ace_cursor" style="left: 10.5978px; top: 28px; width: 6.59781px; height: 14px;"></div></div></div></div><div class="ace_scrollbar ace_scrollbar-v" style="display: none; width: 20px; bottom: 0px;"><div class="ace_scrollbar-inner" style="width: 20px; height: 42px;"></div></div><div class="ace_scrollbar ace_scrollbar-h" style="display: none; height: 20px; left: 40px; right: 0px;"><div class="ace_scrollbar-inner" style="height: 20px; width: 796px;"></div></div><div style="height: auto; width: auto; top: 0px; left: 0px; visibility: hidden; position: absolute; white-space: pre; font: inherit; overflow: hidden;"><div style="height: auto; width: auto; top: 0px; left: 0px; visibility: hidden; position: absolute; white-space: pre; font: inherit; overflow: visible;"></div><div style="height: auto; width: auto; top: 0px; left: 0px; visibility: hidden; position: absolute; white-space: pre; font-style: inherit; font-variant: inherit; font-stretch: inherit; font-size: inherit; line-height: inherit; font-family: inherit; overflow: visible;">XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</div></div></div></div></pre>
                <p>(Этот код, конечно, не скомпилируется, если для *it не определён оператор &lt;&lt; вывода в поток: например, для пары или вектора.)</p>
                <p>Под эти довольно мягкие требования попадают итераторы всех контейнеров: векторов, множеств, словарей и др., в том числе константных.</p>
                <p>Итого, требования к входным итераторам следующие:</p>
                <ul>
                    <li>++it: переход к следующему значению;</li>
                    <li>*it: <strong>получение значения</strong> по итератору;</li>
                    <li>it-&gt;field: обращение к полю значения, эквивалентно (*it).field;</li>
                    <li>*(it++): получение текущего значения и переход к следующему;</li>
                    <li>it1 != end: сравнение на неравенство, необходимое лишь для определения конца диапазона.</li>
                </ul>
                <p>В этот список осознанно не попало довольно важное свойство, которым обладают все итераторы контейнеров, — <strong>многопроходность.</strong> Формально его можно определить так: тип итераторов является многопроходным, если по диапазону
                    [begin, end) итераторов этого типа можно <strong>проитерироваться более одного раза.</strong> Таким образом, по диапазону из многопроходных итераторов можно пройтись несколько раз, а по диапазону из однопроходных — только один раз.</p>
                <p>Чуть ниже мы увидим, как неожиданно могут вести себя однопроходные итераторы; а в разделе про forward-итераторы — зачем в алгоритмах может понадобиться многопроходность.</p>
                <h3></h3>
                <h3>istream_iterator</h3>
                <p>Категории итераторов не возникали на пустом месте: каждая из них описывает некоторый набор существующих итераторов, не удовлетворяющих более жёстким требованиям. В частности, типичным примером входного итератора является <strong>итератор чтения из потока</strong>                    — istream_iterator из заголовочного файла &lt;iterator&gt;. Так выглядит пример заполнения вектора всеми строками из входного потока с помощью этого итератора:</p>
                <pre contenteditable="false" data-language="c_cpp" style="opacity: 1;" tabindex="0"><div><div aria-label="Блок кода: нажмите клавишу Escape, чтобы выйти из блока кода" role="textbox" tabindex="-1" class="rc-CodeBlock code-container ace_editor ace-tomorrow" style="height: 42px;"><textarea class="ace_text-input" wrap="off" autocorrect="off" autocapitalize="off" spellcheck="false" style="opacity: 0; left: 274.923px; top: 28px; height: 14px; width: 6.59781px;" role="presentation" aria-hidden="true" tabindex="-1" aria-label="Нажмите клавишу Escape, чтобы выйти из режима редактирования кода"></textarea><div class="ace_gutter"><div class="ace_layer ace_gutter-layer ace_folding-enabled" style="margin-top: 0px; height: 70px; width: 40px;"><div class="ace_gutter-cell " style="height: 14px;">1</div><div class="ace_gutter-cell " style="height: 14px;">2</div><div class="ace_gutter-cell " style="height: 14px;">3</div></div><div class="ace_gutter-active-line" style="top: 28px; height: 14px;"></div></div><div class="ace_scroller" style="left: 40px; right: 0px; bottom: 0px;"><div class="ace_content" style="margin-top: 0px; width: 796px; height: 70px; margin-left: 0px;"><div class="ace_layer ace_print-margin-layer"><div class="ace_print-margin" style="left: 531.825px; visibility: visible;"></div></div><div class="ace_layer ace_marker-layer"></div><div class="ace_layer ace_text-layer" style="padding: 0px 4px;"><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px"><span class="ace_storage ace_modifier">const</span> <span class="ace_identifier">istream_iterator</span><span class="ace_keyword ace_operator">&lt;</span><span class="ace_identifier">string</span><span class="ace_keyword ace_operator">&gt;</span> <span class="ace_identifier">start</span><span class="ace_paren ace_lparen">(</span><span class="ace_identifier">cin</span><span class="ace_paren ace_rparen">)</span><span class="ace_punctuation ace_operator">;</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px"><span class="ace_storage ace_modifier">const</span> <span class="ace_identifier">istream_iterator</span><span class="ace_keyword ace_operator">&lt;</span><span class="ace_identifier">string</span><span class="ace_keyword ace_operator">&gt;</span> <span class="ace_identifier">end</span><span class="ace_punctuation ace_operator">;</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px"><span class="ace_identifier">vector</span><span class="ace_keyword ace_operator">&lt;</span><span class="ace_identifier">string</span><span class="ace_keyword ace_operator">&gt;</span> <span class="ace_identifier">strings</span><span class="ace_paren ace_lparen">(</span><span class="ace_identifier">start</span><span class="ace_punctuation ace_operator">,</span> <span class="ace_identifier">end</span><span class="ace_paren ace_rparen">)</span><span class="ace_punctuation ace_operator">;</span></div></div></div><div class="ace_layer ace_marker-layer"></div><div class="ace_layer ace_cursor-layer ace_hidden-cursors"><div class="ace_cursor" style="left: 234.923px; top: 28px; width: 6.59781px; height: 14px;"></div></div></div></div><div class="ace_scrollbar ace_scrollbar-v" style="display: none; width: 20px; bottom: 0px;"><div class="ace_scrollbar-inner" style="width: 20px; height: 42px;"></div></div><div class="ace_scrollbar ace_scrollbar-h" style="display: none; height: 20px; left: 40px; right: 0px;"><div class="ace_scrollbar-inner" style="height: 20px; width: 796px;"></div></div><div style="height: auto; width: auto; top: 0px; left: 0px; visibility: hidden; position: absolute; white-space: pre; font: inherit; overflow: hidden;"><div style="height: auto; width: auto; top: 0px; left: 0px; visibility: hidden; position: absolute; white-space: pre; font: inherit; overflow: visible;"></div><div style="height: auto; width: auto; top: 0px; left: 0px; visibility: hidden; position: absolute; white-space: pre; font-style: inherit; font-variant: inherit; font-stretch: inherit; font-size: inherit; line-height: inherit; font-family: inherit; overflow: visible;">XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</div></div></div></div></pre>
                <p>Разыменование этого итератора практически эквивалентно чтению очередного значения из потока (в последнем примере это cin). Поскольку итератор старается занимать минимально необходимый объём памяти, он не сохраняет предыдущие считанные
                    значения и потому является однопроходным. Так, вектор more_strings всегда будет содержать только первое значение: все введённые строки уже сохранены в вектор strings, а сам итератор start помнит лишь значение, сохранённое в нём при
                    инициализации, то есть первую строку из ввода. Попробуйте запустить этот код:</p>
                <pre contenteditable="false" data-language="c_cpp" style="opacity: 1;" tabindex="0"><div><div aria-label="Блок кода: нажмите клавишу Escape, чтобы выйти из блока кода" role="textbox" tabindex="-1" class="rc-CodeBlock code-container ace_editor ace-tomorrow" style="height: 70px;"><textarea class="ace_text-input" wrap="off" autocorrect="off" autocapitalize="off" spellcheck="false" style="opacity: 0; left: 406.88px; top: 56px; height: 14px; width: 6.59781px;" role="presentation" aria-hidden="true" tabindex="-1" aria-label="Нажмите клавишу Escape, чтобы выйти из режима редактирования кода"></textarea><div class="ace_gutter"><div class="ace_layer ace_gutter-layer ace_folding-enabled" style="margin-top: 0px; height: 98px; width: 40px;"><div class="ace_gutter-cell " style="height: 14px;">1</div><div class="ace_gutter-cell " style="height: 14px;">2</div><div class="ace_gutter-cell " style="height: 14px;">3</div><div class="ace_gutter-cell " style="height: 14px;">4</div><div class="ace_gutter-cell " style="height: 14px;">5</div></div><div class="ace_gutter-active-line" style="top: 56px; height: 14px;"></div></div><div class="ace_scroller" style="left: 40px; right: 0px; bottom: 0px;"><div class="ace_content" style="margin-top: 0px; width: 796px; height: 98px; margin-left: 0px;"><div class="ace_layer ace_print-margin-layer"><div class="ace_print-margin" style="left: 531.825px; visibility: visible;"></div></div><div class="ace_layer ace_marker-layer"><div class="ace_bracket ace_start ace_br15" style="height:14px;width:6.5978125px;top:56px;left:347.08625px;"></div></div><div class="ace_layer ace_text-layer" style="padding: 0px 4px;"><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px"><span class="ace_storage ace_modifier">const</span> <span class="ace_identifier">istream_iterator</span><span class="ace_keyword ace_operator">&lt;</span><span class="ace_identifier">string</span><span class="ace_keyword ace_operator">&gt;</span> <span class="ace_identifier">start</span><span class="ace_paren ace_lparen">(</span><span class="ace_identifier">cin</span><span class="ace_paren ace_rparen">)</span><span class="ace_punctuation ace_operator">;</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px"><span class="ace_storage ace_modifier">const</span> <span class="ace_identifier">istream_iterator</span><span class="ace_keyword ace_operator">&lt;</span><span class="ace_identifier">string</span><span class="ace_keyword ace_operator">&gt;</span> <span class="ace_identifier">end</span><span class="ace_punctuation ace_operator">;</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px"><span class="ace_identifier">vector</span><span class="ace_keyword ace_operator">&lt;</span><span class="ace_identifier">string</span><span class="ace_keyword ace_operator">&gt;</span> <span class="ace_identifier">strings</span><span class="ace_paren ace_lparen">(</span><span class="ace_identifier">start</span><span class="ace_punctuation ace_operator">,</span> <span class="ace_identifier">end</span><span class="ace_paren ace_rparen">)</span><span class="ace_punctuation ace_operator">;</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px"><span class="ace_identifier">vector</span><span class="ace_keyword ace_operator">&lt;</span><span class="ace_identifier">string</span><span class="ace_keyword ace_operator">&gt;</span> <span class="ace_identifier">more_strings</span><span class="ace_paren ace_lparen">(</span><span class="ace_identifier">start</span><span class="ace_punctuation ace_operator">,</span> <span class="ace_identifier">end</span><span class="ace_paren ace_rparen">)</span><span class="ace_punctuation ace_operator">;</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px"><span class="ace_comment">// more_strings состоит из одного элемента — strings[0]</span></div></div></div><div class="ace_layer ace_marker-layer"></div><div class="ace_layer ace_cursor-layer ace_hidden-cursors"><div class="ace_cursor" style="left: 366.88px; top: 56px; width: 6.59781px; height: 14px;"></div></div></div></div><div class="ace_scrollbar ace_scrollbar-v" style="display: none; width: 20px; bottom: 0px;"><div class="ace_scrollbar-inner" style="width: 20px; height: 70px;"></div></div><div class="ace_scrollbar ace_scrollbar-h" style="display: none; height: 20px; left: 40px; right: 0px;"><div class="ace_scrollbar-inner" style="height: 20px; width: 796px;"></div></div><div style="height: auto; width: auto; top: 0px; left: 0px; visibility: hidden; position: absolute; white-space: pre; font: inherit; overflow: hidden;"><div style="height: auto; width: auto; top: 0px; left: 0px; visibility: hidden; position: absolute; white-space: pre; font: inherit; overflow: visible;"></div><div style="height: auto; width: auto; top: 0px; left: 0px; visibility: hidden; position: absolute; white-space: pre; font-style: inherit; font-variant: inherit; font-stretch: inherit; font-size: inherit; line-height: inherit; font-family: inherit; overflow: visible;">XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</div></div></div></div></pre>
                <p>Поскольку такие итераторы не привязаны к конкретной ячейке в памяти и получают очередное значение из ввода, нельзя рассчитывать и на «разумное» сравнение итераторов на равенство:</p>
                <pre contenteditable="false" data-language="c_cpp" style="opacity: 1;" tabindex="0"><div><div aria-label="Блок кода: нажмите клавишу Escape, чтобы выйти из блока кода" role="textbox" tabindex="-1" class="rc-CodeBlock code-container ace_editor ace-tomorrow" style="height: 56px;"><textarea class="ace_text-input" wrap="off" autocorrect="off" autocapitalize="off" spellcheck="false" style="opacity: 0; left: 294.717px; top: 42px; height: 14px; width: 6.59781px;" role="presentation" aria-hidden="true" tabindex="-1" aria-label="Нажмите клавишу Escape, чтобы выйти из режима редактирования кода"></textarea><div class="ace_gutter"><div class="ace_layer ace_gutter-layer ace_folding-enabled" style="margin-top: 0px; height: 84px; width: 40px;"><div class="ace_gutter-cell " style="height: 14px;">1</div><div class="ace_gutter-cell " style="height: 14px;">2</div><div class="ace_gutter-cell " style="height: 14px;">3</div><div class="ace_gutter-cell " style="height: 14px;">4</div></div><div class="ace_gutter-active-line" style="top: 42px; height: 14px;"></div></div><div class="ace_scroller" style="left: 40px; right: 0px; bottom: 0px;"><div class="ace_content" style="margin-top: 0px; width: 796px; height: 84px; margin-left: 0px;"><div class="ace_layer ace_print-margin-layer"><div class="ace_print-margin" style="left: 531.825px; visibility: visible;"></div></div><div class="ace_layer ace_marker-layer"></div><div class="ace_layer ace_text-layer" style="padding: 0px 4px;"><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px"><span class="ace_storage ace_modifier">const</span> <span class="ace_identifier">istream_iterator</span><span class="ace_keyword ace_operator">&lt;</span><span class="ace_identifier">string</span><span class="ace_keyword ace_operator">&gt;</span> <span class="ace_identifier">start</span><span class="ace_paren ace_lparen">(</span><span class="ace_identifier">cin</span><span class="ace_paren ace_rparen">)</span><span class="ace_punctuation ace_operator">;</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px"><span class="ace_storage ace_type">auto</span> <span class="ace_identifier">start_copy</span> <span class="ace_keyword ace_operator">=</span> <span class="ace_identifier">start</span><span class="ace_punctuation ace_operator">;</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px"><span class="ace_keyword ace_operator">++</span><span class="ace_identifier">start_copy</span><span class="ace_punctuation ace_operator">;</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px"><span class="ace_identifier">cout</span> <span class="ace_keyword ace_operator">&lt;&lt;</span> <span class="ace_paren ace_lparen">(</span><span class="ace_identifier">start</span> <span class="ace_keyword ace_operator">==</span> <span class="ace_identifier">start_copy</span><span class="ace_paren ace_rparen">)</span> <span class="ace_keyword ace_operator">&lt;&lt;</span> <span class="ace_identifier">endl</span><span class="ace_punctuation ace_operator">;</span></div></div></div><div class="ace_layer ace_marker-layer"></div><div class="ace_layer ace_cursor-layer ace_hidden-cursors"><div class="ace_cursor" style="left: 254.717px; top: 42px; width: 6.59781px; height: 14px;"></div></div></div></div><div class="ace_scrollbar ace_scrollbar-v" style="display: none; width: 20px; bottom: 0px;"><div class="ace_scrollbar-inner" style="width: 20px; height: 56px;"></div></div><div class="ace_scrollbar ace_scrollbar-h" style="display: none; height: 20px; left: 40px; right: 0px;"><div class="ace_scrollbar-inner" style="height: 20px; width: 796px;"></div></div><div style="height: auto; width: auto; top: 0px; left: 0px; visibility: hidden; position: absolute; white-space: pre; font: inherit; overflow: hidden;"><div style="height: auto; width: auto; top: 0px; left: 0px; visibility: hidden; position: absolute; white-space: pre; font: inherit; overflow: visible;"></div><div style="height: auto; width: auto; top: 0px; left: 0px; visibility: hidden; position: absolute; white-space: pre; font-style: inherit; font-variant: inherit; font-stretch: inherit; font-size: inherit; line-height: inherit; font-family: inherit; overflow: visible;">XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</div></div></div></div></pre>
                <p>Если ввести больше одной строки, каждый из итераторов будет помнить свою строку, но при этом они будут считаться равными. Во-первых, с некоторой точки зрения это логично: при итерировании с помощью любого из них будет получен один и тот
                    же набор значений (если только не пытаться использовать оба итератора одновременно). Во-вторых, для простейших итераторов достаточно иметь возможность корректного сравнения лишь с конечным итератором. В роли конечного istream-итератора
                    всегда выступает созданный с помощью конструктора по умолчанию: обычный итератор становится равным ему, как только данные в потоке иссякли.</p>
                <p>Как видно из примера с вектором strings, однопроходность и другие ограничения итераторов не являются критичными: при наличии возможности использовать дополнительную память все значения из данного диапазона можно просто сложить в вектор
                    (или любой другой контейнер).</p>
                <h3></h3>
                <h3>Функции, работающие с input-итераторами</h3>
                <p>Несмотря на вышеперечисленные ограничения, для input-итераторов (как и для многих других) существуют функции, готовые с ними работать и не выдвигающие более жёстких требований. Один из самых простых примеров — использованный в предыдущих
                    примерах конструктор вектора от двух итераторов: понятно, что для создания вектора по набору значений достаточно лишь один раз проитерироваться по этому набору. Но как для произвольной функции понять, достаточно ли передаваемым в неё
                    итераторам быть входными или требования к ним более жёсткие?</p>
                <p>Первый способ — заглянуть в документацию, как уже было показано в видео. Например, упомянутый конструктор вектора <a href="https://en.cppreference.com/w/cpp/container/vector/vector" target="_blank" rel="noopener nofollow">выглядит</a>                    следующим образом:</p>
                <pre contenteditable="false" data-language="c_cpp" style="opacity: 1;" tabindex="0"><div><div aria-label="Блок кода: нажмите клавишу Escape, чтобы выйти из блока кода" role="textbox" tabindex="-1" class="rc-CodeBlock code-container ace_editor ace-tomorrow" style="height: 42px;"><textarea class="ace_text-input" wrap="off" autocorrect="off" autocapitalize="off" spellcheck="false" style="opacity: 0; left: 340.902px; top: 28px; height: 14px; width: 6.59781px;" role="presentation" aria-hidden="true" tabindex="-1" aria-label="Нажмите клавишу Escape, чтобы выйти из режима редактирования кода"></textarea><div class="ace_gutter"><div class="ace_layer ace_gutter-layer ace_folding-enabled" style="margin-top: 0px; height: 70px; width: 40px;"><div class="ace_gutter-cell " style="height: 14px;">1</div><div class="ace_gutter-cell " style="height: 14px;">2</div><div class="ace_gutter-cell " style="height: 14px;">3</div></div><div class="ace_gutter-active-line" style="top: 28px; height: 14px;"></div></div><div class="ace_scroller" style="left: 40px; right: 0px; bottom: 0px;"><div class="ace_content" style="margin-top: 0px; width: 796px; height: 70px; margin-left: 0px;"><div class="ace_layer ace_print-margin-layer"><div class="ace_print-margin" style="left: 531.825px; visibility: visible;"></div></div><div class="ace_layer ace_marker-layer"></div><div class="ace_layer ace_text-layer" style="padding: 0px 4px;"><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px"><span class="ace_storage ace_type">template</span><span class="ace_keyword ace_operator">&lt;</span><span class="ace_storage ace_type">class</span> <span class="ace_identifier">InputIt</span><span class="ace_keyword ace_operator">&gt;</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px"><span class="ace_identifier">vector</span><span class="ace_paren ace_lparen">(</span><span class="ace_identifier">InputIt</span> <span class="ace_identifier">first</span><span class="ace_punctuation ace_operator">,</span> <span class="ace_identifier">InputIt</span> <span class="ace_identifier">last</span><span class="ace_punctuation ace_operator">,</span> </div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px">       <span class="ace_storage ace_modifier">const</span> <span class="ace_identifier">Allocator</span><span class="ace_keyword ace_operator">&amp;</span> <span class="ace_identifier">alloc</span> <span class="ace_keyword ace_operator">=</span> <span class="ace_identifier">Allocator</span><span class="ace_paren ace_lparen">(</span><span class="ace_paren ace_rparen">))</span><span class="ace_punctuation ace_operator">;</span></div></div></div><div class="ace_layer ace_marker-layer"></div><div class="ace_layer ace_cursor-layer ace_hidden-cursors"><div class="ace_cursor" style="left: 300.902px; top: 28px; width: 6.59781px; height: 14px;"></div></div></div></div><div class="ace_scrollbar ace_scrollbar-v" style="display: none; width: 20px; bottom: 0px;"><div class="ace_scrollbar-inner" style="width: 20px; height: 42px;"></div></div><div class="ace_scrollbar ace_scrollbar-h" style="display: none; height: 20px; left: 40px; right: 0px;"><div class="ace_scrollbar-inner" style="height: 20px; width: 796px;"></div></div><div style="height: auto; width: auto; top: 0px; left: 0px; visibility: hidden; position: absolute; white-space: pre; font: inherit; overflow: hidden;"><div style="height: auto; width: auto; top: 0px; left: 0px; visibility: hidden; position: absolute; white-space: pre; font: inherit; overflow: visible;"></div><div style="height: auto; width: auto; top: 0px; left: 0px; visibility: hidden; position: absolute; white-space: pre; font-style: inherit; font-variant: inherit; font-stretch: inherit; font-size: inherit; line-height: inherit; font-family: inherit; overflow: visible;">XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</div></div></div></div></pre>
                <p>Не обращайте внимания на аллокатор: здесь достаточно заметить, что тип итератора (шаблонный параметр функции) — InputIt.</p>
                <p>Второй способ — опираясь на своё представление о реализации этой функции, оценить, что именно требуется от итераторов. Рассмотрим, например, уже известные вам алгоритмы count и count_if, вычисляющие количество элементов в заданном наборе,
                    удовлетворяющих некоторому условию. Понятно, что их можно реализовать предельно просто, с помощью лишь одного прохода по данному диапазону. Эта догадка подтверждается <a href="https://en.cppreference.com/w/cpp/algorithm/count" target="_blank"
                        rel="noopener nofollow">документацией</a>: как заветным InputIt в заголовках функций, так и секцией «Possible implementation», в которой приведена возможная реализация этой функции и ссылки на её настоящую реализацию в стандартных
                    библиотеках.
                </p>
                <p>Иногда построение подобных догадок требует более углублённого знания алгоритмов и структур данных. Так, например, может показаться неочевидным, что <a href="https://en.cppreference.com/w/cpp/algorithm/merge" target="_blank" rel="noopener nofollow">функция merge</a>,
                    сливающая два отсортированных диапазона в один, требует на входе лишь входные итераторы. И всё же всегда можно заглянуть в документацию или даже просто попробовать скомпилировать нужный код, а параллельно развивать интуицию и знание
                    алгоритмов. Но имейте в виду: не всегда одна лишь компилируемость функции для некоторых итераторов означает, что она будет корректно работать. Соответствующий пример будет рассмотрен ниже.</p>
                <p><strong>Полный список требований</strong> к input-итераторам находится <a href="https://en.cppreference.com/w/cpp/named_req/InputIterator" target="_blank" rel="noopener nofollow">здесь</a>.</p>
                <h2></h2>
                <h2>Выходные (output) итераторы</h2>
                <p>Напомним, как использовался выходной итератор d_first в реализации функции copy:</p>
                <pre contenteditable="false" data-language="c_cpp" style="opacity: 1;" tabindex="0"><div><div aria-label="Блок кода: нажмите клавишу Escape, чтобы выйти из блока кода" role="textbox" tabindex="-1" class="rc-CodeBlock code-container ace_editor ace-tomorrow" style="height: 126px;"><textarea class="ace_text-input" wrap="off" autocorrect="off" autocapitalize="off" spellcheck="false" style="opacity: 0; left: 57.5978px; top: 112px; height: 14px; width: 6.59781px;" role="presentation" aria-hidden="true" tabindex="-1" aria-label="Нажмите клавишу Escape, чтобы выйти из режима редактирования кода"></textarea><div class="ace_gutter"><div class="ace_layer ace_gutter-layer ace_folding-enabled" style="margin-top: 0px; height: 154px; width: 47px;"><div class="ace_gutter-cell " style="height: 14px;">1</div><div class="ace_gutter-cell " style="height: 14px;">2</div><div class="ace_gutter-cell " style="height: 14px;">3</div><div class="ace_gutter-cell " style="height: 14px;">4<span class="ace_fold-widget ace_start ace_open" style="height: 14px;"></span></div><div class="ace_gutter-cell " style="height: 14px;">5<span class="ace_fold-widget ace_start ace_open" style="height: 14px;"></span></div><div class="ace_gutter-cell " style="height: 14px;">6</div><div class="ace_gutter-cell " style="height: 14px;">7</div><div class="ace_gutter-cell " style="height: 14px;">8</div><div class="ace_gutter-cell " style="height: 14px;">9</div></div><div class="ace_gutter-active-line" style="top: 112px; height: 14px;"></div></div><div class="ace_scroller" style="left: 47px; right: 0px; bottom: 0px;"><div class="ace_content" style="margin-top: 0px; width: 789px; height: 154px; margin-left: 0px;"><div class="ace_layer ace_print-margin-layer"><div class="ace_print-margin" style="left: 531.825px; visibility: visible;"></div></div><div class="ace_layer ace_marker-layer"><div class="ace_bracket ace_start ace_br15" style="height:14px;width:6.5978125px;top:42px;left:4px;"></div></div><div class="ace_layer ace_text-layer" style="padding: 0px 4px;"><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px"><span class="ace_storage ace_type">template</span><span class="ace_keyword ace_operator">&lt;</span><span class="ace_storage ace_modifier">typename</span> <span class="ace_identifier">InputIt</span><span class="ace_punctuation ace_operator">,</span> <span class="ace_storage ace_modifier">typename</span> <span class="ace_identifier">OutputIt</span><span class="ace_keyword ace_operator">&gt;</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px"><span class="ace_identifier">OutputIt</span> <span class="ace_identifier">copy</span><span class="ace_paren ace_lparen">(</span><span class="ace_identifier">InputIt</span> <span class="ace_identifier">first</span><span class="ace_punctuation ace_operator">,</span> <span class="ace_identifier">InputIt</span> <span class="ace_identifier">last</span><span class="ace_punctuation ace_operator">,</span> </div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px">              <span class="ace_identifier">OutputIt</span> <span class="ace_identifier">d_first</span><span class="ace_paren ace_rparen">)</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px"><span class="ace_paren ace_lparen">{</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px">    <span class="ace_keyword ace_control">while</span> <span class="ace_paren ace_lparen">(</span><span class="ace_identifier">first</span> <span class="ace_keyword ace_operator">!=</span> <span class="ace_identifier">last</span><span class="ace_paren ace_rparen">)</span> <span class="ace_paren ace_lparen">{</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px">        <span class="ace_keyword ace_operator">*</span><span class="ace_identifier">d_first</span><span class="ace_keyword ace_operator">++</span> <span class="ace_keyword ace_operator">=</span> <span class="ace_keyword ace_operator">*</span><span class="ace_identifier">first</span><span class="ace_keyword ace_operator">++</span><span class="ace_punctuation ace_operator">;</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px">    <span class="ace_paren ace_rparen">}</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px">    <span class="ace_keyword ace_control">return</span> <span class="ace_identifier">d_first</span><span class="ace_punctuation ace_operator">;</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px"><span class="ace_paren ace_rparen">}</span></div></div></div><div class="ace_layer ace_marker-layer"></div><div class="ace_layer ace_cursor-layer ace_hidden-cursors"><div class="ace_cursor" style="left: 10.5978px; top: 112px; width: 6.59781px; height: 14px;"></div></div></div></div><div class="ace_scrollbar ace_scrollbar-v" style="display: none; width: 20px; bottom: 0px;"><div class="ace_scrollbar-inner" style="width: 20px; height: 126px;"></div></div><div class="ace_scrollbar ace_scrollbar-h" style="display: none; height: 20px; left: 47px; right: 0px;"><div class="ace_scrollbar-inner" style="height: 20px; width: 789px;"></div></div><div style="height: auto; width: auto; top: 0px; left: 0px; visibility: hidden; position: absolute; white-space: pre; font: inherit; overflow: hidden;"><div style="height: auto; width: auto; top: 0px; left: 0px; visibility: hidden; position: absolute; white-space: pre; font: inherit; overflow: visible;"></div><div style="height: auto; width: auto; top: 0px; left: 0px; visibility: hidden; position: absolute; white-space: pre; font-style: inherit; font-variant: inherit; font-stretch: inherit; font-size: inherit; line-height: inherit; font-family: inherit; overflow: visible;">XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</div></div></div></div></pre>
                <p>Отсюда видно, что единственное требование к выходному итератору — уметь принимать очередное значение с помощью конструкции *d_first++ = value. Понятно, что итераторы неконстантных (изменяемых) контейнеров умеют это без каких-либо доработок:
                    *d_first возвращает ссылку на элемент, с помощью которой можно записать новое значение, а оператор ++ действительно перемещает итератор на следующую ячейку памяти.</p>
                <p>Но итераторы хороши своим уровнем абстракции: для того, чтобы складывать куда-то значения, необязательно хранить адрес какой-то ячейки в памяти; достаточно лишь реализовать конструкцию *it++ = value. Это позволяет реализовать уже известные
                    вам back_insert_iterator и insert_iterator (конструируемые с помощью функций back_inserter и inserter), а также <a href="https://en.cppreference.com/w/cpp/iterator/ostream_iterator" target="_blank" rel="noopener nofollow">ostream_iterator</a>                    — итератор вывода в поток.</p>
                <p>Но как это реализовано и можно ли использовать разыменование и инкремент выходного итератора в отрыве от конструкции *it++ = value? Ответ на это легко найти в <a href="https://en.cppreference.com/w/cpp/iterator/back_insert_iterator" target="_blank"
                        rel="noopener nofollow">документации</a>:</p>
                <ul>
                    <li>инкремент итератора не делает <em>ничего;</em></li>
                    <li>разыменование итератора возвращает ссылку <em>на сам итератор;</em></li>
                    <li>зато реализовано присваивание итератору сохраняемого значения, здесь как раз и сосредоточена основная логика.</li>
                </ul>
                <p>Таким образом, для подобных итераторов запись *it++ = value эквивалентна it = value, но при этом первый вариант универсален и работает для всех выходных итераторов, включая, например, итераторы вектора. Не используйте второй вариант: вас
                    не поймут.</p>
                <p>Отдельно отметим, что <strong>выходными не являются</strong> итераторы множеств (set&lt;T&gt;), словарей (map&lt;K, V&gt;) и константных контейнеров (const vector&lt;T&gt;). Это объясняется очень легко: для этих итераторов ссылка *it является
                    константной и потому не допускает запись.</p>
                <p>В предыдущих видео мы уже рассматривали алгоритмы, возвращающие набор значений с помощью выходных итераторов. Обратите внимание, что эти алгоритмы для возврата одного набора принимают один выходной итератор, а не диапазон; поэтому от выходного
                    итератора не требуется возможность сравнения на неравенство. С другой стороны, передаваемый в функцию выходной итератор должен гарантированно уметь принять все переданные в него значения.</p>
                <p><strong>Полный список требований</strong> к output-итераторам находится <a href="https://en.cppreference.com/w/cpp/named_req/OutputIterator" target="_blank" rel="noopener nofollow">здесь</a>.</p>
                <h2></h2>
                <h2>Прямые (forward) итераторы</h2>
                <p>Категория forward-итераторов приближает рассмотренные выше абстракции к итераторам настоящих контейнеров.</p>
                <p>Рассмотрим <a href="https://en.cppreference.com/w/cpp/container/forward_list" target="_blank" rel="noopener nofollow">forward_list</a> (односвязный список) — линейный контейнер, который позволяет проитерироваться по элементам в прямом
                    порядке, но не в обратном и не перескакивая через несколько элементов. Объясняется это тем, что каждый элемент односвязного списка хранится в памяти независимо и «знает» лишь, где находится следующий за ним. Понятно, что итераторы
                    этого контейнера являются входными, а в случае его неконстантности ещё и выходными. Но какими дополнительными преимуществами обладают итераторы списка?</p>
                <ol>
                    <li><em>Многопроходность:</em> поскольку за итератором стоят реально хранящиеся в памяти элементы, ничто не мешает проитерироваться по ним несколько раз.</li>
                    <li><em>Итератор разыменовывается в ссылку,</em> а не во что-то ненастоящее, как было с back_insert_iterator. (Впрочем, существуют forward-итераторы, для которых operator* возвращает результат по значению.)</li>
                    <li><em>Разумное сравнение:</em> благодаря тому, что каждый итератор (кроме, возможно, end) указывает на реальное место в памяти, нет проблем в определении корректного сравнения на равенство и неравенство для любых итераторов <em>одного контейнера.</em></li>
                </ol>
                <p>Это и есть достаточно полный список требований, отличающих прямой итератор от входного. При этом в случае неконстантности ссылки из п. 2 итератор оказывается ещё и выходным.</p>
                <h3></h3>
                <h3>Функции, работающие с forward-итераторами</h3>
                <p>Рассмотренный выше список требований может показаться довольно искусственным: неужели есть алгоритмы, которые принимают forward-итераторы, но не готовы работать с входными? Оказывается, что да, и дело в первую очередь в многопроходности.</p>
                <p>В качестве примера можно привести следующие алгоритмы, не изменяющие переданный диапазон: <a href="https://en.cppreference.com/w/cpp/algorithm/find_first_of" target="_blank" rel="noopener nofollow">find_first_of</a>, <a href="https://en.cppreference.com/w/cpp/algorithm/find_end"
                        target="_blank" rel="noopener nofollow">find_end</a>, <a href="https://en.cppreference.com/w/cpp/algorithm/search" target="_blank" rel="noopener nofollow">search</a>, <a href="https://en.cppreference.com/w/cpp/algorithm/adjacent_find"
                        target="_blank" rel="noopener nofollow">adjacent_find</a>. Сигнатура простейшего варианта функции find_first_of выглядит следующим образом:</p>
                <pre contenteditable="false" data-language="c_cpp" style="opacity: 1;" tabindex="0"><div><div aria-label="Блок кода: нажмите клавишу Escape, чтобы выйти из блока кода" role="textbox" tabindex="-1" class="rc-CodeBlock code-container ace_editor ace-tomorrow" style="height: 42px;"><textarea class="ace_text-input" wrap="off" autocorrect="off" autocapitalize="off" spellcheck="false" style="opacity: 0; left: 433.271px; top: 28px; height: 14px; width: 6.59781px;" role="presentation" aria-hidden="true" tabindex="-1" aria-label="Нажмите клавишу Escape, чтобы выйти из режима редактирования кода"></textarea><div class="ace_gutter"><div class="ace_layer ace_gutter-layer ace_folding-enabled" style="margin-top: 0px; height: 70px; width: 40px;"><div class="ace_gutter-cell " style="height: 14px;">1</div><div class="ace_gutter-cell " style="height: 14px;">2</div><div class="ace_gutter-cell " style="height: 14px;">3</div></div><div class="ace_gutter-active-line" style="top: 28px; height: 14px;"></div></div><div class="ace_scroller" style="left: 40px; right: 0px; bottom: 0px;"><div class="ace_content" style="margin-top: 0px; width: 796px; height: 70px; margin-left: 0px;"><div class="ace_layer ace_print-margin-layer"><div class="ace_print-margin" style="left: 531.825px; visibility: visible;"></div></div><div class="ace_layer ace_marker-layer"></div><div class="ace_layer ace_text-layer" style="padding: 0px 4px;"><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px"><span class="ace_storage ace_type">template</span><span class="ace_keyword ace_operator">&lt;</span><span class="ace_storage ace_modifier">typename</span> <span class="ace_identifier">InputIt</span><span class="ace_punctuation ace_operator">,</span> <span class="ace_storage ace_modifier">typename</span> <span class="ace_identifier">ForwardIt</span><span class="ace_keyword ace_operator">&gt;</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px"><span class="ace_identifier">InputIt</span> <span class="ace_identifier">find_first_of</span><span class="ace_paren ace_lparen">(</span><span class="ace_identifier">InputIt</span> <span class="ace_identifier">first</span><span class="ace_punctuation ace_operator">,</span> <span class="ace_identifier">InputIt</span> <span class="ace_identifier">last</span><span class="ace_punctuation ace_operator">,</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px">                      <span class="ace_identifier">ForwardIt</span> <span class="ace_identifier">s_first</span><span class="ace_punctuation ace_operator">,</span> <span class="ace_identifier">ForwardIt</span> <span class="ace_identifier">s_last</span><span class="ace_paren ace_rparen">)</span><span class="ace_punctuation ace_operator">;</span></div></div></div><div class="ace_layer ace_marker-layer"></div><div class="ace_layer ace_cursor-layer ace_hidden-cursors"><div class="ace_cursor" style="left: 393.271px; top: 28px; width: 6.59781px; height: 14px;"></div></div></div></div><div class="ace_scrollbar ace_scrollbar-v" style="display: none; width: 20px; bottom: 0px;"><div class="ace_scrollbar-inner" style="width: 20px; height: 42px;"></div></div><div class="ace_scrollbar ace_scrollbar-h" style="display: none; height: 20px; left: 40px; right: 0px;"><div class="ace_scrollbar-inner" style="height: 20px; width: 796px;"></div></div><div style="height: auto; width: auto; top: 0px; left: 0px; visibility: hidden; position: absolute; white-space: pre; font: inherit; overflow: hidden;"><div style="height: auto; width: auto; top: 0px; left: 0px; visibility: hidden; position: absolute; white-space: pre; font: inherit; overflow: visible;"></div><div style="height: auto; width: auto; top: 0px; left: 0px; visibility: hidden; position: absolute; white-space: pre; font-style: inherit; font-variant: inherit; font-stretch: inherit; font-size: inherit; line-height: inherit; font-family: inherit; overflow: visible;">XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</div></div></div></div></pre>
                <p>В результате возвращается первый из элементов [first, last), равный одному из элементов [s_first, s_last). Понятно, что самый простой способ это реализовать — для каждого элемента первого диапазона сравнить его с каждым элементов второго.
                    И действительно, код этой функции по сути эквивалентен такому:</p>
                <pre contenteditable="false" data-language="c_cpp" style="opacity: 1;" tabindex="0"><div><div aria-label="Блок кода: нажмите клавишу Escape, чтобы выйти из блока кода" role="textbox" tabindex="-1" class="rc-CodeBlock code-container ace_editor ace-tomorrow" style="height: 84px;"><textarea class="ace_text-input" wrap="off" autocorrect="off" autocapitalize="off" spellcheck="false" style="opacity: 0; left: 57.1956px; top: 70px; height: 14px; width: 6.59781px;" role="presentation" aria-hidden="true" tabindex="-1" aria-label="Нажмите клавишу Escape, чтобы выйти из режима редактирования кода"></textarea><div class="ace_gutter"><div class="ace_layer ace_gutter-layer ace_folding-enabled" style="margin-top: 0px; height: 112px; width: 40px;"><div class="ace_gutter-cell " style="height: 14px;">1</div><div class="ace_gutter-cell " style="height: 14px;">2</div><div class="ace_gutter-cell " style="height: 14px;">3<span class="ace_fold-widget ace_start ace_open" style="height: 14px;"></span></div><div class="ace_gutter-cell " style="height: 14px;">4</div><div class="ace_gutter-cell " style="height: 14px;">5</div><div class="ace_gutter-cell " style="height: 14px;">6</div></div><div class="ace_gutter-active-line" style="top: 70px; height: 14px;"></div></div><div class="ace_scroller" style="left: 40px; right: 0px; bottom: 0px;"><div class="ace_content" style="margin-top: 0px; width: 796px; height: 112px; margin-left: 0px;"><div class="ace_layer ace_print-margin-layer"><div class="ace_print-margin" style="left: 531.825px; visibility: visible;"></div></div><div class="ace_layer ace_marker-layer"></div><div class="ace_layer ace_text-layer" style="padding: 0px 4px;"><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px"><span class="ace_keyword ace_control">return</span> <span class="ace_identifier">find_if</span><span class="ace_paren ace_lparen">(</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px">    <span class="ace_identifier">first</span><span class="ace_punctuation ace_operator">,</span> <span class="ace_identifier">last</span><span class="ace_punctuation ace_operator">,</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px">    <span class="ace_paren ace_lparen">[</span><span class="ace_identifier">s_first</span><span class="ace_punctuation ace_operator">,</span> <span class="ace_identifier">s_last</span><span class="ace_paren ace_rparen">]</span><span class="ace_paren ace_lparen">(</span><span class="ace_storage ace_modifier">const</span> <span class="ace_storage ace_type">auto</span><span class="ace_keyword ace_operator">&amp;</span> <span class="ace_identifier">value</span><span class="ace_paren ace_rparen">)</span> <span class="ace_paren ace_lparen">{</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px">      <span class="ace_keyword ace_control">return</span> <span class="ace_identifier">find</span><span class="ace_paren ace_lparen">(</span><span class="ace_identifier">s_first</span><span class="ace_punctuation ace_operator">,</span> <span class="ace_identifier">s_last</span><span class="ace_punctuation ace_operator">,</span> <span class="ace_identifier">value</span><span class="ace_paren ace_rparen">)</span> <span class="ace_keyword ace_operator">!=</span> <span class="ace_identifier">s_last</span><span class="ace_punctuation ace_operator">;</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px">    <span class="ace_paren ace_rparen">}</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px"><span class="ace_paren ace_rparen">)</span><span class="ace_punctuation ace_operator">;</span></div></div></div><div class="ace_layer ace_marker-layer"></div><div class="ace_layer ace_cursor-layer ace_hidden-cursors"><div class="ace_cursor" style="left: 17.1956px; top: 70px; width: 6.59781px; height: 14px;"></div></div></div></div><div class="ace_scrollbar ace_scrollbar-v" style="display: none; width: 20px; bottom: 0px;"><div class="ace_scrollbar-inner" style="width: 20px; height: 84px;"></div></div><div class="ace_scrollbar ace_scrollbar-h" style="display: none; height: 20px; left: 40px; right: 0px;"><div class="ace_scrollbar-inner" style="height: 20px; width: 796px;"></div></div><div style="height: auto; width: auto; top: 0px; left: 0px; visibility: hidden; position: absolute; white-space: pre; font: inherit; overflow: hidden;"><div style="height: auto; width: auto; top: 0px; left: 0px; visibility: hidden; position: absolute; white-space: pre; font: inherit; overflow: visible;"></div><div style="height: auto; width: auto; top: 0px; left: 0px; visibility: hidden; position: absolute; white-space: pre; font-style: inherit; font-variant: inherit; font-stretch: inherit; font-size: inherit; line-height: inherit; font-family: inherit; overflow: visible;">XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</div></div></div></div></pre>
                <p>Такой код не требует многопроходности от первого диапазона, но для второго она необходима, так как find для него запускается несколько раз.</p>
                <p>Похожая история имеет место для алгоритма <a href="https://en.cppreference.com/w/cpp/algorithm/search" target="_blank" rel="noopener nofollow">search</a>: search(first, last, s_first, s_last) ищёт первое вхождение [s_first, s_last) в [first,
                    last), примеряя один полуинтервал ко второму во всевозможных позициях; соответственно, многопроходность требуется от обоих диапазонов. <a href="https://en.cppreference.com/w/cpp/algorithm/find_end" target="_blank" rel="noopener nofollow">find_end</a>,
                    в свою очередь, решает очень похожую задачу и с большой вероятностью использует search</p>
                <p>adjacent_find</p>
                <p>С <a href="https://en.cppreference.com/w/cpp/algorithm/adjacent_find" target="_blank" rel="noopener nofollow">adjacent_find</a> дело обстоит несколько сложнее:</p>
                <pre contenteditable="false" data-language="c_cpp" style="opacity: 1;" tabindex="0"><div><div aria-label="Блок кода: нажмите клавишу Escape, чтобы выйти из блока кода" role="textbox" tabindex="-1" class="rc-CodeBlock code-container ace_editor ace-tomorrow" style="height: 42px;"><textarea class="ace_text-input" wrap="off" autocorrect="off" autocapitalize="off" spellcheck="false" style="opacity: 0; left: 420.075px; top: 14px; height: 14px; width: 6.59781px;" role="presentation" aria-hidden="true" tabindex="-1" aria-label="Нажмите клавишу Escape, чтобы выйти из режима редактирования кода"></textarea><div class="ace_gutter"><div class="ace_layer ace_gutter-layer ace_folding-enabled" style="margin-top: 0px; height: 70px; width: 40px;"><div class="ace_gutter-cell " style="height: 14px;">1</div><div class="ace_gutter-cell " style="height: 14px;">2</div></div><div class="ace_gutter-active-line" style="top: 14px; height: 14px;"></div></div><div class="ace_scroller" style="left: 40px; right: 0px; bottom: 0px;"><div class="ace_content" style="margin-top: 0px; width: 796px; height: 70px; margin-left: 0px;"><div class="ace_layer ace_print-margin-layer"><div class="ace_print-margin" style="left: 531.825px; visibility: visible;"></div></div><div class="ace_layer ace_marker-layer"></div><div class="ace_layer ace_text-layer" style="padding: 0px 4px;"><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px"><span class="ace_storage ace_type">template</span><span class="ace_keyword ace_operator">&lt;</span><span class="ace_storage ace_modifier">typename</span> <span class="ace_identifier">ForwardIt</span><span class="ace_keyword ace_operator">&gt;</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px"><span class="ace_identifier">ForwardIt</span> <span class="ace_identifier">adjacent_find</span><span class="ace_paren ace_lparen">(</span><span class="ace_identifier">ForwardIt</span> <span class="ace_identifier">first</span><span class="ace_punctuation ace_operator">,</span> <span class="ace_identifier">ForwardIt</span> <span class="ace_identifier">last</span><span class="ace_paren ace_rparen">)</span><span class="ace_punctuation ace_operator">;</span></div></div></div><div class="ace_layer ace_marker-layer"></div><div class="ace_layer ace_cursor-layer ace_hidden-cursors"><div class="ace_cursor" style="left: 380.075px; top: 14px; width: 6.59781px; height: 14px;"></div></div></div></div><div class="ace_scrollbar ace_scrollbar-v" style="display: none; width: 20px; bottom: 0px;"><div class="ace_scrollbar-inner" style="width: 20px; height: 28px;"></div></div><div class="ace_scrollbar ace_scrollbar-h" style="display: none; height: 20px; left: 40px; right: 0px;"><div class="ace_scrollbar-inner" style="height: 20px; width: 796px;"></div></div><div style="height: auto; width: auto; top: 0px; left: 0px; visibility: hidden; position: absolute; white-space: pre; font: inherit; overflow: hidden;"><div style="height: auto; width: auto; top: 0px; left: 0px; visibility: hidden; position: absolute; white-space: pre; font: inherit; overflow: visible;"></div><div style="height: auto; width: auto; top: 0px; left: 0px; visibility: hidden; position: absolute; white-space: pre; font-style: inherit; font-variant: inherit; font-stretch: inherit; font-size: inherit; line-height: inherit; font-family: inherit; overflow: visible;">XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</div></div></div></div></pre>
                <p>Этот алгоритм ищет совпадающие соседние элементы. Неужели это нельзя сделать за один проход и ослабить требования на параметры до input-итераторов? Чтобы разобраться, рассмотрим возможную реализацию, которая приводится в документации:</p>
                <pre contenteditable="false" data-language="c_cpp" style="opacity: 1;" tabindex="0"><div><div aria-label="Блок кода: нажмите клавишу Escape, чтобы выйти из блока кода" role="textbox" tabindex="-1" class="rc-CodeBlock code-container ace_editor ace-tomorrow" style="height: 196px;"><textarea class="ace_text-input" wrap="off" autocorrect="off" autocapitalize="off" spellcheck="false" style="opacity: 0; left: 57.5978px; top: 182px; height: 14px; width: 6.59781px;" role="presentation" aria-hidden="true" tabindex="-1" aria-label="Нажмите клавишу Escape, чтобы выйти из режима редактирования кода"></textarea><div class="ace_gutter"><div class="ace_layer ace_gutter-layer ace_folding-enabled" style="margin-top: 0px; height: 224px; width: 47px;"><div class="ace_gutter-cell " style="height: 14px;">1</div><div class="ace_gutter-cell " style="height: 14px;">2<span class="ace_fold-widget ace_start ace_open" style="height: 14px;"></span></div><div class="ace_gutter-cell " style="height: 14px;">3<span class="ace_fold-widget ace_start ace_open" style="height: 14px;"></span></div><div class="ace_gutter-cell " style="height: 14px;">4</div><div class="ace_gutter-cell " style="height: 14px;">5</div><div class="ace_gutter-cell " style="height: 14px;">6</div><div class="ace_gutter-cell " style="height: 14px;">7</div><div class="ace_gutter-cell " style="height: 14px;">8<span class="ace_fold-widget ace_start ace_open" style="height: 14px;"></span></div><div class="ace_gutter-cell " style="height: 14px;">9<span class="ace_fold-widget ace_start ace_open" style="height: 14px;"></span></div><div class="ace_gutter-cell " style="height: 14px;">10</div><div class="ace_gutter-cell " style="height: 14px;">11</div><div class="ace_gutter-cell " style="height: 14px;">12</div><div class="ace_gutter-cell " style="height: 14px;">13</div><div class="ace_gutter-cell " style="height: 14px;">14</div></div><div class="ace_gutter-active-line" style="top: 182px; height: 14px;"></div></div><div class="ace_scroller" style="left: 47px; right: 0px; bottom: 0px;"><div class="ace_content" style="margin-top: 0px; width: 789px; height: 224px; margin-left: 0px;"><div class="ace_layer ace_print-margin-layer"><div class="ace_print-margin" style="left: 531.825px; visibility: visible;"></div></div><div class="ace_layer ace_marker-layer"><div class="ace_bracket ace_start ace_br15" style="height:14px;width:6.5978125px;top:14px;left:380.0753125px;"></div></div><div class="ace_layer ace_text-layer" style="padding: 0px 4px;"><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px"><span class="ace_storage ace_type">template</span><span class="ace_keyword ace_operator">&lt;</span><span class="ace_storage ace_modifier">typename</span> <span class="ace_identifier">ForwardIt</span><span class="ace_keyword ace_operator">&gt;</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px"><span class="ace_identifier">ForwardIt</span> <span class="ace_identifier">adjacent_find</span><span class="ace_paren ace_lparen">(</span><span class="ace_identifier">ForwardIt</span> <span class="ace_identifier">first</span><span class="ace_punctuation ace_operator">,</span> <span class="ace_identifier">ForwardIt</span> <span class="ace_identifier">last</span><span class="ace_paren ace_rparen">)</span> <span class="ace_paren ace_lparen">{</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px">    <span class="ace_keyword ace_control">if</span> <span class="ace_paren ace_lparen">(</span><span class="ace_identifier">first</span> <span class="ace_keyword ace_operator">==</span> <span class="ace_identifier">last</span><span class="ace_paren ace_rparen">)</span> <span class="ace_paren ace_lparen">{</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px">        <span class="ace_keyword ace_control">return</span> <span class="ace_identifier">last</span><span class="ace_punctuation ace_operator">;</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px">    <span class="ace_paren ace_rparen">}</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px">    <span class="ace_identifier">ForwardIt</span> <span class="ace_identifier">next</span> <span class="ace_keyword ace_operator">=</span> <span class="ace_identifier">first</span><span class="ace_punctuation ace_operator">;</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px">    <span class="ace_keyword ace_operator">++</span><span class="ace_identifier">next</span><span class="ace_punctuation ace_operator">;</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px">    <span class="ace_keyword ace_control">for</span> <span class="ace_paren ace_lparen">(</span><span class="ace_punctuation ace_operator">;</span> <span class="ace_identifier">next</span> <span class="ace_keyword ace_operator">!=</span> <span class="ace_identifier">last</span><span class="ace_punctuation ace_operator">;</span> <span class="ace_keyword ace_operator">++</span><span class="ace_identifier">next</span><span class="ace_punctuation ace_operator">,</span> <span class="ace_keyword ace_operator">++</span><span class="ace_identifier">first</span><span class="ace_paren ace_rparen">)</span> <span class="ace_paren ace_lparen">{</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px">        <span class="ace_keyword ace_control">if</span> <span class="ace_paren ace_lparen">(</span><span class="ace_keyword ace_operator">*</span><span class="ace_identifier">first</span> <span class="ace_keyword ace_operator">==</span> <span class="ace_keyword ace_operator">*</span><span class="ace_identifier">next</span><span class="ace_paren ace_rparen">)</span> <span class="ace_paren ace_lparen">{</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px">            <span class="ace_keyword ace_control">return</span> <span class="ace_identifier">first</span><span class="ace_punctuation ace_operator">;</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px">        <span class="ace_paren ace_rparen">}</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px">    <span class="ace_paren ace_rparen">}</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px">    <span class="ace_keyword ace_control">return</span> <span class="ace_identifier">last</span><span class="ace_punctuation ace_operator">;</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px"><span class="ace_paren ace_rparen">}</span></div></div></div><div class="ace_layer ace_marker-layer"></div><div class="ace_layer ace_cursor-layer ace_hidden-cursors"><div class="ace_cursor" style="left: 10.5978px; top: 182px; width: 6.59781px; height: 14px;"></div></div></div></div><div class="ace_scrollbar ace_scrollbar-v" style="display: none; width: 20px; bottom: 0px;"><div class="ace_scrollbar-inner" style="width: 20px; height: 196px;"></div></div><div class="ace_scrollbar ace_scrollbar-h" style="display: none; height: 20px; left: 47px; right: 0px;"><div class="ace_scrollbar-inner" style="height: 20px; width: 789px;"></div></div><div style="height: auto; width: auto; top: 0px; left: 0px; visibility: hidden; position: absolute; white-space: pre; font: inherit; overflow: hidden;"><div style="height: auto; width: auto; top: 0px; left: 0px; visibility: hidden; position: absolute; white-space: pre; font: inherit; overflow: visible;"></div><div style="height: auto; width: auto; top: 0px; left: 0px; visibility: hidden; position: absolute; white-space: pre; font-style: inherit; font-variant: inherit; font-stretch: inherit; font-size: inherit; line-height: inherit; font-family: inherit; overflow: visible;">XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</div></div></div></div></pre>
                <p>Видите ли вы, где этот код требует многопроходности?</p>
                <p>По сути он дважды итерируется по диапазону: сначала с помощью next, а сразу за ним — first. Найдите тест, на котором эта функция будет некорректно работать для istream-итераторов. Проверьте, работает ли на этом тесте adjacent_find из стандартной
                    библиотеки.
                </p>
                <p>Перейдём на некоторое время в более формальную плоскость и разберёмся, в каких именно требованиях выражается многопроходность. Их можно найти <a href="https://en.cppreference.com/w/cpp/named_req/ForwardIterator" target="_blank" rel="noopener nofollow">в статье про ForwardIterator</a>,
                    в разделе «Multipass guarantee». Какие из этих свойств действительно необходимы для корректной работы последнего примера?</p>
                <ol>
                    <li>Корректность сравнения на == любых итераторов. В последнем примере <strong>не нужна:</strong> сравнение происходит только с last.</li>
                    <li>Безопасность записи нового значения. <strong>Не актуально,</strong> так как adjacent_find не изменяет элементы.</li>
                    <li>Устойчивость *it к увеличению копии it. <strong>Нужна,</strong> и для istream-итератора выполняется благодаря сохранению текущего элемента.</li>
                    <li>Выполнение ++it1 == ++it2 для равных итераторов it1 и it2. С одной стороны, как уже было отмечено в п. 1, сравнение итераторов в этом коде не очень нужно, с другой — явно <strong>ожидается,</strong> что при увеличении обоих итераторов
                        first и next с отставанием в 1 шаг будет получаться одинаковое значение. Таким образом, в сочетании с п. 1 получаем свойство, которое <strong>нужно и не выполняется</strong> для istream-итераторов.</li>
                </ol>
                <p>Можно ли реализовать adjacent_find без одновременного прохода двумя итераторами? Да, и такой код можно увидеть <a href="https://github.com/gcc-mirror/gcc/blob/d9375e490072d1aae73a93949aa158fcd2a27018/libstdc%2B%2B-v3/include/bits/stl_algo.h#L945"
                        target="_blank" rel="noopener nofollow">в реализации этого алгоритма в стандартной библиотеке g++</a> (для краткости приведена версия без использования предиката):</p>
                <pre contenteditable="false" data-language="c_cpp" style="opacity: 1;" tabindex="0"><div><div aria-label="Блок кода: нажмите клавишу Escape, чтобы выйти из блока кода" role="textbox" tabindex="-1" class="rc-CodeBlock code-container ace_editor ace-tomorrow" style="height: 196px;"><textarea class="ace_text-input" wrap="off" autocorrect="off" autocapitalize="off" spellcheck="false" style="opacity: 0; left: 57.5978px; top: 182px; height: 14px; width: 6.59781px;" role="presentation" aria-hidden="true" tabindex="-1" aria-label="Нажмите клавишу Escape, чтобы выйти из режима редактирования кода"></textarea><div class="ace_gutter"><div class="ace_layer ace_gutter-layer ace_folding-enabled" style="margin-top: 0px; height: 224px; width: 47px;"><div class="ace_gutter-cell " style="height: 14px;">1</div><div class="ace_gutter-cell " style="height: 14px;">2<span class="ace_fold-widget ace_start ace_open" style="height: 14px;"></span></div><div class="ace_gutter-cell " style="height: 14px;">3<span class="ace_fold-widget ace_start ace_open" style="height: 14px;"></span></div><div class="ace_gutter-cell " style="height: 14px;">4</div><div class="ace_gutter-cell " style="height: 14px;">5</div><div class="ace_gutter-cell " style="height: 14px;">6</div><div class="ace_gutter-cell " style="height: 14px;">7<span class="ace_fold-widget ace_start ace_open" style="height: 14px;"></span></div><div class="ace_gutter-cell " style="height: 14px;">8<span class="ace_fold-widget ace_start ace_open" style="height: 14px;"></span></div><div class="ace_gutter-cell " style="height: 14px;">9</div><div class="ace_gutter-cell " style="height: 14px;">10</div><div class="ace_gutter-cell " style="height: 14px;">11</div><div class="ace_gutter-cell " style="height: 14px;">12</div><div class="ace_gutter-cell " style="height: 14px;">13</div><div class="ace_gutter-cell " style="height: 14px;">14</div></div><div class="ace_gutter-active-line" style="top: 182px; height: 14px;"></div></div><div class="ace_scroller" style="left: 47px; right: 0px; bottom: 0px;"><div class="ace_content" style="margin-top: 0px; width: 789px; height: 224px; margin-left: 0px;"><div class="ace_layer ace_print-margin-layer"><div class="ace_print-margin" style="left: 531.825px; visibility: visible;"></div></div><div class="ace_layer ace_marker-layer"><div class="ace_bracket ace_start ace_br15" style="height:14px;width:6.5978125px;top:14px;left:498.8359375px;"></div></div><div class="ace_layer ace_text-layer" style="padding: 0px 4px;"><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px"><span class="ace_storage ace_type">template</span><span class="ace_keyword ace_operator">&lt;</span><span class="ace_storage ace_modifier">typename</span> <span class="ace_identifier">ForwardIterator</span><span class="ace_keyword ace_operator">&gt;</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px"><span class="ace_identifier">ForwardIterator</span> <span class="ace_identifier">adjacent_find</span><span class="ace_paren ace_lparen">(</span><span class="ace_identifier">ForwardIterator</span> <span class="ace_identifier">first</span><span class="ace_punctuation ace_operator">,</span> <span class="ace_identifier">ForwardIterator</span> <span class="ace_identifier">last</span><span class="ace_paren ace_rparen">)</span> <span class="ace_paren ace_lparen">{</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px">  <span class="ace_keyword ace_control">if</span> <span class="ace_paren ace_lparen">(</span><span class="ace_identifier">first</span> <span class="ace_keyword ace_operator">==</span> <span class="ace_identifier">last</span><span class="ace_paren ace_rparen">)</span> <span class="ace_paren ace_lparen">{</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px">    <span class="ace_keyword ace_control">return</span> <span class="ace_identifier">last</span><span class="ace_punctuation ace_operator">;</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px">  <span class="ace_paren ace_rparen">}</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px">  <span class="ace_identifier">ForwardIterator</span> <span class="ace_identifier">next</span> <span class="ace_keyword ace_operator">=</span> <span class="ace_identifier">first</span><span class="ace_punctuation ace_operator">;</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px">  <span class="ace_keyword ace_control">while</span> <span class="ace_paren ace_lparen">(</span><span class="ace_keyword ace_operator">++</span><span class="ace_identifier">next</span> <span class="ace_keyword ace_operator">!=</span> <span class="ace_identifier">last</span><span class="ace_paren ace_rparen">)</span> <span class="ace_paren ace_lparen">{</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px">    <span class="ace_keyword ace_control">if</span> <span class="ace_paren ace_lparen">(</span><span class="ace_keyword ace_operator">*</span><span class="ace_identifier">first</span> <span class="ace_keyword ace_operator">==</span> <span class="ace_keyword ace_operator">*</span><span class="ace_identifier">next</span><span class="ace_paren ace_rparen">)</span> <span class="ace_paren ace_lparen">{</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px">      <span class="ace_keyword ace_control">return</span> <span class="ace_identifier">first</span><span class="ace_punctuation ace_operator">;</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px">    <span class="ace_paren ace_rparen">}</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px">    <span class="ace_identifier">first</span> <span class="ace_keyword ace_operator">=</span> <span class="ace_identifier">next</span><span class="ace_punctuation ace_operator">;</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px">  <span class="ace_paren ace_rparen">}</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px">  <span class="ace_keyword ace_control">return</span> <span class="ace_identifier">last</span><span class="ace_punctuation ace_operator">;</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px"><span class="ace_paren ace_rparen">}</span></div></div></div><div class="ace_layer ace_marker-layer"></div><div class="ace_layer ace_cursor-layer ace_hidden-cursors"><div class="ace_cursor" style="left: 10.5978px; top: 182px; width: 6.59781px; height: 14px;"></div></div></div></div><div class="ace_scrollbar ace_scrollbar-v" style="display: none; width: 20px; bottom: 0px;"><div class="ace_scrollbar-inner" style="width: 20px; height: 196px;"></div></div><div class="ace_scrollbar ace_scrollbar-h" style="display: none; height: 20px; left: 47px; right: 0px;"><div class="ace_scrollbar-inner" style="height: 20px; width: 789px;"></div></div><div style="height: auto; width: auto; top: 0px; left: 0px; visibility: hidden; position: absolute; white-space: pre; font: inherit; overflow: hidden;"><div style="height: auto; width: auto; top: 0px; left: 0px; visibility: hidden; position: absolute; white-space: pre; font: inherit; overflow: visible;"></div><div style="height: auto; width: auto; top: 0px; left: 0px; visibility: hidden; position: absolute; white-space: pre; font-style: inherit; font-variant: inherit; font-stretch: inherit; font-size: inherit; line-height: inherit; font-family: inherit; overflow: visible;">XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</div></div></div></div></pre>
                <p>Такой код уже <strong>успешно работает с istream-итераторами.</strong> Но тогда почему не ослабить требования на параметры adjacent_find? Неужели istream-итератор в чём-то лучше стандартного input-итератора?</p>
                <p>Да, и это свойство неоднократно обсуждалось выше. По стандарту от input-итератора не требуется сохранение текущего значения. <a href="https://en.cppreference.com/w/cpp/named_req/InputIterator" target="_blank" rel="noopener nofollow">Более формально</a>,
                    при увеличении итератора его копии не обязаны оставаться разыменуемыми. Это свойство требуется при разыменовании итератора first, но выполняется для input-итератора как раз благодаря тому, что он помнит текущее значение и «не теряет»
                    его при копировании и сдвиге.</p>
                <p>Можно ли реализовать adjacent_find так, чтобы он действительно мог работать с любыми input-итераторами? Да, и для этого достаточно вместо first между соседними итерациями сохранять само предыдущее значение — *first — в отдельную переменную.
                    Правда, так не стоит делать для многопроходных итераторов, поэтому понадобится отдельный вариант функции.</p>
                <p>Дополнения</p>
                <p>Ещё одно место в документации, где можно легко встретить forward-итераторы — <strong>параллельные версии</strong> алгоритмов, работающих с input-итераторами, например, <a href="https://en.cppreference.com/w/cpp/algorithm/count" target="_blank"
                        rel="noopener nofollow">count</a>:</p>
                <pre contenteditable="false" data-language="c_cpp" style="opacity: 1;" tabindex="0"><div><div aria-label="Блок кода: нажмите клавишу Escape, чтобы выйти из блока кода" role="textbox" tabindex="-1" class="rc-CodeBlock code-container ace_editor ace-tomorrow" style="height: 84px;"><textarea class="ace_text-input" wrap="off" autocorrect="off" autocapitalize="off" spellcheck="false" style="opacity: 0; left: 57.1956px; top: 70px; height: 14px; width: 6.59781px;" role="presentation" aria-hidden="true" tabindex="-1" aria-label="Нажмите клавишу Escape, чтобы выйти из режима редактирования кода"></textarea><div class="ace_gutter"><div class="ace_layer ace_gutter-layer ace_folding-enabled" style="margin-top: 0px; height: 112px; width: 40px;"><div class="ace_gutter-cell " style="height: 14px;">1</div><div class="ace_gutter-cell " style="height: 14px;">2</div><div class="ace_gutter-cell " style="height: 14px;">3</div><div class="ace_gutter-cell " style="height: 14px;">4</div><div class="ace_gutter-cell " style="height: 14px;">5</div><div class="ace_gutter-cell " style="height: 14px;">6</div></div><div class="ace_gutter-active-line" style="top: 70px; height: 14px;"></div></div><div class="ace_scroller" style="left: 40px; right: 0px; bottom: 0px;"><div class="ace_content" style="margin-top: 0px; width: 796px; height: 112px; margin-left: 0px;"><div class="ace_layer ace_print-margin-layer"><div class="ace_print-margin" style="left: 531.825px; visibility: visible;"></div></div><div class="ace_layer ace_marker-layer"></div><div class="ace_layer ace_text-layer" style="padding: 0px 4px;"><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px"><span class="ace_storage ace_type">template</span><span class="ace_keyword ace_operator">&lt;</span><span class="ace_storage ace_modifier">typename</span> <span class="ace_identifier">ExecutionPolicy</span><span class="ace_punctuation ace_operator">,</span> <span class="ace_storage ace_modifier">typename</span> <span class="ace_identifier">ForwardIt</span><span class="ace_punctuation ace_operator">,</span> <span class="ace_storage ace_modifier">typename</span> <span class="ace_identifier">T</span><span class="ace_keyword ace_operator">&gt;</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px"><span class="ace_storage ace_type">int</span> <span class="ace_identifier">count</span><span class="ace_paren ace_lparen">(</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px">    <span class="ace_identifier">ExecutionPolicy</span><span class="ace_keyword ace_operator">&amp;&amp;</span> <span class="ace_identifier">policy</span><span class="ace_punctuation ace_operator">,</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px">    <span class="ace_identifier">ForwardIt</span> <span class="ace_identifier">first</span><span class="ace_punctuation ace_operator">,</span> <span class="ace_identifier">ForwardIt</span> <span class="ace_identifier">last</span><span class="ace_punctuation ace_operator">,</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px">    <span class="ace_storage ace_modifier">const</span> <span class="ace_identifier">T</span><span class="ace_keyword ace_operator">&amp;</span> <span class="ace_identifier">value</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px"><span class="ace_paren ace_rparen">)</span><span class="ace_punctuation ace_operator">;</span></div></div></div><div class="ace_layer ace_marker-layer"></div><div class="ace_layer ace_cursor-layer ace_hidden-cursors"><div class="ace_cursor" style="left: 17.1956px; top: 70px; width: 6.59781px; height: 14px;"></div></div></div></div><div class="ace_scrollbar ace_scrollbar-v" style="display: none; width: 20px; bottom: 0px;"><div class="ace_scrollbar-inner" style="width: 20px; height: 84px;"></div></div><div class="ace_scrollbar ace_scrollbar-h" style="display: none; height: 20px; left: 40px; right: 0px;"><div class="ace_scrollbar-inner" style="height: 20px; width: 796px;"></div></div><div style="height: auto; width: auto; top: 0px; left: 0px; visibility: hidden; position: absolute; white-space: pre; font: inherit; overflow: hidden;"><div style="height: auto; width: auto; top: 0px; left: 0px; visibility: hidden; position: absolute; white-space: pre; font: inherit; overflow: visible;"></div><div style="height: auto; width: auto; top: 0px; left: 0px; visibility: hidden; position: absolute; white-space: pre; font-style: inherit; font-variant: inherit; font-stretch: inherit; font-size: inherit; line-height: inherit; font-family: inherit; overflow: visible;">XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</div></div></div></div></pre>
                <p>Параллельность будет подробно обсуждаться в следующем курсе, но суть здесь следующая: подсчёт количества элементов в диапазоне распараллеливается на разные потоки, для этого исходный диапазон разбивается на порции, которые будут независимо
                    этими потоками обрабатываться — так и возникает необходимость в многопроходности.</p>
                <p>Наконец, как уже обсуждалось в предыдущем видео, нужно иметь в виду, что некоторые алгоритмы, принимающие forward-итераторы, в отличие от рассмотренных выше, изменяют или переставляют элементы. Простые примеры:</p>
                <ul>
                    <li><a href="https://en.cppreference.com/w/cpp/algorithm/remove" target="_blank" rel="noopener nofollow">remove</a> переставляет элементы местами, откладывая лишние;</li>
                    <li><a href="https://en.cppreference.com/w/cpp/algorithm/replace" target="_blank" rel="noopener nofollow">replace</a> присваивает некоторым элементам новое значение.</li>
                </ul>
                <p>Понятно, что такие алгоритмы нельзя вызвать для константных итераторов. Обычно по описанию функции легко понять, собирается ли она менять переданные элементы.</p>
                <p>Итак, мы подробно обсудили отличия forward-итераторов от более широких категорий. В первую очередь, это многопроходность, в которой периодически возникает необходимость. Также forward-итераторы — самые простые, позволяющие одновременно
                    и читать нижележащие значения, и изменять их.</p>
                <p><strong>Полный список требований</strong> к forward-итераторам находится <a href="https://en.cppreference.com/w/cpp/named_req/ForwardIterator" target="_blank" rel="noopener nofollow">здесь</a>.</p>
                <h2></h2>
                <h2>Двунаправленные (bidirectional) итераторы</h2>
                <p>Как легко понять по названию, с помощью двунаправленных итераторов можно итерироваться как вперёд, так и назад — с помощью --it или it--. Остальные свойства эти итераторы наследуют от прямых: таким образом, <strong>любой bidirectional-итератор является forward-итератором.</strong>                    Более того, поскольку любой forward-итератор является входным, то и любой двунаправленный им является.</p>
                <p>Двунаправленными являются итераторы всех контейнеров, кроме рассмотренного выше и редко используемого forward_list. При этом итераторы множества и словаря являются двунаправленными и не принадлежат более узким категориям, то есть не удовлетворяют
                    более жёстким требованиям, рассмотренным ниже.</p>
                <p>Ожидаемо есть и алгоритмы, на эту двунаправленность полагающиеся: как переставляющий элементы <a href="https://en.cppreference.com/w/cpp/algorithm/reverse" target="_blank" rel="noopener nofollow">reverse</a>, так и просто читающий (и записывающий)
                    элементы в обратном порядке <a href="https://en.cppreference.com/w/cpp/algorithm/copy_backward" target="_blank" rel="noopener nofollow">copy_backward</a>. В документации такие итераторы коротко обозначаются BidirIt.</p>
                <p><strong>Полный список требований</strong> к bidirectional-итераторам находится <a href="https://en.cppreference.com/w/cpp/named_req/BidirectionalIterator" target="_blank" rel="noopener nofollow">здесь</a>.</p>
                <h2></h2>
                <h2>Итераторы произвольного доступа (random access)</h2>
                <p>Наконец, мы перешли к категории итераторов с максимальным набором требований — из тех, что могут быть необходимы для вызова алгоритма. Итераторы произвольного доступа умеют всё то же, что и итераторы вектора. А именно:</p>
                <ul>
                    <li>it + n, n + it, it - n (результат — итератор);</li>
                    <li>it += n, it -= n (результат — ссылка на итератор);</li>
                    <li>it[n] (эквивалентно *(it + n)).</li>
                </ul>
                <ol>
                    <li>Позволяют вычитать итераторы и сравнивать их: it1 - it2, it1 &lt; it2, it1 &lt;= it2, it1 &gt; it2, it1 &gt;= it2.</li>
                </ol>
                <p>Этим требованиям удовлетворяют итераторы вектора и дека (про него вы узнаете в следующем блоке), но не множества и словаря.</p>
                <p>Может возникнуть вопрос: почему бы не реализовать операцию it + n для любых итераторов, не являющихся random access, с помощью n-кратного инкремента? Дело в том, что C++ старается не обманывать разработчика и требует эффективной реализации
                    от операций, выглядящих как встроенные. В данном случае прибавление числа к итератору <em>должно иметь константную сложность.</em> Для обобщённых операций с итераторами есть следующие функции из заголовочного файла &lt;iterator&gt;:</p>
                <ul>
                    <li><a href="https://en.cppreference.com/w/cpp/iterator/next" target="_blank" rel="noopener nofollow">next</a> замещает it + 1 или it + n;</li>
                    <li><a href="https://en.cppreference.com/w/cpp/iterator/prev" target="_blank" rel="noopener nofollow">prev</a> замещает it - 1 или it - n;</li>
                    <li><a href="https://en.cppreference.com/w/cpp/iterator/advance" target="_blank" rel="noopener nofollow">advance</a> замещает it += n;</li>
                    <li><a href="https://en.cppreference.com/w/cpp/iterator/distance" target="_blank" rel="noopener nofollow">distance</a> замещает it2 - it1.</li>
                </ul>
                <p>Сложность этих функций линейна (по n или результату distance), но для итераторов произвольного доступа константная, потому что в этом случае реализация осуществляется с помощью +, - и +=.</p>
                <p>Итератор произвольного доступа не обязан ссылаться на конкретные ячейки в памяти. Например, можно реализовать <strong>считающий итератор,</strong> поочерёдно возвращающий значения целочисленного типа: 1, 2, 3 и т. д. Такой итератор реализован
                    в библиотеке ranges C++20: см. <a href="https://en.cppreference.com/w/cpp/ranges/iota_view" target="_blank" rel="noopener nofollow">статью про iota_view</a>, секцию std::ranges::iota_view::iterator. В частности, видно, что категория
                    этого итератора зависит от возможностей типа W, по которому выполняется перебор. Подробнее библиотека ranges будет рассмотрена в 4-м курсе специализации.</p>
                <h3></h3>
                <ol>
                    <li>Являются двунаправленными.</li>
                    <li>Позволяют сдвинуть итератор на целочисленное количество позиций:</li>
                </ol>
                <h3>Функции, работающие с random access итераторами</h3>
                <p>Напомним, что в силу наследования свойств рассмотренные выше функции, принимающие входные, прямые и двунаправленные итераторы, можно вызвать для итераторов произвольного доступа. Функции, принимающие выходные итераторы, можно вызвать только
                    для неконстантных итераторов.</p>
                <p>При этом есть функции, принимающие лишь итераторы произвольного доступа, то есть требующие сравнения итераторов или быстрого перемещения на несколько ячеек. Простой пример такой функции — <a href="https://en.cppreference.com/w/cpp/algorithm/random_shuffle"
                        target="_blank" rel="noopener nofollow">shuffle</a>: произвольный доступ в ней необходим для выбора случайного элемента из диапазона с помощью быстрого обращения по случайному индексу. Слово «random» неслучайно присутствует и в названии
                    категории итераторов, и в старом названии функции shuffle, однако путать эти его смыслы всё же не стоит: итераторы с <em>произвольным</em> доступом позволяют за константную сложность обращаться по <em>произвольному</em> индексу, но
                    напрямую со случайностью не связаны.</p>
                <p>Таких функций, которые вовсе не скомпилируются для двунаправленных итераторов, немного. Чаще вы встретите ситуацию, которую удобно обсудить на примере алгоритма <a href="https://en.cppreference.com/w/cpp/algorithm/lower_bound" target="_blank"
                        rel="noopener nofollow">lower_bound</a>. В реализации этого алгоритма необходимо обращаться к <em>середине диапазона итераторов.</em> Если сделать это с помощью +, алгоритм будет работать только для итераторов произвольного доступа
                    — но быстро. Если же использовать advance, как и сделано в секции «Possible implementation», алгоритм будет работать и для forward-итераторов, пусть и медленнее.</p>
                <p>Соответственно, в секции «Сложность» для lower_bound гарантируется следующее: <em>функция выполняет O(log(last - first)) сравнений, однако для не random access итераторов количество инкрементов итераторов будет линейным.</em></p>
                <p><strong>Полный список требований</strong> к итераторам произвольного доступа находится <a href="https://en.cppreference.com/w/cpp/named_req/RandomAccessIterator" target="_blank" rel="noopener nofollow">здесь</a>.</p>
                <h2></h2>
                <h2>Перегрузка функций по категориям итераторов</h2>
                <p>Выше мы неоднократно заявляли о возможности реализовать некоторую функцию разными способами в зависимости от категории переданных в неё итераторов. До C++20 стандартный способ сделать это — использовать теги итераторов. Рассмотрим простейший
                    пример <a href="https://en.cppreference.com/w/cpp/iterator/iterator_tags" target="_blank" rel="noopener nofollow">из документации</a>:</p>
                <pre contenteditable="false" data-language="c_cpp" style="opacity: 1;" tabindex="0"><div><div aria-label="Блок кода: нажмите клавишу Escape, чтобы выйти из блока кода" role="textbox" tabindex="-1" class="rc-CodeBlock code-container ace_editor ace-tomorrow" style="height: 350px;"><textarea class="ace_text-input" wrap="off" autocorrect="off" autocapitalize="off" spellcheck="false" style="opacity: 0; left: 57.5978px; top: 336px; height: 14px; width: 6.59781px;" role="presentation" aria-hidden="true" tabindex="-1" aria-label="Нажмите клавишу Escape, чтобы выйти из режима редактирования кода"></textarea><div class="ace_gutter"><div class="ace_layer ace_gutter-layer ace_folding-enabled" style="margin-top: 0px; height: 378px; width: 47px;"><div class="ace_gutter-cell " style="height: 14px;">1</div><div class="ace_gutter-cell " style="height: 14px;">2<span class="ace_fold-widget ace_start ace_open" style="height: 14px;"></span></div><div class="ace_gutter-cell " style="height: 14px;">3</div><div class="ace_gutter-cell " style="height: 14px;">4</div><div class="ace_gutter-cell " style="height: 14px;">5</div><div class="ace_gutter-cell " style="height: 14px;">6</div><div class="ace_gutter-cell " style="height: 14px;">7<span class="ace_fold-widget ace_start ace_open" style="height: 14px;"></span></div><div class="ace_gutter-cell " style="height: 14px;">8</div><div class="ace_gutter-cell " style="height: 14px;">9</div><div class="ace_gutter-cell " style="height: 14px;">10</div><div class="ace_gutter-cell " style="height: 14px;">11</div><div class="ace_gutter-cell " style="height: 14px;">12<span class="ace_fold-widget ace_start ace_open" style="height: 14px;"></span></div><div class="ace_gutter-cell " style="height: 14px;">13</div><div class="ace_gutter-cell " style="height: 14px;">14</div><div class="ace_gutter-cell " style="height: 14px;">15</div><div class="ace_gutter-cell " style="height: 14px;">16</div><div class="ace_gutter-cell " style="height: 14px;">17<span class="ace_fold-widget ace_start ace_open" style="height: 14px;"></span></div><div class="ace_gutter-cell " style="height: 14px;">18</div><div class="ace_gutter-cell " style="height: 14px;">19</div><div class="ace_gutter-cell " style="height: 14px;">20</div><div class="ace_gutter-cell " style="height: 14px;">21</div><div class="ace_gutter-cell " style="height: 14px;">22</div><div class="ace_gutter-cell " style="height: 14px;">23</div><div class="ace_gutter-cell " style="height: 14px;">24</div><div class="ace_gutter-cell " style="height: 14px;">25</div></div><div class="ace_gutter-active-line" style="top: 336px; height: 14px;"></div></div><div class="ace_scroller" style="left: 47px; right: 0px; bottom: 0px;"><div class="ace_content" style="margin-top: 0px; width: 789px; height: 378px; margin-left: 0px;"><div class="ace_layer ace_print-margin-layer"><div class="ace_print-margin" style="left: 531.825px; visibility: visible;"></div></div><div class="ace_layer ace_marker-layer"><div class="ace_bracket ace_start ace_br15" style="height:14px;width:6.5978125px;top:224px;left:76.5759375px;"></div></div><div class="ace_layer ace_text-layer" style="padding: 0px 4px;"><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px"><span class="ace_storage ace_type">template</span><span class="ace_keyword ace_operator">&lt;</span><span class="ace_storage ace_modifier">typename</span> <span class="ace_identifier">BDIter</span><span class="ace_keyword ace_operator">&gt;</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px"><span class="ace_storage ace_type">void</span> <span class="ace_identifier">alg</span><span class="ace_paren ace_lparen">(</span><span class="ace_identifier">BDIter</span> <span class="ace_identifier">it1</span><span class="ace_punctuation ace_operator">,</span> <span class="ace_identifier">BDIter</span> <span class="ace_identifier">it2</span><span class="ace_punctuation ace_operator">,</span> <span class="ace_identifier">std</span><span class="ace_punctuation ace_operator">::</span><span class="ace_identifier">bidirectional_iterator_tag</span><span class="ace_paren ace_rparen">)</span> <span class="ace_paren ace_lparen">{</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px">  <span class="ace_identifier">std</span><span class="ace_punctuation ace_operator">::</span><span class="ace_identifier">cout</span> <span class="ace_keyword ace_operator">&lt;&lt;</span> <span class="ace_string ace_start">"</span><span class="ace_string">alg() called for bidirectional iterator</span><span class="ace_constant ace_language ace_escape">\n</span><span class="ace_string ace_end">"</span><span class="ace_punctuation ace_operator">;</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px"><span class="ace_paren ace_rparen">}</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px"> </div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px"><span class="ace_storage ace_type">template</span><span class="ace_keyword ace_operator">&lt;</span><span class="ace_storage ace_modifier">typename</span> <span class="ace_identifier">RAIter</span><span class="ace_keyword ace_operator">&gt;</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px"><span class="ace_storage ace_type">void</span> <span class="ace_identifier">alg</span><span class="ace_paren ace_lparen">(</span><span class="ace_identifier">RAIter</span> <span class="ace_identifier">it1</span><span class="ace_punctuation ace_operator">,</span> <span class="ace_identifier">RAIter</span> <span class="ace_identifier">it2</span><span class="ace_punctuation ace_operator">,</span> <span class="ace_identifier">std</span><span class="ace_punctuation ace_operator">::</span><span class="ace_identifier">random_access_iterator_tag</span><span class="ace_paren ace_rparen">)</span> <span class="ace_paren ace_lparen">{</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px">  <span class="ace_identifier">std</span><span class="ace_punctuation ace_operator">::</span><span class="ace_identifier">cout</span> <span class="ace_keyword ace_operator">&lt;&lt;</span> <span class="ace_string ace_start">"</span><span class="ace_string">alg() called for random-access iterator</span><span class="ace_constant ace_language ace_escape">\n</span><span class="ace_string ace_end">"</span><span class="ace_punctuation ace_operator">;</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px"><span class="ace_paren ace_rparen">}</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px"> </div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px"><span class="ace_storage ace_type">template</span><span class="ace_keyword ace_operator">&lt;</span><span class="ace_storage ace_modifier">typename</span> <span class="ace_identifier">Iter</span><span class="ace_keyword ace_operator">&gt;</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px"><span class="ace_storage ace_type">void</span> <span class="ace_identifier">alg</span><span class="ace_paren ace_lparen">(</span><span class="ace_identifier">Iter</span> <span class="ace_identifier">first</span><span class="ace_punctuation ace_operator">,</span> <span class="ace_identifier">Iter</span> <span class="ace_identifier">last</span><span class="ace_paren ace_rparen">)</span> <span class="ace_paren ace_lparen">{</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px">  <span class="ace_identifier">alg</span><span class="ace_paren ace_lparen">(</span><span class="ace_identifier">first</span><span class="ace_punctuation ace_operator">,</span> <span class="ace_identifier">last</span><span class="ace_punctuation ace_operator">,</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px">      <span class="ace_storage ace_modifier">typename</span> <span class="ace_identifier">std</span><span class="ace_punctuation ace_operator">::</span><span class="ace_identifier">iterator_traits</span><span class="ace_keyword ace_operator">&lt;</span><span class="ace_identifier">Iter</span><span class="ace_keyword ace_operator">&gt;</span><span class="ace_punctuation ace_operator">::</span><span class="ace_identifier">iterator_category</span><span class="ace_paren ace_lparen">(</span><span class="ace_paren ace_rparen">))</span><span class="ace_punctuation ace_operator">;</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px"><span class="ace_paren ace_rparen">}</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px"> </div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px"><span class="ace_storage ace_type">int</span> <span class="ace_identifier">main</span><span class="ace_paren ace_lparen">(</span><span class="ace_paren ace_rparen">)</span> <span class="ace_paren ace_lparen">{</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px">  <span class="ace_identifier">std</span><span class="ace_punctuation ace_operator">::</span><span class="ace_identifier">vector</span><span class="ace_keyword ace_operator">&lt;</span><span class="ace_storage ace_type">int</span><span class="ace_keyword ace_operator">&gt;</span> <span class="ace_identifier">v</span><span class="ace_punctuation ace_operator">;</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px">  <span class="ace_identifier">alg</span><span class="ace_paren ace_lparen">(</span><span class="ace_identifier">v</span><span class="ace_punctuation ace_operator">.</span><span class="ace_identifier">begin</span><span class="ace_paren ace_lparen">(</span><span class="ace_paren ace_rparen">)</span><span class="ace_punctuation ace_operator">,</span> <span class="ace_identifier">v</span><span class="ace_punctuation ace_operator">.</span><span class="ace_identifier">end</span><span class="ace_paren ace_lparen">(</span><span class="ace_paren ace_rparen">))</span><span class="ace_punctuation ace_operator">;</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px">  <span class="ace_comment">// выведет «alg() called for random-access iterator»</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px"> </div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px">  <span class="ace_identifier">std</span><span class="ace_punctuation ace_operator">::</span><span class="ace_identifier">list</span><span class="ace_keyword ace_operator">&lt;</span><span class="ace_storage ace_type">int</span><span class="ace_keyword ace_operator">&gt;</span> <span class="ace_identifier">l</span><span class="ace_punctuation ace_operator">;</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px">  <span class="ace_identifier">alg</span><span class="ace_paren ace_lparen">(</span><span class="ace_identifier">l</span><span class="ace_punctuation ace_operator">.</span><span class="ace_identifier">begin</span><span class="ace_paren ace_lparen">(</span><span class="ace_paren ace_rparen">)</span><span class="ace_punctuation ace_operator">,</span> <span class="ace_identifier">l</span><span class="ace_punctuation ace_operator">.</span><span class="ace_identifier">end</span><span class="ace_paren ace_lparen">(</span><span class="ace_paren ace_rparen">))</span><span class="ace_punctuation ace_operator">;</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px">  <span class="ace_comment">// выведет «alg() called for bidirectional iterator»</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px"><span class="ace_paren ace_rparen">}</span></div></div></div><div class="ace_layer ace_marker-layer"></div><div class="ace_layer ace_cursor-layer ace_hidden-cursors"><div class="ace_cursor" style="left: 10.5978px; top: 336px; width: 6.59781px; height: 14px;"></div></div></div></div><div class="ace_scrollbar ace_scrollbar-v" style="display: none; width: 20px; bottom: 0px;"><div class="ace_scrollbar-inner" style="width: 20px; height: 350px;"></div></div><div class="ace_scrollbar ace_scrollbar-h" style="display: none; height: 20px; left: 47px; right: 0px;"><div class="ace_scrollbar-inner" style="height: 20px; width: 789px;"></div></div><div style="height: auto; width: auto; top: 0px; left: 0px; visibility: hidden; position: absolute; white-space: pre; font: inherit; overflow: hidden;"><div style="height: auto; width: auto; top: 0px; left: 0px; visibility: hidden; position: absolute; white-space: pre; font: inherit; overflow: visible;"></div><div style="height: auto; width: auto; top: 0px; left: 0px; visibility: hidden; position: absolute; white-space: pre; font-style: inherit; font-variant: inherit; font-stretch: inherit; font-size: inherit; line-height: inherit; font-family: inherit; overflow: visible;">XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</div></div></div></div></pre>
                <p>Обсудим эту схему по пунктам:</p>
                <ol>
                    <li>В main вызывается функция alg от двух итераторов: вектора или списка. Есть ровно одна версия шаблона alg с 2 параметрами, так что вызывается именно она.</li>
                    <li>В функции alg с 2 параметрами определяется тег итератора. typename std::iterator_traits&lt;Iter&gt;::iterator_category — это тип для этого тега: std::random_access_iterator_tag для итератора вектора и std::bidirectional_iterator_tag
                        для итератора списка. То же выражение с пустыми круглыми скобками в конце — значение по умолчанию этого типа.</li>
                    <li>Есть две версии шаблонной функции alg с 3 параметрами: первые два из них шаблонные (и потому в текущем виде не помогают выбрать конкретную версию функции), а третий имеет конкретный тип: это std::random_access_iterator_tag или std::bidirectional_iterator_tag.
                        Сам третий параметр не используется, поэтому его название в заголовке функции не указано. Именно тип 3-го параметра помогает компилятору выбрать конкретную версию функции alg в зависимости от категории исходных итераторов.</li>
                    <li>В зависимости от категории итератора выполняется конкретная логика. В данном случае всего лишь выводятся разные сообщения.</li>
                </ol>
                <p>Рассмотрим теперь реальный пример такой перегрузки — <a href="https://github.com/llvm-mirror/libcxx/blob/a12cb9d211019d99b5875b6d8034617cbc24c2cc/include/algorithm#L1278-L1317" target="_blank" rel="noopener nofollow">реализацию алгоритма equal в стандартной библиотеке libc++</a>.</p>
                <p>Эта версия equal поэлементно сравнивает два диапазона итераторов [first1, last1) и [first2, last2) с помощью бинарного предиката p:</p>
                <pre contenteditable="false" data-language="c_cpp" style="opacity: 1;" tabindex="0"><div><div aria-label="Блок кода: нажмите клавишу Escape, чтобы выйти из блока кода" role="textbox" tabindex="-1" class="rc-CodeBlock code-container ace_editor ace-tomorrow" style="height: 56px;"><textarea class="ace_text-input" wrap="off" autocorrect="off" autocapitalize="off" spellcheck="false" style="opacity: 0; left: 241.934px; top: 42px; height: 14px; width: 6.59781px;" role="presentation" aria-hidden="true" tabindex="-1" aria-label="Нажмите клавишу Escape, чтобы выйти из режима редактирования кода"></textarea><div class="ace_gutter"><div class="ace_layer ace_gutter-layer ace_folding-enabled" style="margin-top: 0px; height: 84px; width: 40px;"><div class="ace_gutter-cell " style="height: 14px;">1</div><div class="ace_gutter-cell " style="height: 14px;">2</div><div class="ace_gutter-cell " style="height: 14px;">3</div><div class="ace_gutter-cell " style="height: 14px;">4</div></div><div class="ace_gutter-active-line" style="top: 42px; height: 14px;"></div></div><div class="ace_scroller" style="left: 40px; right: 0px; bottom: 0px;"><div class="ace_content" style="margin-top: 0px; width: 796px; height: 84px; margin-left: 0px;"><div class="ace_layer ace_print-margin-layer"><div class="ace_print-margin" style="left: 531.825px; visibility: visible;"></div></div><div class="ace_layer ace_marker-layer"></div><div class="ace_layer ace_text-layer" style="padding: 0px 4px;"><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px"><span class="ace_storage ace_type">template</span><span class="ace_keyword ace_operator">&lt;</span><span class="ace_storage ace_modifier">typename</span> <span class="ace_identifier">InputIt1</span><span class="ace_punctuation ace_operator">,</span> <span class="ace_storage ace_modifier">typename</span> <span class="ace_identifier">InputIt2</span><span class="ace_punctuation ace_operator">,</span> <span class="ace_storage ace_type">class</span> <span class="ace_identifier">BinaryPredicate</span><span class="ace_keyword ace_operator">&gt;</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px"><span class="ace_storage ace_type">bool</span> <span class="ace_identifier">equal</span><span class="ace_paren ace_lparen">(</span><span class="ace_identifier">InputIt1</span> <span class="ace_identifier">first1</span><span class="ace_punctuation ace_operator">,</span> <span class="ace_identifier">InputIt1</span> <span class="ace_identifier">last1</span><span class="ace_punctuation ace_operator">,</span> </div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px">           <span class="ace_identifier">InputIt2</span> <span class="ace_identifier">first2</span><span class="ace_punctuation ace_operator">,</span> <span class="ace_identifier">InputIt2</span> <span class="ace_identifier">last2</span><span class="ace_punctuation ace_operator">,</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px">           <span class="ace_identifier">BinaryPredicate</span> <span class="ace_identifier">p</span><span class="ace_paren ace_rparen">)</span><span class="ace_punctuation ace_operator">;</span></div></div></div><div class="ace_layer ace_marker-layer"></div><div class="ace_layer ace_cursor-layer ace_hidden-cursors"><div class="ace_cursor" style="left: 201.934px; top: 42px; width: 6.59781px; height: 14px;"></div></div></div></div><div class="ace_scrollbar ace_scrollbar-v" style="display: none; width: 20px; bottom: 0px;"><div class="ace_scrollbar-inner" style="width: 20px; height: 56px;"></div></div><div class="ace_scrollbar ace_scrollbar-h" style="display: none; height: 20px; left: 40px; right: 0px;"><div class="ace_scrollbar-inner" style="height: 20px; width: 796px;"></div></div><div style="height: auto; width: auto; top: 0px; left: 0px; visibility: hidden; position: absolute; white-space: pre; font: inherit; overflow: hidden;"><div style="height: auto; width: auto; top: 0px; left: 0px; visibility: hidden; position: absolute; white-space: pre; font: inherit; overflow: visible;"></div><div style="height: auto; width: auto; top: 0px; left: 0px; visibility: hidden; position: absolute; white-space: pre; font-style: inherit; font-variant: inherit; font-stretch: inherit; font-size: inherit; line-height: inherit; font-family: inherit; overflow: visible;">XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</div></div></div></div></pre>
                <p>Понятно, что если эти диапазоны имеют разную длину, их даже не надо сравнивать: можно сразу вернуть false. Но быстро вычислить длину можно только для итераторов произвольного доступа, так что хочется реализовать такую оптимизацию именно
                    для них. Это так и сделано: в перегрузке по random_access_iterator_tag вызывается distance и в случае неравенства длин возвращается false; затем вызывается версия функции equal без 4-го аргумента — конца второго диапазона.</p>
                <pre contenteditable="false" data-language="c_cpp" style="opacity: 1;" tabindex="0"><div><div aria-label="Блок кода: нажмите клавишу Escape, чтобы выйти из блока кода" role="textbox" tabindex="-1" class="rc-CodeBlock code-container ace_editor ace-tomorrow" style="height: 224px;"><textarea class="ace_text-input" wrap="off" autocorrect="off" autocapitalize="off" spellcheck="false" style="opacity: 0; left: 57.5978px; top: 210px; height: 14px; width: 6.59781px;" role="presentation" aria-hidden="true" tabindex="-1" aria-label="Нажмите клавишу Escape, чтобы выйти из режима редактирования кода"></textarea><div class="ace_gutter"><div class="ace_layer ace_gutter-layer ace_folding-enabled" style="margin-top: 0px; height: 266px; width: 47px;"><div class="ace_gutter-cell " style="height: 28px;">1</div><div class="ace_gutter-cell " style="height: 14px;">2</div><div class="ace_gutter-cell " style="height: 14px;">3</div><div class="ace_gutter-cell " style="height: 14px;">4</div><div class="ace_gutter-cell " style="height: 28px;">5</div><div class="ace_gutter-cell " style="height: 14px;">6</div><div class="ace_gutter-cell " style="height: 14px;">7<span class="ace_fold-widget ace_start ace_open" style="height: 14px;"></span></div><div class="ace_gutter-cell " style="height: 28px;">8</div><div class="ace_gutter-cell " style="height: 14px;">9</div><div class="ace_gutter-cell " style="height: 14px;">10</div><div class="ace_gutter-cell " style="height: 14px;">11</div><div class="ace_gutter-cell " style="height: 14px;">12</div><div class="ace_gutter-cell " style="height: 14px;">13</div></div><div class="ace_gutter-active-line" style="top: 210px; height: 14px;"></div></div><div class="ace_scroller" style="left: 47px; right: 0px; bottom: 0px;"><div class="ace_content" style="margin-top: 0px; width: 789px; height: 266px; margin-left: 0px;"><div class="ace_layer ace_print-margin-layer"><div class="ace_print-margin" style="left: 531.825px; visibility: visible;"></div></div><div class="ace_layer ace_marker-layer"><div class="ace_bracket ace_start ace_br15" style="height:14px;width:6.5978125px;top:112px;left:4px;"></div></div><div class="ace_layer ace_text-layer" style="padding: 0px 4px;"><div class="ace_line_group" style="height:28px"><div class="ace_line" style="height:14px"><span class="ace_storage ace_type">template</span> <span class="ace_keyword ace_operator">&lt;</span><span class="ace_storage ace_type">class</span> <span class="ace_identifier">_BinaryPredicate</span><span class="ace_punctuation ace_operator">,</span> <span class="ace_storage ace_type">class</span> <span class="ace_identifier">_RandomAccessIterator1</span><span class="ace_punctuation ace_operator">,</span> <span class="ace_storage ace_type">class</span> </div><div class="ace_line" style="height:14px">&nbsp;&nbsp;<span class="ace_identifier">_RandomAccessIterator2</span><span class="ace_keyword ace_operator">&gt;</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px"><span class="ace_storage ace_modifier">inline</span> <span class="ace_identifier">_LIBCPP_INLINE_VISIBILITY</span> <span class="ace_identifier">_LIBCPP_CONSTEXPR_AFTER_CXX17</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px"><span class="ace_storage ace_type">bool</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px"><span class="ace_identifier">__equal</span><span class="ace_paren ace_lparen">(</span><span class="ace_identifier">_RandomAccessIterator1</span> <span class="ace_identifier">__first1</span><span class="ace_punctuation ace_operator">,</span> <span class="ace_identifier">_RandomAccessIterator1</span> <span class="ace_identifier">__last1</span><span class="ace_punctuation ace_operator">,</span></div></div><div class="ace_line_group" style="height:28px"><div class="ace_line" style="height:14px">        <span class="ace_identifier">_RandomAccessIterator2</span> <span class="ace_identifier">__first2</span><span class="ace_punctuation ace_operator">,</span> <span class="ace_identifier">_RandomAccessIterator2</span> <span class="ace_identifier">__last2</span><span class="ace_punctuation ace_operator">,</span> </div><div class="ace_line" style="height:14px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="ace_identifier">_BinaryPredicate</span> <span class="ace_identifier">__pred</span><span class="ace_punctuation ace_operator">,</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px">      <span class="ace_identifier">random_access_iterator_tag</span><span class="ace_punctuation ace_operator">,</span> <span class="ace_identifier">random_access_iterator_tag</span> <span class="ace_paren ace_rparen">)</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px"><span class="ace_paren ace_lparen">{</span></div></div><div class="ace_line_group" style="height:28px"><div class="ace_line" style="height:14px">    <span class="ace_keyword ace_control">if</span> <span class="ace_paren ace_lparen">(</span> <span class="ace_identifier">_VSTD</span><span class="ace_punctuation ace_operator">::</span><span class="ace_identifier">distance</span><span class="ace_paren ace_lparen">(</span><span class="ace_identifier">__first1</span><span class="ace_punctuation ace_operator">,</span> <span class="ace_identifier">__last1</span><span class="ace_paren ace_rparen">)</span> <span class="ace_keyword ace_operator">!=</span> <span class="ace_identifier">_VSTD</span><span class="ace_punctuation ace_operator">::</span><span class="ace_identifier">distance</span><span class="ace_paren ace_lparen">(</span><span class="ace_identifier">__first2</span><span class="ace_punctuation ace_operator">,</span> <span class="ace_identifier">__last2</span></div><div class="ace_line" style="height:14px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="ace_paren ace_rparen">))</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px">        <span class="ace_keyword ace_control">return</span> <span class="ace_constant ace_language">false</span><span class="ace_punctuation ace_operator">;</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px">    <span class="ace_keyword ace_control">return</span> <span class="ace_identifier">_VSTD</span><span class="ace_punctuation ace_operator">::</span><span class="ace_identifier">equal</span><span class="ace_keyword ace_operator">&lt;</span><span class="ace_identifier">_RandomAccessIterator1</span><span class="ace_punctuation ace_operator">,</span> <span class="ace_identifier">_RandomAccessIterator2</span><span class="ace_punctuation ace_operator">,</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px">                        <span class="ace_storage ace_modifier">typename</span> <span class="ace_identifier">add_lvalue_reference</span><span class="ace_keyword ace_operator">&lt;</span><span class="ace_identifier">_BinaryPredicate</span><span class="ace_keyword ace_operator">&gt;</span><span class="ace_punctuation ace_operator">::</span><span class="ace_identifier">type</span><span class="ace_keyword ace_operator">&gt;</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px">                       <span class="ace_paren ace_lparen">(</span><span class="ace_identifier">__first1</span><span class="ace_punctuation ace_operator">,</span> <span class="ace_identifier">__last1</span><span class="ace_punctuation ace_operator">,</span> <span class="ace_identifier">__first2</span><span class="ace_punctuation ace_operator">,</span> <span class="ace_identifier">__pred</span> <span class="ace_paren ace_rparen">)</span><span class="ace_punctuation ace_operator">;</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px"><span class="ace_paren ace_rparen">}</span></div></div></div><div class="ace_layer ace_marker-layer"></div><div class="ace_layer ace_cursor-layer ace_hidden-cursors"><div class="ace_cursor" style="left: 10.5978px; top: 210px; width: 6.59781px; height: 14px;"></div></div></div></div><div class="ace_scrollbar ace_scrollbar-v" style="display: none; width: 20px; bottom: 0px;"><div class="ace_scrollbar-inner" style="width: 20px; height: 224px;"></div></div><div class="ace_scrollbar ace_scrollbar-h" style="display: none; height: 20px; left: 47px; right: 0px;"><div class="ace_scrollbar-inner" style="height: 20px; width: 789px;"></div></div><div style="height: auto; width: auto; top: 0px; left: 0px; visibility: hidden; position: absolute; white-space: pre; font: inherit; overflow: hidden;"><div style="height: auto; width: auto; top: 0px; left: 0px; visibility: hidden; position: absolute; white-space: pre; font: inherit; overflow: visible;"></div><div style="height: auto; width: auto; top: 0px; left: 0px; visibility: hidden; position: absolute; white-space: pre; font-style: inherit; font-variant: inherit; font-stretch: inherit; font-size: inherit; line-height: inherit; font-family: inherit; overflow: visible;">XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</div></div></div></div></pre>
                <h2></h2>
                <h2>Непрерывные (contiguous) итераторы</h2>
                <p>Казалось бы, неужели можно придумать более жёсткие требования к итераторам, которые ещё и будут актуальны для каких-либо алгоритмов? Можно. Однако, подобно свойству многопроходности, это новое свойство нельзя проверить на этапе компиляции.</p>
                <p>Это свойство — непрерывность хранения в памяти соответствующих итератору данных. Мы пока не изучали указатели, но если они вам уже знакомы, взгляните на более формальное определение: it[n] <em>эквивалентно</em> (&amp;*it)[n]. Знание о
                    том, что данные хранятся в памяти непрерывно, в некоторых случаях позволяет работать с ними более эффективно.</p>
                <p>Непрерывными являются итераторы векторов и строк, а также сырые указатели и итераторы массива. Итераторы дека, изучаемого далее в этой неделе, являются random access, но не являются непрерывными. Подробнее про массивы, деки и особенности
                    хранения данных в них вы узнаете в разделе «Линейные контейнеры» 3-го курса.</p>
                <p>Понятие contiguous-итератора введено в язык в C++17, однако вместе с ним <a href="https://stackoverflow.com/questions/42851957/contiguous-iterator-detection" target="_blank" rel="noopener nofollow">не появился</a> contiguous_iterator_tag,
                    позволяющий реализовать перегрузку из предыдущего раздела. Так пришлось поступить из-за нежелания сломать обратную совместимость: до C++17 было написано большое количество кода, полагающегося на то, что iterator_category для итераторов
                    векторов и строк — это в точности random_access_iterator_tag. Тем не менее, в C++20 появляется более нативная возможность перегрузки функций по категориям итераторов (в том числе и для непрерывных) — <strong>концепты.</strong></p>
                <p>При этом аналог этой перегрузки реализовывался и до последних стандартов — но исключительно для сырых указателей. Например, <a href="https://en.cppreference.com/w/cpp/algorithm/fill" target="_blank" rel="noopener nofollow">алгоритм fill</a>                    можно реализовать эффективнее для непрерывного диапазона элементов-байтов — с помощью <a href="https://en.cppreference.com/w/cpp/string/byte/memset" target="_blank" rel="noopener nofollow">функции memset</a>, унаследованной из языка
                    C. <a href="https://github.com/gcc-mirror/gcc/blob/d9375e490072d1aae73a93949aa158fcd2a27018/libstdc%2B%2B-v3/include/bits/stl_algobase.h#L717-L726" target="_blank" rel="noopener nofollow">В стандартной библиотеке libstdc++</a> это
                    сделано так:</p>
                <pre contenteditable="false" data-language="c_cpp" style="opacity: 1;" tabindex="0"><div><div aria-label="Блок кода: нажмите клавишу Escape, чтобы выйти из блока кода" role="textbox" tabindex="-1" class="rc-CodeBlock code-container ace_editor ace-tomorrow" style="height: 140px;"><textarea class="ace_text-input" wrap="off" autocorrect="off" autocapitalize="off" spellcheck="false" style="opacity: 0; left: 70.7934px; top: 126px; height: 14px; width: 6.59781px;" role="presentation" aria-hidden="true" tabindex="-1" aria-label="Нажмите клавишу Escape, чтобы выйти из режима редактирования кода"></textarea><div class="ace_gutter"><div class="ace_layer ace_gutter-layer ace_folding-enabled" style="margin-top: 0px; height: 168px; width: 47px;"><div class="ace_gutter-cell " style="height: 14px;">1</div><div class="ace_gutter-cell " style="height: 14px;">2</div><div class="ace_gutter-cell " style="height: 14px;">3</div><div class="ace_gutter-cell " style="height: 14px;">4</div><div class="ace_gutter-cell " style="height: 14px;">5</div><div class="ace_gutter-cell " style="height: 14px;">6<span class="ace_fold-widget ace_start ace_open" style="height: 14px;"></span></div><div class="ace_gutter-cell " style="height: 14px;">7</div><div class="ace_gutter-cell " style="height: 14px;">8</div><div class="ace_gutter-cell " style="height: 14px;">9</div><div class="ace_gutter-cell " style="height: 14px;">10</div></div><div class="ace_gutter-active-line" style="top: 126px; height: 14px;"></div></div><div class="ace_scroller" style="left: 47px; right: 0px; bottom: 0px;"><div class="ace_content" style="margin-top: 0px; width: 789px; height: 168px; margin-left: 0px;"><div class="ace_layer ace_print-margin-layer"><div class="ace_print-margin" style="left: 531.825px; visibility: visible;"></div></div><div class="ace_layer ace_marker-layer"><div class="ace_bracket ace_start ace_br15" style="height:14px;width:6.5978125px;top:70px;left:17.195625px;"></div></div><div class="ace_layer ace_text-layer" style="padding: 0px 4px;"><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px"><span class="ace_comment">// Specialization: for char types we can use memset.</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px"><span class="ace_storage ace_type">template</span><span class="ace_keyword ace_operator">&lt;</span><span class="ace_storage ace_modifier">typename</span> <span class="ace_identifier">_Tp</span><span class="ace_keyword ace_operator">&gt;</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px">  <span class="ace_storage ace_modifier">inline</span> <span class="ace_storage ace_modifier">typename</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px">  <span class="ace_identifier">__gnu_cxx</span><span class="ace_punctuation ace_operator">::</span><span class="ace_identifier">__enable_if</span><span class="ace_keyword ace_operator">&lt;</span><span class="ace_identifier">__is_byte</span><span class="ace_keyword ace_operator">&lt;</span><span class="ace_identifier">_Tp</span><span class="ace_keyword ace_operator">&gt;</span><span class="ace_punctuation ace_operator">::</span><span class="ace_identifier">__value</span><span class="ace_punctuation ace_operator">,</span> <span class="ace_storage ace_type">void</span><span class="ace_keyword ace_operator">&gt;</span><span class="ace_punctuation ace_operator">::</span><span class="ace_identifier">__type</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px">  <span class="ace_identifier">__fill_a</span><span class="ace_paren ace_lparen">(</span><span class="ace_identifier">_Tp</span><span class="ace_keyword ace_operator">*</span> <span class="ace_identifier">__first</span><span class="ace_punctuation ace_operator">,</span> <span class="ace_identifier">_Tp</span><span class="ace_keyword ace_operator">*</span> <span class="ace_identifier">__last</span><span class="ace_punctuation ace_operator">,</span> <span class="ace_storage ace_modifier">const</span> <span class="ace_identifier">_Tp</span><span class="ace_keyword ace_operator">&amp;</span> <span class="ace_identifier">__c</span><span class="ace_paren ace_rparen">)</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px">  <span class="ace_paren ace_lparen">{</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px">    <span class="ace_storage ace_modifier">const</span> <span class="ace_identifier">_Tp</span> <span class="ace_identifier">__tmp</span> <span class="ace_keyword ace_operator">=</span> <span class="ace_identifier">__c</span><span class="ace_punctuation ace_operator">;</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px">    <span class="ace_keyword ace_control">if</span> <span class="ace_paren ace_lparen">(</span><span class="ace_storage ace_modifier">const</span> <span class="ace_identifier">size_t</span> <span class="ace_identifier">__len</span> <span class="ace_keyword ace_operator">=</span> <span class="ace_identifier">__last</span> <span class="ace_keyword ace_operator">-</span> <span class="ace_identifier">__first</span><span class="ace_paren ace_rparen">)</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px">      <span class="ace_identifier">__builtin_memset</span><span class="ace_paren ace_lparen">(</span><span class="ace_identifier">__first</span><span class="ace_punctuation ace_operator">,</span> <span class="ace_keyword ace_operator">static_cast&lt;</span><span class="ace_storage ace_type">unsigned</span> <span class="ace_storage ace_type">char</span><span class="ace_keyword ace_operator">&gt;</span><span class="ace_paren ace_lparen">(</span><span class="ace_identifier">__tmp</span><span class="ace_paren ace_rparen">)</span><span class="ace_punctuation ace_operator">,</span> <span class="ace_identifier">__len</span><span class="ace_paren ace_rparen">)</span><span class="ace_punctuation ace_operator">;</span></div></div><div class="ace_line_group" style="height:14px"><div class="ace_line" style="height:14px">  <span class="ace_paren ace_rparen">}</span></div></div></div><div class="ace_layer ace_marker-layer"></div><div class="ace_layer ace_cursor-layer ace_hidden-cursors"><div class="ace_cursor" style="left: 23.7934px; top: 126px; width: 6.59781px; height: 14px;"></div></div></div></div><div class="ace_scrollbar ace_scrollbar-v" style="display: none; width: 20px; bottom: 0px;"><div class="ace_scrollbar-inner" style="width: 20px; height: 140px;"></div></div><div class="ace_scrollbar ace_scrollbar-h" style="display: none; height: 20px; left: 47px; right: 0px;"><div class="ace_scrollbar-inner" style="height: 20px; width: 789px;"></div></div><div style="height: auto; width: auto; top: 0px; left: 0px; visibility: hidden; position: absolute; white-space: pre; font: inherit; overflow: hidden;"><div style="height: auto; width: auto; top: 0px; left: 0px; visibility: hidden; position: absolute; white-space: pre; font: inherit; overflow: visible;"></div><div style="height: auto; width: auto; top: 0px; left: 0px; visibility: hidden; position: absolute; white-space: pre; font-style: inherit; font-variant: inherit; font-stretch: inherit; font-size: inherit; line-height: inherit; font-family: inherit; overflow: visible;">XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</div></div></div></div></pre>
                <p>Мы не будем углябляться в детали этого кода, но в конечном счёте его смысл следующий: для простых типов (эквивалентных unsigned char) и для итераторов, являющихся указателями, вызывается memset. Эта функция не вызовется, если итератор
                    является <em>обёрткой</em> над указателем, как это иногда случается с итераторами вектора.</p>
                <p>Итого, в полной мере использовать понятие непрерывного итератора можно будет лишь в C++20 с помощью концептов, которые будут затронуты позже в нашей специализации.</p>
                <p><strong>Полный список требований</strong> к contiguous-итераторам находится <a href="https://en.cppreference.com/w/cpp/named_req/ContiguousIterator" target="_blank" rel="noopener nofollow">здесь</a>.</p>
                <h2></h2>
                <h2>vector&lt;bool&gt;::iterator</h2>
                <p>Выше мы утаили неудобную правду про итераторы <a href="https://en.cppreference.com/w/cpp/container/vector_bool" target="_blank" rel="noopener nofollow">контейнера vector&lt;bool&gt;</a>: оказывается, они не являются не то что непрерывными,
                    а даже forward!</p>
                <p>Дело в том, что vector&lt;bool&gt; устроен так, что каждый элемент занимает в нём не один байт (как одна переменная типа bool), а один бит. С одной стороны, это в 8 раз эффективнее по памяти, с другой — <strong>не существует ссылки на бит.</strong>                    Что же тогда возвращает *it для таких итераторов?</p>
                <p>Результат этого выражения — так называемый <em>прокси-объект:</em> он ведёт себя как ссылка, при этом ссылкой не являясь. Он умеет неявно преобразоваться в bool, ему можно присвоить bool, но это не bool&amp;. Таким образом, нарушается
                    формальное требование к forward-итераторам: *it должно возвращать именно ссылку на элемент.</p>
                <p>Тем не менее, по правилам хорошего тона итераторы vector&lt;bool&gt; часто поддерживаются наравне с итераторами других векторов, и формальное требование про ссылку оказывается избыточным.</p>
                <p>В одной из задач этого блока вам понадобится получить по типу итератора It (или переменной it) тип нижележащего значения. Те, кто знакомы с decltype, могут предложить использовать для этого выражение decltype(*it). Но из-за этих же нестандартных
                    итераторов *it не будет ссылкой на bool, и поэтому лучше использовать typename It::value_type. Самый же универсальный способ, работающий в том числе и для сырых указателей, — typename iterator_traits&lt;It&gt;::value_type.</p>
            </div>
            <hr>
        </div>
        <div class="slide">
            <label for="slide-classes">
                <h3>Classes / Классы</h3> 
            </label>
            <input type="checkbox" id="slide-classes" />
            <div class="slide-text">
                <p><span class="font-bold">Классы в С++</span> – это абстракция, описывающая методы и свойства ещё не существующих объектов. Объекты – конкретное представление абстракции, имеющее свои свойства и методы. Созданные объекты на основе одного
                    класса называются экземплярами этого класса. Эти объекты могут иметь различное поведение, свойства, но все равно будут являться объектами одного класса.</p>
                <ol>
                    <p>В <span class="font-bold">ООП</span> существует три основных принципа построения классов:</p>
                    <li><span class="font-bold">Инкапсуляция</span> – это свойство, позволяющее объединить в классе данные и методы, работающие с ними и скрыть детали реализации от пользователя.</li>
                    <li><span class="font-bold">Наследование</span> – это свойство, позволяющее создать новый класс-потомок на основе уже существующего, при этом все характеристики класса родителя присваиваются классу-потомку.</li>
                    <li><span class="font-bold">Полиморфизм</span> – свойство классов, позволяющее использовать объекты классов с одинаковым интерфейсом без информации о типе и внутренней структуре объекта.</li>
                </ol>
                <p>А теперь рассмотрим структуру объявления классов:</p>
                <p class="cpp_code">// объявление классов в С++</p>
                <p class="cpp_code">class /*имя класса*/</p>
                <p class="cpp_code">{</p>
                <p class="cpp_code_1t">private:</p>
                <p class="cpp_code_2t">/* список свойств и методов для использования внутри класса */</p>
                <p class="cpp_code_1t"> public:</p>
                <p class="cpp_code_2t"> /* список методов доступных другим функциям и объектам программы */</p>
                <p class="cpp_code_1t">protected:</p>
                <p class="cpp_code_2t">/*список средств, доступных при наследовании*/</p>
                <p class="cpp_code">};</p>
                <p>Объявление класса начинается с зарезервированного ключевого слова <span class="font-bold font-italic">class</span>, после которого пишется имя класса. В фигурных скобках, строки 3 — 10 объявляется тело класса, причём после закрывающейся
                    скобки обязательно нужно ставить точку с запятой, строка 10. В теле класса объявляются три метки спецификации доступа, строки 4, 6, 8, после каждой метки нужно ставить двоеточие. В строке 4 объявлена метка спецификатора доступа
                    <span class="font-bold font-italic">private</span>. Все методы и свойства класса, объявленные после спецификатор доступа <span class="font-bold font-italic">private</span> будут доступны только внутри класса. В строке 6 объявлен спецификатор
                    доступа <span class="font-bold font-italic">public</span>, все методы и свойства класса, объявленные после спецификатора доступа <span class="font-bold font-italic">public</span> будут доступны другим функциям и объектам в программе.</p>
                <p>При объявлении класса, не обязательно объявлять три спецификатора доступа, и не обязательно их объявлять в таком порядке. Но лучше сразу определиться с порядком объявления спецификаторов доступа, и стараться его придерживаться. </p>
                <p>Разработаем программу, в которой объявим простейший класс, в котором будет объявлена одна функция, печатающая сообщение:</p>
                <p class="cpp_code">// classes.cpp: определяет точку входа для консольного приложения.</p>
                <br>
                <p class="cpp_code">#include "stdafx.h"</p>
                <p class="cpp_code">#include &lt;iostream&gt;</p>
                <br>
                <p class="cpp_code">using namespace std;</p>
                <br>
                <p class="cpp_code">// начало объявления класса</p>
                <p class="cpp_code">class CppStudio // имя класса</p>
                <p class="cpp_code">{</p>
                <p class="cpp_code_1t">public: // спецификатор доступа</p>
                <p class="cpp_code_2t">void message() // функция (метод класса) выводящая сообщение на экран</p>
                <p class="cpp_code_2t">{</p>
                <p class="cpp_code_3t">cout &lt;&lt; "website: cppstudio. comntheme: Classes and Objects in C + +n";</p>
                <p class="cpp_code_2t">}</p>
                <p class="cpp_code">}; // конец объявления класса CppStudio</p>
                <br>
                <p class="cpp_code">int main(int argc, char* argv[])</p>
                <p class="cpp_code">{</p>
                <p class="cpp_code_1t">CppStudio objMessage; // объявление объекта</p>
                <p class="cpp_code_1t">objMessage.message(); // вызов функции класса message</p>
                <br>
                <p class="cpp_code_1t">system("pause");</p>
                <p class="cpp_code_1t">return 0;</p>
                <br>
                <p class="cpp_code">}</p>
                <p>В строках 7 — 14 мы определили класс с именем <span class="font-bold font-italic">CppStudio</span>. Имя класса принято начинать с большой буквы, последующие слова в имени также должны начинаться с большой буквы. В теле класса объявлен
                    спецификатор доступа <span class="font-bold font-italic">public</span>, который позволяет вызывать другим функциям методы класса, объявленные после <span class="font-bold font-italic">public</span>. Вот именно поэтому в главной функции,
                    в строке 19 мы смогли вызвать функцию message. В классе <span class="font-bold font-italic">CppStudio</span> объявлена всего одна функция, которая не имеет параметров и выводит сообщение на экран, строка 12. В строке 18 объявлена переменная
                    <span class="font-bold font-italic">objMessage</span> типа <span class="font-bold font-italic">CppStudio</span>, так вот, переменная <span class="font-bold font-italic">objMessage</span> — это объект класса <span class="font-bold font-italic">CppStudio</span>.
                    Таким образом, класс является сложным типом данных. После того как объект класса объявлен, можно воспользоваться его методами. Метод всего один — функция message. Для этого обращаемся к методу объекта objMessage через точку, как показано
                    в строке 19, в результате программа выдаст текстовое сообщение.</p>
                <hr>
                <div class="slide" style="padding-left: 3%;">
                    <label for="slide-set_get_classes">
                        <h3>Set and get class functions / Set и get функции классов</h3> 
                    </label>
                    <input type="checkbox" id="slide-set_get_classes" />
                    <div class="slide-text">
                        <p>Каждый объект имеет какие-то свои свойства или атрибуты, которые характеризуют его на протяжении всей жизни. Атрибуты объекта хранятся в переменных, объявленных внутри класса, которому принадлежит данный объект. Причём, объявление
                            переменных должно выполняться со спецификатором доступа <span class="font-bold font-italic">private</span>. Такие переменные называются элементами данных. Так как элементы данных объявлены в <span class="font-bold font-italic">private</span>,
                            то и доступ к ним могут получить только методы класса, внешний доступ к элементам данных запрещён. Поэтому принято объявлять в классах специальные методы — так называемые <span class="font-bold font-italic">set</span> и
                            <span class="font-bold font-italic">get функции</span>, с помощью которых можно манипулировать элементами данных. <span class="font-bold font-italic">Set-функции</span> инициализируют элементы данных, <span class="font-bold font-italic">get-функции</span>                            позволяют просмотреть значения элементов данных. Класс <span class="font-bold font-italic">CppStudio</span> можно доработать так, чтобы в нём можно было хранить дату в формате <span class="font-italic">дд.мм.гг</span>. Для
                            изменения и просмотра даты реализуем <span class="font-bold font-italic">set</span> и <span class="font-bold font-italic">get</span> функции.</p>
                    </div>
                </div>
                <hr>
                <div class="slide" style="padding-left: 3%;">
                    <label for="slide-constructors_classes">
                        <h3>Constructors / Конструкторы</h3> 
                    </label>
                    <input type="checkbox" id="slide-constructors_classes" />
                    <div class="slide-text">
                        <p><span class="font-bold">Конструктор</span> — специальная функция, которая выполняет начальную инициализацию элементов данных, причём имя конструктора обязательно должно совпадать с именем класса. Важным отличием конструктора от
                            остальных функций является то, что он не возвращает никаких значений, в том числе и <span class="font-bold font-italic">void</span>. В любом классе должен быть конструктор, даже если явным образом конструктор не объявлен (как
                            в предыдущем классе), то компилятор предоставляет конструктор по умолчанию, без параметров.</p>
                        <p>Доработаем класс <span class="font-bold font-italic">CppStudio</span>, добавив к нему конструктор:</p>
                        <p class="cpp_code">// classes.cpp: определяет точку входа для консольного приложения.</p>
                        <br>
                        <p class="cpp_code">#include "stdafx.h"</p>
                        <p class="cpp_code">#include &lt;iostream&gt;</p>
                        <br>
                        <p class="cpp_code">using namespace std;</p>
                        <br>
                        <p class="cpp_code">class CppStudio // имя класса</p>
                        <p class="cpp_code">{</p>
                        <p class="cpp_code_1t">private: // спецификатор доступа private</p>
                        <p class="cpp_code_2t">int day, // день</p>
                        <p class="cpp_code_2t">month, // месяц</p>
                        <p class="cpp_code_2t">year; // год</p>
                        <p class="cpp_code_1t">public: // спецификатор доступа public</p>
                        <p class="cpp_code_2t">CppStudio(int date_day, int date_month, int date_year ) // конструктор класса</p>
                        <p class="cpp_code_2t">{</p>
                        <p class="cpp_code_3t">setDate(date_day, date_month, date_year); // вызов функции установки даты</p>
                        <p class="cpp_code_2t">}</p>
                        <p class="cpp_code_2t">void message() // функция (метод класса) выводящая сообщение на экран</p>
                        <p class="cpp_code_2t">{</p>
                        <p class="cpp_code_3t">cout &lt;&lt; "nwebsite: cppstudio.comntheme: Classes and Objects in C + +n";</p>
                        <p class="cpp_code_2t">}</p>
                        <p class="cpp_code_2t">void setDate(int date_day, int date_month, int date_year) // установка даты в формате дд.мм.гг</p>
                        <p class="cpp_code_2t">{</p>
                        <p class="cpp_code_3t">day = date_day; // инициализация день</p>
                        <p class="cpp_code_3t">month = date_month; // инициализация месяц</p>
                        <p class="cpp_code_3t">year = date_year; // инициализация год</p>
                        <p class="cpp_code_2t">}</p>
                        <p class="cpp_code_2t">void getDate() // отобразить текущую дату</p>
                        <p class="cpp_code_2t">{</p>
                        <p class="cpp_code_3t">cout &lt;&lt; "date: " &lt;&lt; day &lt;&lt; "." &lt;&lt; month &lt;&lt; "." &lt;&lt; year &lt;&lt; endl;</p>
                        <p class="cpp_code_2t">}</p>
                        <p class="cpp_code">}; // конец объявления класса CppStudio</p>
                        <br>
                        <p class="cpp_code">int main(int argc, char* argv[])</p>
                        <p class="cpp_code">{</p>
                        <p class="cpp_code_1t">CppStudio objCppstudio(11,11,2011); // объявление объекта и инициализация элементов данных</p>
                        <p class="cpp_code_1t">objCppstudio.message(); // вызов функции message</p>
                        <p class="cpp_code_1t">objCppstudio.getDate(); // отобразить дату</p>
                        <br>
                        <p class="cpp_code_1t">system("pause");</p>
                        <br>
                        <p class="cpp_code_1t">return 0;</p>
                        <p class="cpp_code">}</p>
                        <p>Конструктор объявлен в строках 13 — 16. Конструктор имеет три параметра, через которые он получает информацию о дате, в теле конструктора вызывается set — функция для установки даты. В строке 35 объявляем объект класса, причём
                            после имени объекта в круглых скобках передаём три аргумента.</p>
                    </div>
                </div>
                <hr>
                <div class="slide" style="padding-left: 3%;">
                    <label for="slide-declaration_classes">
                        <h3>Class constructor and destructor / Конструктор и деструктор классов</h3> 
                    </label>
                    <input type="checkbox" id="slide-declaration_classes" />
                    <div class="slide-text">
                        <p>Конструктор (construct — создавать) – это специальный метод класса, который предназначен для инициализации элементов класса некоторыми начальными значениями.</p>
                        <p>В отличии от конструктора, деструктор (destruct — разрушать) — специальный метод класса, который служит для уничтожения элементов класса. Чаще всего его используют тогда, когда в конструкторе, при создании объекта класса, динамически
                            был выделен участок памяти и необходимо эту память очистить, если эти значения уже не нужны для дальнейшей работы программы.</p>
                        <div class="atention">
                            <h4>Важно запомнить:</h4>
                            <p>Конструктор и деструктор, мы всегда объявляем в разделе public. </p>
                            <p>При объявлении конструктора, тип данных возвращаемого значения не указывается, в том числе — void!!!. </p>
                            <p>У деструктора также нет типа данных для возвращаемого значения, к тому же деструктору нельзя передавать никаких параметров. </p>
                            <p>Имя класса и конструктора должно быть идентично. </p>
                            <p>Имя деструктора идентично имени конструктора, но с приставкой ~.</p>
                            <p>В классе допустимо создавать несколько конструкторов, если это необходимо. Имена, согласно пункту 2 нашего списка, будут одинаковыми. Компилятор будет их различать по передаваемым параметрам (как при перегрузке функций). Если
                                мы не передаем в конструктор параметры, он считается конструктором по умолчанию. </p>
                            <p>Обратите внимание на то, что в классе может быть объявлен только один деструктор. </p>
                        </div>
                        <p>Теперь приведём пример работы конструктора:</p>
                        <p class="cpp_code"># include &lt;iostream&gt;</p>
                        <br>
                        <p class="cpp_code">using namespace std;</p>
                        <br>
                        <p class="cpp_code">class AB //класс</p>
                        <p class="cpp_code">{</p>
                        <p class="cpp_code_1t">private:</p>
                        <p class="cpp_code_2t">int a;</p>
                        <p class="cpp_code_2t">int b;</p>
                        <p class="cpp_code_1t">public:</p>
                        <p class="cpp_code_2t">AB() //это конструктор: 1) у конструктора нет типа возвращаемого значения! в том числе void!!!</p>
                        <p class="cpp_code_2t">// 2) имя должно быть таким как и у класса (в нашем случае AB)</p>
                        <p class="cpp_code_2t">{</p>
                        <p class="cpp_code_3t">a = 0;//присвоим начальные значения переменным</p>
                        <p class="cpp_code_3t">b = 0;</p>
                        <p class="cpp_code_3t">cout &lt;&lt; "Работа конструктора при создании нового объекта: " &lt;&lt; endl;//и здесь же их отобразим на экран</p>
                        <p class="cpp_code_3t">cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; endl;</p>
                        <p class="cpp_code_3t">cout &lt;&lt; "b = " &lt;&lt; b &lt;&lt; endl &lt;&lt; endl;</p>
                        <p class="cpp_code_2t">}</p>
                        <p class="cpp_code_2t">void setAB() // с помощью этого метода изменим начальные значения заданные конструктором</p>
                        <p class="cpp_code_2t">{</p>
                        <p class="cpp_code_3t">cout &lt;&lt; "Введите целое число а: ";</p>
                        <p class="cpp_code_3t">cin >> a;</p>
                        <p class="cpp_code_3t">cout &lt;&lt; "Введите целое число b: ";</p>
                        <p class="cpp_code_3t">cin >> b;</p>
                        <p class="cpp_code_2t">}</p>
                        <p class="cpp_code_2t">void getAB() //выведем на экран измененные значения</p>
                        <p class="cpp_code_2t">{</p>
                        <p class="cpp_code_3t">cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; endl;</p>
                        <p class="cpp_code_3t">cout &lt;&lt; "b = " &lt;&lt; b &lt;&lt; endl &lt;&lt; endl;</p>
                        <p class="cpp_code_2t">}</p>
                        <p class="cpp_code">};</p>
                        <br>
                        <p class="cpp_code">int main()</p>
                        <p class="cpp_code">{</p>
                        <p class="cpp_code_1t">setlocale(LC_ALL, "rus");</p>
                        <p class="cpp_code_1t">AB obj1; //конструктор сработает на данном этапе (во время создания объекта класса)</p>
                        <p class="cpp_code_1t">obj1.setAB(); //присвоим новые значения переменным</p>
                        <p class="cpp_code_1t">obj1.getAB(); //и выведем их на экран</p>
                        <p class="cpp_code_1t">AB obj2; //конструктор сработает на данном этапе (во время создания 2-го объекта класса)</p>
                        <p class="cpp_code_1t">return 0;</p>
                        <p class="cpp_code">}</p>
                        <p>В результате работы программы мы получаем такой результат:</p>
                        <p class="cpp_code">Работа конструктора при создании нового объекта: </p>
                        <p class="cpp_code">a = 0</p>
                        <p class="cpp_code">b = 0</p>
                        <br>
                        <p class="cpp_code">Введите целое число а: 34</p>
                        <p class="cpp_code">Введите целое число b: 67</p>
                        <p class="cpp_code">a = 34</p>
                        <p class="cpp_code">b = 67</p>
                        <br>
                        <p class="cpp_code">Работа конструктора при создании нового объекта:</p>
                        <p class="cpp_code">a = 0</p>
                        <p class="cpp_code">b = 0</p>
                        <p>Как видно из результата работы программы, конструктор срабатывает сразу, при создании объектов класса, поэтому вызывать конструктор не нужно, он сам «приходит».</p>
                        <p>Также, как и обычным функциям можно передавать конструктору параметры. Через параметры, конструктору можно передавать любые данные, которые будут необходимы при инициализации объектов класса.</p>
                        <p>Рассмотрим еще один пример, это та же программа, только в код внесены некоторые изменения.</p>
                        <p>Сейчас мы покажем принцип работы деструктора:</p>
                        <p class="cpp_code"># include &lt;iostream&gt;</p>
                        <br>
                        <p class="cpp_code">using namespace std;</p>
                        <br>
                        <p class="cpp_code">class AB //класс</p>
                        <p class="cpp_code">{</p>
                        <p class="cpp_code_1t">private:</p>
                        <p class="cpp_code_2t">int a;</p>
                        <p class="cpp_code_2t">int b;</p>
                        <p class="cpp_code_1t">public:</p>
                        <p class="cpp_code_2t">AB(int A, int B) //эти параметры мы передадим при создании объекта в main</p>
                        <p class="cpp_code_2t">{</p>
                        <p class="cpp_code_3t">a = A;//присвоим нашим элементам класса значения параметров</p>
                        <p class="cpp_code_3t">b = B;</p>
                        <p class="cpp_code_3t">cout &lt;&lt; "Тут сработал конструктор, который принимает параметры: " &lt;&lt; endl;//и здесь же их отобразим на экран</p>
                        <p class="cpp_code_3t">cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; endl;</p>
                        <p class="cpp_code_3t">cout &lt;&lt; "b = " &lt;&lt; b &lt;&lt; endl &lt;&lt; endl;</p>
                        <p class="cpp_code_2t">}</p>
                        <br>
                        <p class="cpp_code_2t">void setAB()</p>
                        <p class="cpp_code_2t">{</p>
                        <p class="cpp_code_3t">cout &lt;&lt; "Введите целое число а: ";</p>
                        <p class="cpp_code_3t">cin >> a;</p>
                        <p class="cpp_code_3t">cout &lt;&lt; "Введите целое число b: ";</p>
                        <p class="cpp_code_3t">cin >> b;</p>
                        <p class="cpp_code_2t">}</p>
                        <br>
                        <p class="cpp_code_2t">void getAB()</p>
                        <p class="cpp_code_2t">{</p>
                        <p class="cpp_code_3t">cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; endl;</p>
                        <p class="cpp_code_3t">cout &lt;&lt; "b = " &lt;&lt; b &lt;&lt; endl &lt;&lt; endl;</p>
                        <p class="cpp_code_2t">}</p>
                        <br>
                        <p class="cpp_code_2t">~AB() // это деструктор. не будем заставлять его чистить память, пусть просто покажет где он сработал</p>
                        <p class="cpp_code_2t">{</p>
                        <p class="cpp_code_3t">cout &lt;&lt; "Тут сработал деструктор" &lt;&lt; endl;</p>
                        <p class="cpp_code_2t">}</p>
                        <p class="cpp_code">};</p>
                        <br>
                        <p class="cpp_code">int main()</p>
                        <p class="cpp_code">{</p>
                        <p class="cpp_code_1t">setlocale(LC_ALL, "rus");</p>
                        <p class="cpp_code_1t">AB obj1(100, 100); //передаем конструктору параметры</p>
                        <p class="cpp_code_1t">obj1.setAB(); //присвоим новые значения переменным</p>
                        <p class="cpp_code_1t">obj1.getAB(); //и выведем их на экран</p>
                        <p class="cpp_code_1t">AB obj2(200, 200); //передаем конструктору параметры</p>
                        <p class="cpp_code">}</p>
                        <p>Теперь посмотрим результат работы программы:</p>
                        <p class="cpp_code">Тут сработал конструктор, который принимает параметры:</p>
                        <p class="cpp_code">a = 100</p>
                        <p class="cpp_code">b = 100</p>
                        <br>
                        <p class="cpp_code">Введите целое число а: 333</p>
                        <p class="cpp_code">Введите целое число b: 333</p>
                        <p class="cpp_code">a = 333</p>
                        <p class="cpp_code">b = 333</p>
                        <br>
                        <p class="cpp_code">Тут сработал конструктор, который принимает параметры: </p>
                        <p class="cpp_code">a = 200</p>
                        <p class="cpp_code">b = 200</p>
                        <br>
                        <p class="cpp_code">Тут сработал деструктор</p>
                        <p class="cpp_code">Тут сработал деструктор</p>
                        <p>Деструктор срабатывает в тот момент, когда завершается работа программы и уничтожаются все данные. Мы его не вызывали – он сработал сам. Как видно, он сработал 2 раза, как и конструктор. В первую очередь, он удалил второй созданный
                            объект (где a = 200, b = 200), а затем первый (где a = 100, b = 100).</p>
                    </div>
                </div>
                <hr>
                <div class="slide" style="padding-left: 3%;">
                    <label for="slide-declaration_classes">
                        <h3>Class declaration in a separate file / Объявление класса в отдельном файле</h3> 
                    </label>
                    <input type="checkbox" id="slide-declaration_classes" />
                    <div class="slide-text">
                        <p>Класс необходимо объявлять в отдельном файле, чтобы его можно было неоднократно использовать. Ранее мы объявляли в отдельном файле функции, таким же образом размещается класс в отдельном файле.</p>
                        <ol>
                            <p>Для этого необходимо выполнить 3 шага:</p>
                            <li>Добавить в проект заголовочный файл <span class="font-bold font-italic">*.h.</span></li>
                            <li>В заголовочном файле объявить пользовательский класс, в нашем случае — <span class="font-bold font-italic">CppStudio</span>.</li>
                            <li>Подключить заголовочный файл к программе, в нашем случае — <span class="font-bold font-italic">#include "CppStudio.h"</span></li>
                        </ol>
                        <p>В <span class="font-bold font-italic">MVS2022</span> заголовочный файл можно добавить, вызвав контекстное меню в «обозревателе решений», выбрав пункт «создать новый элемент». В появившемся диалоговом окне выбираем нужный тип файла
                            — это <span class="font-bold font-italic">*.h</span> и заполняем поле «Имя файла». Имя выбираем осмысленное, как правило такое же, как и имя класса. Теперь к нашему проекту добавлен новый заголовочный файл — <span class="font-bold font-italic">CppStudio.h</span>.</p>
                        <p>В только что созданном заголовочном файле объявляем класс и, если необходимо, подключаем дополнительные заголовочные. Вот, что должно получиться:</p>
                        <p class="cpp_code">// заголовочный файл CppStudio.h</p>
                        <br>
                        <p class="cpp_code">#include &lt;iostream&gt;</p>
                        <br>
                        <p class="cpp_code">using namespace std;</p>
                        <br>
                        <p class="cpp_code">// объявление класса</p>
                        <p class="cpp_code">class CppStudio // имя класса</p>
                        <p class="cpp_code">{</p>
                        <p class="cpp_code_1t">private: // спецификатор доступа private</p>
                        <p class="cpp_code_2t">int day, // день</p>
                        <p class="cpp_code_2t">month, // месяц</p>
                        <p class="cpp_code_2t">year; // год</p>
                        <p class="cpp_code_1t">public: // спецификатор доступа public</p>
                        <p class="cpp_code_2t">CppStudio(int date_day, int date_month, int date_year ) // конструктор класса</p>
                        <p class="cpp_code_2t">{</p>
                        <p class="cpp_code_3t">setDate(date_day, date_month, date_year); // вызов функции установки даты</p>
                        <p class="cpp_code_2t">}</p>
                        <p class="cpp_code_2t">void message() // функция (метод класса) выводящая сообщение на экран</p>
                        <p class="cpp_code_2t">{</p>
                        <p class="cpp_code_3t">cout &lt;&lt; "nwebsite: cppstudio.comntheme: Classes and Objects in C + +n";</p>
                        <p class="cpp_code_2t">}</p>
                        <p class="cpp_code_2t">void setDate(int date_day, int date_month, int date_year) // установка даты в формате дд.мм.гг</p>
                        <p class="cpp_code_2t">{</p>
                        <p class="cpp_code_3t">day = date_day; // инициализация день</p>
                        <p class="cpp_code_3t">month = date_month; // инициализация месяц</p>
                        <p class="cpp_code_3t"> year = date_year; // инициализация год</p>
                        <p class="cpp_code_2t">}</p>
                        <p class="cpp_code_2t">void getDate() // отобразить текущую дату</p>
                        <p class="cpp_code_2t">{</p>
                        <p class="cpp_code_3t">cout &lt;&lt; "date: " &lt;&lt; day &lt;&lt; "." &lt;&lt; month &lt;&lt; "." &lt;&lt; year &lt;&lt; endl;</p>
                        <p class="cpp_code_2t">}</p>
                        <p class="cpp_code">}; // конец объявления класса CppStudio</p>
                        <p>Чтобы главная функция увидела созданный нами класс и смогла его использовать, необходимо включить определение класса в исполняемом файле, с функцией main.</p>
                        <p>Вот как это сделать:</p>
                        <p class="cpp_code">// classes.cpp: определяет точку входа для консольного приложения.</p>
                        <br>
                        <p class="cpp_code">#include "stdafx.h"</p>
                        <p class="cpp_code">// подключаем класс CppStudio</p>
                        <p class="cpp_code">#include "CppStudio.h"</p>
                        <br>
                        <p class="cpp_code">int main(int argc, char*argv[])</p>
                        <p class="cpp_code">{</p>
                        <p class="cpp_code_1t">CppStudio objCppstudio(11,11,2011); // объявление объекта и инициализвция элементов данных</p>
                        <p class="cpp_code_1t">objCppstudio.message(); // вызов функции message</p>
                        <p class="cpp_code_1t">objCppstudio.getDate(); // отобразить дату</p>
                        <p class="cpp_code_1t">system("pause");</p>
                        <p class="cpp_code_1t">return 0;</p>
                        <p class="cpp_code">}</p>
                        <p>В пятой строке подключено определение класса CppStudio, только после этого можно создавать объекты класса, использовать его методы и так далее.</p>
                    </div>
                </div>
                <hr>
                <div class="slide" style="padding-left: 3%;">
                    <label for="slide-Implementation_classes">
                            <h3>Separating the Interface from the Implementation / Отделение интерфейса от реализации</h3> 
                        </label>
                    <input type="checkbox" id="slide-Implementation_classes" />
                    <div class="slide-text">
                        <p><span class="font-bold font-italic">Интерфейс класса</span> — конструкция, определяющая методы и свойства, предоставляемые классом.</p>
                        <p><span class="font-bold font-italic">Реализация класса</span> — способ осуществления работоспособности класса.</p>
                        <p><span class="font-bold font-italic">Отделение</span> интерфейса от <span class="font-bold font-italic">реализации</span> класса выполняется для того, чтобы скрыть способ осуществления работоспособности класса.</p>
                        <ol>
                            <p>Отделение интерфейса от реализации выполняется за 5 шагов:</p>
                            <li>Добавить в проект заголовочный файл *.h.</li>
                            <li>Определить интерфейс класса в заголовочном файле.</li>
                            <li>Добавить в проект исполняемый файл *.cpp.</li>
                            <li>В исполняемом файле выполнить реализацию класса.</li>
                            <li>Подключить заголовочный файл к программе.</li>
                        </ol>
                        <p>Теперь рассмотрим, как должен выглядеть интерфейс класса:</p>
                        <p class="cpp_code">// заголовочный файл класса СppStudio.h</p>
                        <p class="cpp_code">// интерфейс класса</p>
                        <br>
                        <p class="cpp_code">// объявление класса</p>
                        <p class="cpp_code">class CppStudio // имя класса</p>
                        <p class="cpp_code">{</p>
                        <p class="cpp_code_1t">private: // спецификатор доступа private</p>
                        <p class="cpp_code_2t">int day, // день</p>
                        <p class="cpp_code_2t">month, // месяц</p>
                        <p class="cpp_code_2t">year; // год</p>
                        <p class="cpp_code_1t">public: // спецификатор доступа public</p>
                        <p class="cpp_code_2t">CppStudio(int, int, int); // конструктор класса</p>
                        <p class="cpp_code_2t">void message(); // функция (метод класса) выводящая сообщение на экран</p>
                        <p class="cpp_code_2t">void setDate(int, int, int); // установка даты в формате дд.мм.гг</p>
                        <p class="cpp_code_2t">void getDate(); // отобразить текущую дату</p>
                        <p class="cpp_code">}; // конец объявления класса CppStudio</p>
                        <p>В интерфейсе класса остались объявленные переменные и прототипы методов класса.</p>
                        <p>Теперь рассмотрим содержимое файла реализации методов класса:</p>
                        <p class="cpp_code">// файл реализации класса CppStudio.cpp</p>
                        <br>
                        <p class="cpp_code">#include &lt;iostream&gt;</p>
                        <br>
                        <p class="cpp_code">using namespace std;</p>
                        <br>
                        <p class="cpp_code">// подключаем интерфейс класса к файлу его реализации</p>
                        <p class="cpp_code">#include "CppStudio.h"</p>
                        <br>
                        <p class="cpp_code">CppStudio::CppStudio(int date_day, int date_month, int date_year ) // конструктор класса</p>
                        <p class="cpp_code">{</p>
                        <p class="cpp_code_1t">setDate(date_day, date_month, date_year); // вызов функции установки даты</p>
                        <p class="cpp_code">}</p>
                        <br>
                        <p class="cpp_code">void CppStudio::message() // функция (метод класса) выводящая сообщение на экран</p>
                        <p class="cpp_code">{</p>
                        <p class="cpp_code_1t">cout &lt;&lt; "nwebsite: cppstudio.comntheme: Classes and Objects in C + +n";</p>
                        <p class="cpp_code">}</p>
                        <br>
                        <p class="cpp_code">void CppStudio::setDate(int date_day, int date_month, int date_year) // установка даты в формате дд.мм.гг</p>
                        <p class="cpp_code">{</p>
                        <p class="cpp_code_1t">day = date_day; // инициализация день</p>
                        <p class="cpp_code_1t">month = date_month; // инициализация месяц</p>
                        <p class="cpp_code_1t">year = date_year; // инициализация год</p>
                        <p class="cpp_code">}</p>
                        <br>
                        <p class="cpp_code">void CppStudio::getDate() // отобразить текущую дату</p>
                        <p class="cpp_code">{</p>
                        <p class="cpp_code_1t">cout &lt;&lt; "date: " &lt;&lt; day &lt;&lt; "." &lt;&lt; month &lt;&lt; "." &lt;&lt; year &lt;&lt; endl;</p>
                        <p class="cpp_code">}</p>
                        <p>Чтобы связать интерфейс класса и его реализацию, необходимо в файле реализации подключить заголовочный файл с определением класса, строка 6. После этого можно объявлять методы класса.</p>
                        <p>Методы класса объявляются точно так же как и функции, только перед именем метода необходимо написать имя класса и поставить унарную операцию разрешения области действия &laquo;::&raquo;:</p>
                        <p class="cpp_code">// синтаксис объявления методов класса вне тела класса</p>
                        <p class="cpp_code">/*возвращаемый тип данных*/ /*имя класса*/::/*имя метода*/(/*параметры метода*/)</p>
                        <p class="cpp_code">{</p>
                        <p class="cpp_code_1t">// операторы</p>
                        <p class="cpp_code">}</p>
                        <p>Так как методы класса объявляются вне тела класса, то необходимо связать реализацию метода с классом, для этого используется бинарная операция разрешения области действия. Эта операция привязывает метод, объявленный извне, к классу,
                            имя которого совпадает с именем в объявлении метода. Поэтому в объявлении метода класса необходимо добавлять имя класса и операцию разрешения области действия.</p>
                        <p>Теперь, когда интерфейс класса определён, методы класса объявлены, осталось подключить заголовочный файл в исполняемом файле с функцией main и программа готова.</p>
                        <p class="cpp_code">// classes.cpp: определяет точку входа для консольного приложения.</p>
                        <br>
                        <p class="cpp_code">#include "stdafx.h"</p>
                        <br>
                        <p class="cpp_code">// подключаем класс CppStudio</p>
                        <p class="cpp_code">#include "CppStudio.h"</p>
                        <br>
                        <p class="cpp_code">int main(int argc, char*argv[])</p>
                        <p class="cpp_code">{</p>
                        <p class="cpp_code_1t">CppStudio objCppstudio(11,11,2011); // объявление объекта и инициализвция элементов данных</p>
                        <p class="cpp_code_1t">objCppstudio.message(); // вызов функции message</p>
                        <p class="cpp_code_1t">objCppstudio.getDate(); // отобразить дату</p>
                        <p class="cpp_code_1t">system("pause");</p>
                        <p class="cpp_code_1t">return 0;</p>
                        <p class="cpp_code">}</p>
                        <p>В строке 5 подключаем заголовочный файл класса, после чего можно создавать объекты этого класса.</p>
                    </div>
                </div>
                <hr>
                <p><a href="https://t.me/HowTo_C/101" target="_blank">Взято от сюда</a></p>
            </div>
            <hr>
        </div>
    </div>

    <script src="../../js/books.js"></script>

</body>