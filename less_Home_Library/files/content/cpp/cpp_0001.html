<head>
    <link rel="stylesheet" href="../../css/books_style.css">
</head>

<body>
    <div class="book-title">
        <h1>Сборник материалов</h1>
    </div>
    <div class="book-content">
        <div class="slide">
            <label for="slide-null_pointer">
                <h3>Null Pointers / Нулевые указатели</h3> 
            </label>
            <input type="checkbox" id="slide-null_pointer" />
            <div class="slide-text">
                <div class="slide">
                    <label for="slide-null_pointer_1">
                        <h4>1. What is this infamous null pointer, anyway? / Что это за печально известный нулевой указатель?</h4>
                    </label>
                    <input type="checkbox" id="slide-null_pointer_1" />
                    <div class="slide-text">
                        <table border="1">
                            <tr>
                                <th>English</th>
                                <th>Русский</th>
                            </tr>
                            <tr>
                                <td>
                                    <p>The language definition states that for each pointer type, there is a special value--the "null pointer"--which is distinguishable from all other pointer values and which is "guaranteed to compare unequal to a pointer
                                        to any object or function". That is, a null pointer points definitively nowhere; it is not the address of any object or function. The address-of operator & will never yield a null pointer, nor will a successful
                                        call to malloc.[footnote] (malloc does return a null pointer when it fails, and this is a typical use of null pointers: as a "special" pointer value with some other meaning, usually "not allocated" or "not pointing
                                        anywhere yet".)</p>
                                </td>
                                <td>
                                    <p>В определении языка говорится, что для каждого типа указателя существует специальное значение - "нулевой указатель" - которое можно отличить от всех других значений указателя и которое "гарантированно сравнивает неравное
                                        с указателем на любой объект или функцию". То есть, нулевой указатель нигде не указывает; это не адрес какого-либо объекта или функции. Оператор address-of & никогда не выдаст нулевой указатель, как и успешный вызов
                                        malloc. [Footnote] (malloc действительно возвращает нулевой указатель в случае сбоя, и это типичное использование нулевых указателей: в качестве "специального" значение указателя с некоторым другим значением, обычно
                                        "не выделено" или "еще нигде не указывает".)</p>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <p>A null pointer is conceptually different from an uninitialized pointer. A null pointer is known not to point to any object or function; an uninitialized pointer might point anywhere.</p>
                                </td>
                                <td>
                                    <p>Нулевой указатель концептуально отличается от неинициализированного указателя. Известно, что нулевой указатель не указывает на какой-либо объект или функцию; неинициализированный указатель может указывать куда угодно.
                                    </p>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <p>As mentioned above, there is a null pointer for each pointer type, and the internal values of null pointers for different types may be different. Although programmers need not know the internal values, the compiler
                                        must always be informed which type of null pointer is required, so that it can make the distinction if necessary.</p>
                                </td>
                                <td>
                                    <p>Как упомянуто выше, для каждого типа указателя существует нулевой указатель, и внутренние значения нулевых указателей для разных типов могут быть разными. Хотя программистам не нужно знать внутренние значения, компилятор
                                        всегда должен быть информирован о том, какой тип нулевого указателя требуется, чтобы он мог провести различие при необходимости.</p>
                                </td>
                            </tr>
                        </table>
                    </div>
                </div>
                <div class="slide">
                    <label for="slide-null_pointer_2">
                        <h4>2. How do I get a null pointer in my programs? / Как получить нулевой указатель в моих программах?</h4>
                    </label>
                    <input type="checkbox" id="slide-null_pointer_2" />
                    <div class="slide-text">
                        <table border="1">
                            <tr>
                                <th>English</th>
                                <th>Русский</th>
                            </tr>
                            <tr>
                                <td>
                                    <p>According to the language definition, an "integral constant expression with the value 0" in a pointer context is converted into a null pointer at compile time. That is, in an initialization, assignment, or comparison
                                        when one side is a variable or expression of pointer type, the compiler can tell that a constant 0 on the other side requests a null pointer, and generate the correctly-typed null pointer value. Therefore, the following
                                        fragments are perfectly legal:
                                    </p>
                                    <p>char *p = 0;</p>
                                    <p>if(p != 0)</p>
                                    <p>(See also question 3.)</p>
                                </td>
                                <td>
                                    <p>Согласно определению языка, "целочисленное константное выражение со значением 0" в контексте указателя преобразуется в нулевой указатель во время компиляции. То есть при инициализации, присваивании или сравнении, когда
                                        одна сторона является переменной или выражением типа указателя, компилятор может сказать, что константа 0 на другой стороне запрашивает нулевой указатель, и сгенерировать правильное значение нулевого указателя.
                                        Поэтому следующие фрагменты абсолютно законны:</p>
                                    <p>char *p = 0;</p>
                                    <p>if(p != 0)</p>
                                    <p>(См. вопрос 3.)</p>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <p>However, an argument being passed to a function is not necessarily recognizable as a pointer context, and the compiler may not be able to tell that an unadorned 0 ``means'' a null pointer. To generate a null pointer
                                        in a function call context, an explicit cast may be required, to force the 0 to be recognized as a pointer. For example, the Unix system call execl takes a variable-length, null-pointer-terminated list of character
                                        pointer arguments, and is correctly called like this:</p>
                                    <p>execl("/bin/sh", "sh", "-c", "date", (char *)0);</p>
                                </td>
                                <td>
                                    <p>Однако аргумент, передаваемый в функцию, не обязательно распознается как контекст указателя, и компилятор может быть не в состоянии сказать, что неукрашенный 0 "означает" нулевой указатель. Чтобы сгенерировать нулевой
                                        указатель в контексте вызова функции, может потребоваться явное приведение, чтобы заставить 0 быть распознанным как указатель. Например, системный вызов Unix execl принимает список аргументов указателей символов
                                        переменной длины, заканчивающийся нулевым указателем, и корректно вызывается так:</p>
                                    <p>execl("/bin/sh", "sh", "-c", "date", (char *)0);</p>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <p>If the (char *) cast on the last argument were omitted, the compiler would not know to pass a null pointer, and would pass an integer 0 instead. (Note that many Unix manuals get this example wrong; see also question
                                        11.)
                                    </p>
                                </td>
                                <td>
                                    <p>Если бы (char *) приведение к последнему аргументу было опущено, компилятор не знал бы, чтобы передать нулевой указатель, и вместо этого передал бы целое число 0. (Обратите внимание, что во многих руководствах по Unix
                                        этот пример неверен; см. Также вопрос 11.)</p>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <p>When function prototypes are in scope, argument passing becomes an ``assignment context,'' and most casts may safely be omitted, since the prototype tells the compiler that a pointer is required, and of which type,
                                        enabling it to correctly convert an unadorned 0. Function prototypes cannot provide the types for variable arguments in variable-length argument lists however, so explicit casts are still required for those arguments.
                                        It is probably safest to properly cast all null pointer constants in function calls, to guard against varargs functions or those without prototypes.</p>
                                </td>
                                <td>
                                    <p>Когда прототипы функций находятся в области видимости, передача аргументов становится `` контекстом присваивания '', и большинство приведений может быть безопасно опущено, так как прототип сообщает компилятору, что
                                        указатель необходим и какого типа, что позволяет ему правильно преобразовывать неукрашенные 0. Прототипы функций не могут предоставлять типы для переменных аргументов в списках аргументов переменной длины, поэтому
                                        для этих аргументов все еще требуется явное приведение. Вероятно, наиболее безопасным является правильное приведение всех констант нулевого указателя в вызовах функций для защиты от функций varargs или функций без
                                        прототипов.
                                    </p>
                                </td>
                            </tr>
                        </table>
                    </div>
                </div>
                <div class="slide">
                    <label for="slide-null_pointer_3">
                        <h4>Is the abbreviated pointer comparison "if(p)" to test for non-null pointers valid? What if the internal representation for null pointers is nonzero? / Допустимо ли сокращенное сравнение указателей "if (p)" для проверки ненулевых указателей? Что если внутреннее представление для нулевых указателей отлично от нуля?</h4>
                    </label>
                    <input type="checkbox" id="slide-null_pointer_3" />
                    <div class="slide-text">
                        <table border="1">
                            <tr>
                                <th>English</th>
                                <th>Русский</th>
                            </tr>
                            <tr>
                                <td>
                                    <p>When C requires the Boolean value of an expression, a false value is inferred when the expression compares equal to zero, and a true value otherwise. That is, whenever one writes</p>
                                    <p>if(expr)</p>
                                    <p>where "expr" is any expression at all, the compiler essentially acts as if it had been written as</p>
                                    <p>if((expr) != 0)</p>
                                    <p>Substituting the trivial pointer expression "p" for "expr", we have</p>
                                    <p>if(p) is equivalent to if(p != 0)</p>
                                    <p>and this is a comparison context, so the compiler can tell that the (implicit) 0 is actually a null pointer constant, and use the correct null pointer value. There is no trickery involved here; compilers do work this
                                        way, and generate identical code for both constructs. The internal representation of a null pointer does not matter.</p>
                                </td>
                                <td>
                                    <p>Когда C требует логического значения выражения, ложное значение выводится, когда выражение сравнивается равным нулю, и истинное значение в противном случае. То есть всякий раз, когда кто-то пишет</p>
                                    <p>if(expr)</p>
                                    <p>где "expr" - любое выражение вообще, компилятор по существу действует так, как если бы он был записан как</p>
                                    <p>if((expr) != 0)</p>
                                    <p>Подставляя тривиальное выражение-указатель «p» вместо «expr», получим</p>
                                    <p>if(p) эквивалентно if(p != 0)</p>
                                    <p>и это контекст сравнения, поэтому компилятор может сказать, что (неявный) 0 на самом деле является константой нулевого указателя, и использовать правильное значение нулевого указателя. Здесь нет хитрости; компиляторы
                                        работают таким образом и генерируют идентичный код для обеих конструкций. Внутреннее представление нулевого указателя не имеет значения.</p>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <p>The boolean negation operator, !, can be described as follows:</p>
                                    <p>!expr is essentially equivalent to (expr)?0:1</p>
                                    <p>or to ((expr) == 0)</p>
                                    <p>which leads to the conclusion that</p>
                                    <p>if(!p) is equivalent to if(p == 0)</p>
                                </td>
                                <td>
                                    <p>Оператор логического отрицания (!) может быть описан следующим образом:</p>
                                    <p>!expr по существу эквивалентно (expr)?0:1</p>
                                    <p>или ((expr) == 0)</p>
                                    <p>Что приводит к выводу, что</p>
                                    <p>if(!p) эквивалентно if(p == 0)</p>
                                </td>
                            </tr>
                        </table>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="../../js/books.js"></script>

</body>
<!--
    <div class="slide">
                    <label for="slide-null_pointer_xxx">
                        <h4> </h4>
                    </label>
                    <input type="checkbox" id="slide-null_pointer_xxx" />
                    <div class="slide-text">
                        <table border="1">
                            <tr>
                                <th>English</th>
                                <th>Русский</th>
                            </tr>
                            <tr>
                                <td>
                                    <p></p>
                                </td>
                                <td>
                                    <p></p>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <p></p>
                                </td>
                                <td>
                                    <p></p>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <p></p>
                                </td>
                                <td>
                                    <p></p>
                                </td>
                            </tr>
                        </table>
                    </div>
                </div>
-->