<head>
    <link rel="stylesheet" href="../../css/books_style.css">
</head>

<body>
    <div class="book-title">
        <p><a href="./1_03.html">&lArr;Правило 3: Везде, где только можно используйте const</a></p>
        <h1>Глава 1</h1>
        <h2>Правило 4: Прежде чем использовать объекты, убедитесь, что они инициализированы</h2>
        <hr>
        <div>
            <p>Отношение C++кинициализации значений объектов может показаться странным. Например, если вы пишете: </p>
            <p>int x;</p>
            <p>то в некоторых контекстах переменнаях будет гарантированно инициализирована нулем, а в других – нет. Если вы пишете: </p>
            <img src="1_04_01.png" alt="">
            <p>то члены-данные объекта р иногда будут инициализированы (нулями), а иногда - нет. Если Вы перешли к C++ от языка, где нейнициализированные объекты не могут существовать, обратите на это внимание.</p>
            <p>Чтение нейнициализированных значений может быть причиной неопределенного поведения. На некоторых платформах такое простое действие, как доступ к неинициированному значению для чтения, может вызвать аварийную остановку программы. Но чаще вы
                получите случайный набор битов, который испортит внутреннее состояние объекта, в который они записываются, и в конечном итоге это приведет к необъяснимому поведению программы и длительному поиску Ошибки В отладчике.</p>
            <p>Сформулируем правила, которые описывают, когда инициализация объекта гарантируется, а когда нет. К сожалению, эти правила достаточно сложны – на мой взгляд, слишком сложны, чтобы их стоило запоминать. Вообще, если вы работаете с C-частью C++
                (см. правило 1) и инициализация может стоить определенных затрат во время исполнения, то не гарантируется, что она произойдет. Это объясняет, Почему содержимое массивов (в C-части C++) не обязательно инициализируется, а содержимое вектора
                (из STL-части C++) инициализируется всегда.</p>
            <p>По-видимому, лучший способ поведения в такой неопределенной ситуации - всегда инициализировать объекты, прежде чем их использовать. Для объектов встроенных типов, не являющихся членами классов, это нужно делать вручную. Например:</p>
            <img src="1_04_02.png" alt="">
            <p>Почти во всех остальных случаях ответственность за инициализацию ложится на конструкторы. Правило простое: убедитесь, что все конструкторы инициализируют в объекте всё.</p>
            <p>Этому правилу легко следовать, но важно не путать присваивание с инициализацией. Рассмотрим конструктор класса, представляющего записи в адресной книге:</p>
            <img src="1_04_03.png" alt="">
            <p>Да, в результате порождаются объекты ABEntry со значениями, которых вы ожидаете, но это все же не лучший подход. Правила C++ оговаривают, что члены объекта инициируются перед входом в тело конструктора. То есть внутри конструктора ABEntry
                члены theName, theAddress и thePhones не инициализируются, а им присваиваются значения. Инициализация происходит ранее: когда автоматически вызываются их конструкторы перед входом в тело конструктора АВEntry. Это не касается numTimesConsulted,
                поскольку этот член относится к встроенному типу. Для него нет никаких гарантий того, что он вообще будет инициализирован перед присваиванием.</p>
            <p>Лучший способ написания конструктора ABEntry – использовать список Инициализации членов Вместо присваивания:</p>
            <img src="1_04_04.png" alt="">
            <p>Этот конструктор дает тот же самый конечный результат, что и предыдущий, но часто оказывается более эффективным. Версия, основанная на присваиваниях, сначала вызывает конструкторы по умолчанию для инициализации theName, theAddress и thePhоnеѕ,
                а затем сразу присваивает им новые значения, затирая те, что уже были присвоены в конструкторах по умолчанию. Таким образом, вся работа конструкторов по умолчанию тратится впустую. Подход со списком Инициализации членов позволяет избежать
                этой проблемы, поскольку аргументы в списке Инициализации используются в качестве аргументов Конструкторов для различных членов-данных. В этом случае theName создается конструктором копирования из name, theAddress - из address, thePhones
                – из рhоnеѕ. Для большинства типов единственный вызов конструктора копирования более эффективен – иногда намного более эффективен, чем вызов Конструкторов по умолчанию с последующим вызовом операторов присваивания.</p>
            <p>Для объектов встроенных типов вроде num TimesConsulted нет разницы по затратам между инициализацией и присваиванием, но для единообразия часто лучше инициировать все посредством списка инициализации членов. Такие списки можно применять даже
                тогда, когда данные-члены ИНИЦиализируются Конструкторами по умолчанию: просто не передавайте никаких аргументов соответствующему конструктору. Например, если у ABEntry есть конструктор, не принимающий параметров, то он может быть реализован
                примерно так:</p>
            <img src="1_04_05.png" alt="">
        </div>
        <div class="remember">
            <h3>Что следует помнить</h3>
            <li>Объявление чего-либо с модификатором соnѕt помогает компиляторам обнаруживать ошибки. const можно использовать с объектами в любой области действия, с параметрами функций и возвращаемых значений, а также с функциями-членами в целом.</li>
            <li>Компиляторы проверяют побитовую константность, но вы должны программировать, применяя логическую константность.</li>
            <li>Когда константные и неконстантные функции-члены имеют, по сути, одинаковую реализацию, то дублирования кода можно избежать, заставив неконстантную версию вызывать константную.</li>
        </div>
        <p><a href="./1_04.html">Правило 4: Прежде чем использовать объекты, убедитесь, что они инициализированы&rArr;</a></p>
    </div>
</body>