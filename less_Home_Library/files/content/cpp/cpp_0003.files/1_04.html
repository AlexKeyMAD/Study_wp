<head>
    <link rel="stylesheet" href="../../css/books_style.css">
</head>

<body>
    <div class="book-title">
        <p><a href="./1_03.html">&lArr;Правило 3: Везде, где только можно используйте const</a></p>
        <h1>Глава 1</h1>
        <h2>Правило 4: Прежде чем использовать объекты, убедитесь, что они инициализированы</h2>
        <hr>
        <div>
            <p>Отношение C++кинициализации значений объектов может показаться странным. Например, если вы пишете: </p>
            <p>int x;</p>
            <p>то в некоторых контекстах переменнаях будет гарантированно инициализирована нулем, а в других – нет. Если вы пишете: </p>
            <img src="1_04_01.png" alt="">
            <p>то члены-данные объекта р иногда будут инициализированы (нулями), а иногда - нет. Если Вы перешли к C++ от языка, где нейнициализированные объекты не могут существовать, обратите на это внимание.</p>
            <p>Чтение нейнициализированных значений может быть причиной неопределенного поведения. На некоторых платформах такое простое действие, как доступ к неинициированному значению для чтения, может вызвать аварийную остановку программы. Но чаще вы
                получите случайный набор битов, который испортит внутреннее состояние объекта, в который они записываются, и в конечном итоге это приведет к необъяснимому поведению программы и длительному поиску Ошибки В отладчике.</p>
            <p>Сформулируем правила, которые описывают, когда инициализация объекта гарантируется, а когда нет. К сожалению, эти правила достаточно сложны – на мой взгляд, слишком сложны, чтобы их стоило запоминать. Вообще, если вы работаете с C-частью C++
                (см. правило 1) и инициализация может стоить определенных затрат во время исполнения, то не гарантируется, что она произойдет. Это объясняет, Почему содержимое массивов (в C-части C++) не обязательно инициализируется, а содержимое вектора
                (из STL-части C++) инициализируется всегда.</p>
            <p>По-видимому, лучший способ поведения в такой неопределенной ситуации - всегда инициализировать объекты, прежде чем их использовать. Для объектов встроенных типов, не являющихся членами классов, это нужно делать вручную. Например:</p>
            <img src="1_04_02.png" alt="">
            <p>Почти во всех остальных случаях ответственность за инициализацию ложится на конструкторы. Правило простое: убедитесь, что все конструкторы инициализируют в объекте всё.</p>
            <p>Этому правилу легко следовать, но важно не путать присваивание с инициализацией. Рассмотрим конструктор класса, представляющего записи в адресной книге:</p>
            <img src="1_04_03.png" alt="">
            <p>Да, в результате порождаются объекты ABEntry со значениями, которых вы ожидаете, но это все же не лучший подход. Правила C++ оговаривают, что члены объекта инициируются перед входом в тело конструктора. То есть внутри конструктора ABEntry
                члены theName, theAddress и thePhones не инициализируются, а им присваиваются значения. Инициализация происходит ранее: когда автоматически вызываются их конструкторы перед входом в тело конструктора АВEntry. Это не касается numTimesConsulted,
                поскольку этот член относится к встроенному типу. Для него нет никаких гарантий того, что он вообще будет инициализирован перед присваиванием.</p>
            <p>Лучший способ написания конструктора ABEntry – использовать список Инициализации членов Вместо присваивания:</p>
            <img src="1_04_04.png" alt="">
            <p>Этот конструктор дает тот же самый конечный результат, что и предыдущий, но часто оказывается более эффективным. Версия, основанная на присваиваниях, сначала вызывает конструкторы по умолчанию для инициализации theName, theAddress и thePhоnеѕ,
                а затем сразу присваивает им новые значения, затирая те, что уже были присвоены в конструкторах по умолчанию. Таким образом, вся работа конструкторов по умолчанию тратится впустую. Подход со списком Инициализации членов позволяет избежать
                этой проблемы, поскольку аргументы в списке Инициализации используются в качестве аргументов Конструкторов для различных членов-данных. В этом случае theName создается конструктором копирования из name, theAddress - из address, thePhones
                – из рhоnеѕ. Для большинства типов единственный вызов конструктора копирования более эффективен – иногда намного более эффективен, чем вызов Конструкторов по умолчанию с последующим вызовом операторов присваивания.</p>
            <p>Для объектов встроенных типов вроде num TimesConsulted нет разницы по затратам между инициализацией и присваиванием, но для единообразия часто лучше инициировать все посредством списка инициализации членов. Такие списки можно применять даже
                тогда, когда данные-члены ИНИЦиализируются Конструкторами по умолчанию: просто не передавайте никаких аргументов соответствующему конструктору. Например, если у ABEntry есть конструктор, не принимающий параметров, то он может быть реализован
                примерно так:</p>
            <img src="1_04_05.png" alt="">
            <p>Поскольку компилятор автоматически вызывает конструкторы по умолчанию Для данных-членов пользовательских типов, когда для них отсутствуют ИНИЦиализаторы в списке инициализации членов, некоторые программисты считают приведенный выше код избыточным.
                Это понятно, но, придерживаясь Политики всегда перечислять все данные-члены в списках Инициализации, вы избавляете себя от необходимости помнить, какие члены будут инициализированы, если их пропустить, а какие - нет. Например, поскольку
                num TimesConsulted относится к встроенному типу, то исключение его из списка инициализации может открыть двери неопределенному поведению.</p>
            <p>Иногда список инициализации просто необходимо использовать, даже для встроенных типов. Например, данные-члены, которые являются константами либо ссылками, обязаны быть инициализированы, так как они не могут получить значения посредством присваивания
                (см. также правило 5). Чтобы избежать необходимости помнить, когда данные-члены должны быть инициализированы в списке инициализации, а когда это не обязательно, проще делать это всегда. Иногда это обязательно, а часто — более эффективно,
                чем присваивание.</p>
            <p>Во многих классах есть несколько конструкторов, и каждый конструктор имеет свой собственный список Инициализации. Если у класса много данных-членов или базовых классов, то наличие большого числа списков инициализации порождает нежелательное
                дублирование кода (в списках) и тоску (у программистов). В таких случаях имеет смысл опустить в списках инициализации те данные-члены, для которых присваивание работает так же, как настоящая инициализация, переместив инициализацию в одну
                (обычно закрытую) функцию, которую вызывают все конструкторы. Этот подход может быть особенно полезен, если начальные значения должны быть загружены из файла или базы данных. Однако, вообще Говоря, инициализация членов посредством списков
                Инициализации более предпочтительна, чем псевдоинициализация присваиванием.</p>
            <p>Один из аспектов C++, на который можно положиться, — это порядок, в котором инициализируются данные объектов. Этот порядок всегда один и тот же: базовые классы инициализируются раньше производных (см. также правило 12), авнутри класса члены-данные
                инициализируются в том порядке, в котором объявлены. Например, в классе АВEntry член theName всегда будет инициализирован первым, theAddress – вторым, thePhones – третьим, a num TimesConsulted - Последним. Это верно даже в случае, если
                в списке инициализации членов они перечислены в другом порядке (что, к сожалению, не запрещено). Чтобы не вводить в заблуждение человека, читающего вашу программу, и во избежание ошибок непонятного происхождения, всегда перечисляйте данные-члены
                в списке инициализации в том порядке, в котором они объявлены в классе.</p>
            <p>Позаботившись о явной инициализации объектов встроенных типов, которые не являются членами классов, и обеспечив правильную инициализацию базовых классов И Их данных-членов посредством списков Инициализации, у вас останется только одна вещь,
                о чем нужно будет подумать. Речь идет о порядке инициаЛизации нелокальных статических объектов, объявленных в разных единицах трансляции.</p>
            <p>Отнесемся к этой фразе со всем вниманием.</p>
            <p><span style="font-style: italic;">Статический объект</span> существует от момента, когда был сконструирован, и до конца работы программы. Объекты, размещенные в стеке и в «куче», к статическим не относятся. Статическими являются глобальные
                объекты, объекты, объявленные в области действия пространства имен, объекты, объявленные с ключевым словом static внутри классов и функций, а также в области действия отдельного файла с исходным текстом. Статические объекты, объявленные
                внутри функций, известны как локальные статические объекты (поскольку они локальны по отношению к функции), а все прочие называют нелокальными статическими объектами. Статические объекты автоматически уничтожаются при завершении программы,
                то есть при выходе из функции main() автоматически вызываются их деструкторы.</p>
            <p><span style="font-style: italic;">Единица трансляции (translation unit)</span> – это исходный код, который порождает отдельный объектный файл. Обычно это один исходный файл Плюс все файлы, включенные в него директивой #include.</p>
            <p>Проблема возникает, когда есть, по крайней мере, два отдельно компилируемых исходных файла, каждый из которых содержит, по крайней мере, один нелокальный статический объект (то есть глобальный объект либо объявленный В области действия пространства
                имен, класса или файла). Суть ее в том, что если инициализация нелокального статического объекта происходит в одной единице трансляции, а используется он в другой, то такой объект может оказаться неинициализированным в момент использования,
                поскольку <span style="font-style: italic;">относительный порядок инициализации нестатических локальных объектов, определенных в разных единицах трансляции, не определен.</span></p>
            <p>Рассмотрим пример. Предположим, у вас есть класс FileSystem, который делает файлы из Internet неотличимыми от локальных. Поскольку ваш класс представляет мир как единую файловую систему, вы могли бы создать в глобальной области действия или
                в пространстве имен соответствующий ей специальный объект:</p>
            <img src="1_04_06.png" alt="">
            <p>Класс FileSystem определенно не тривиален, ПОЭТому использование объекта theFileSystem до того, как он будет сконструирован, приведет к катастрофическим последствиям.</p>
            <p>Теперь предположим, что некий пользователь создает класс, описывающий каталоги файловой системы. Естественно, его класс будет использовать объект theFileSystem:</p>
            <img src="1_04_07.png" alt="">
            <p>Далее предположим, что пользователь решает создать отдельный глобальный объект класса Directory, представляющий каталог для временных файлов: </p>
            <img src="1_04_08.png" alt="">
            <p>Теперь проблема порядка инициализации становится очевидной: если объект tfs не инициализирован раньше, чем tempDir, то конструктор tempDir попытается использовать tfs до его инициализации. Но tfs и tempDir были созданы разными людьми в разное
                время и находятся в разных исходных файлах – это нелокальные статические объекты, определенные в разных единицах трансляции. Как вы можете быть уверены, что tfs будет инициализирован раньше, чем tempDir?</p>
            <p>Да никак! Еще раз повторю: <span style="font-style: italic;">относительный порядок инициализации нестатических локальных объектов, определенных в разных единицах трансляции, не определен.</span> На то есть своя причина. Определить «правильный»
                порядок инициализации нелокальных статических объектов трудно. Очень трудно. Неразрешимо трудно. В наиболее общем случае – при наличии многих единиц трансляции и нелокальных статических объектов, сгенерированных путем неявной конкретизации
                шаблонов (которые и сами могут быть результатом неявной конкретизации других шаблонов) – не только невозможно определить правильный порядок Инициализации, но обычно даже не стоит искать частные случаи, когда этот порядок в принципе определить
                можно.
            </p>
            <p>К счастью, небольшое изменение в проекте программы позволяет полностью устранить эту проблему. Нужно лишь переместить каждый нелокальный статический объект в отдельную функцию, в которой он будет объявлен статическим. Эти функции возвращают
                ссылки на объекты, которые в них содержатся. Клиенты затем вызывают функции вместо непосредственного обращения к объектам. Другими словами, нелокальные статические объекты заменяются локальными статическими объектами (знакомые с паттернами
                проектирования легко узнают В этом описании типичную реализацию паттерна Singleton).</p>
            <p>Этот подход основан на том, что С++ гарантирует: локальные статические объекты инициализируются в первый раз, когда определение объекта встречается при вызове этой функции. Поэтому если вы замените прямой доступ к нелокальным статическим объектам
                вызовом функций, возвращающих ссылки на расположенные внутри них локальные статические объекты, то можете быть уверены, что ссылки, возвращаемые из функций, будут ссылаться на инициализированные объекты. Дополнительное преимущество заключается
                в том, что если вы никогда не вызываете функцию, эмулирующую нелокальный статический объект, то и не придется платить за создание и уничтожение объекта, чего не скажешь о реальных нелокальных статических объектах.</p>
            <p>Вот как этот прием применяется к объектам tfs и tempDir:</p>
            <img src="1_04_09.png" alt="">
        </div>
        <div class="remember">
            <h3>Что следует помнить</h3>
            <li>Объявление чего-либо с модификатором соnѕt помогает компиляторам обнаруживать ошибки. const можно использовать с объектами в любой области действия, с параметрами функций и возвращаемых значений, а также с функциями-членами в целом.</li>
            <li>Компиляторы проверяют побитовую константность, но вы должны программировать, применяя логическую константность.</li>
            <li>Когда константные и неконстантные функции-члены имеют, по сути, одинаковую реализацию, то дублирования кода можно избежать, заставив неконстантную версию вызывать константную.</li>
        </div>
        <p><a href="./1_04.html">Правило 4: Прежде чем использовать объекты, убедитесь, что они инициализированы&rArr;</a></p>
    </div>
</body>