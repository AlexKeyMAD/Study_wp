<head>
    <link rel="stylesheet" href="../../css/books_style.css">
</head>

<body>
    <div class="book-title">
        <p><a href="./1_04.html">&lArr;Глава 2. Конструкторы, деструкторы и операторы присваивания</a></p>
        <h1>Глава 2</h1>
        <h2>Правило 5: Какие функции С++ создает и вызывает молча</h2>
        <hr>
        <div>
            <p>Когда пустой класс перестает быть пустым? Когда за него берется C++. Если вы не объявите конструктор копирования, оператор присваивания или деструктор самостоятельно, то компилятор сделает это за вас. Более того, если вы не объявите вообще
                никакого конструктора, то компилятор автоматически создаст конструктор по умолчанию. Все эти функции будут открытыми и встроенными (см. правило 30). Например, такое объявление:</p>
            <p>class Empty {}; </p>
            <p>эквиваленто следующему:</p>
            <img src="2_05_01.png" alt="">
            <p>Эти функции генерируются, только если они нужны, но мало найдется случаев, когда без них можно обойтись. Так, следующий код приведет к их автоматической генерации компилятором:</p>
            <img src="2_05_02.png" alt="">
            <p>Итак, компилятор пишет эти функции для вас, но что они делают? Конструктор по умолчанию и деструктор – это места, в которые компилятор помещает служебный код, например вызов конструкторов и деструкторов базовых классов и нестатических данных-членов.
                Отметим, что сгенерированный деструктор не является виртуальным (см. правило 7), если только речь не идет о классе, наследующем классу, у которого есть виртуальный деструктор (в этом случае виртуальность наследуется от базового класса).</p>
            <p>Что касается конструктора копирования и оператора присваивания, то сгенерированные компилятором версии просто копируют каждый нестатический член данных исходного объекта в целевой. Например, рассмотрим шаблон NamedObject, который позволяет
                ассоциировать имена с объектами типа Т:</p>
            <img src="2_05_03.png" alt="">
            <p>Поскольку в классе NamedObject объявлен конструктор, компилятор не станет генерировать конструктор по умолчанию. Это важно. Значит, если вы спроектировали класс так, что его конструктору обязательно должны быть переданы какие-то аргументы,
                то вам не нужно беспокоиться, что компилятор проигнорирует ваше решение и по собственной инициативе добавит еще и конструктор без аргументов.</p>
            <p>В классе NamedObject нет ни конструктора копирования, ни оператора при сваивания, поэтому компилятор сгенерирует их (при необходимости). Посмотрите на следующее употребление конструктора копирования:</p>
            <img src="2_05_04.png" alt="">
            <p>Конструктор копирования, сгенерированный компилятором, должен инициализировать no2.nameValue и no2.objectValue, используя по1.name Value и no1.objectValue соответственно. Член nаmеvаluе имеет тип string, aв стандартном классе string объявлен
                конструктор копирования, поэтому по2.nameValue. Изирован вызовом конструктора копирования string с аргументов no1.name Value. С другой стороны, член NameObject
                <int>::objectValue имеет тип int (поскольку Т есть іnt в данной конкретизации шаблона), а іnt – встроенный тип, поэтому по2.objectValue будет инициализирован побитовым копированием no1.object Value.
            </p>
        </div>
        <p><a href="./2_06.html">Правило 6: &rArr;</a></p>
    </div>
</body>