<head>
    <link rel="stylesheet" href="../../css/books_style.css">
</head>

<body>
    <div class="book-title">
        <p><a href="./0_02.html">&lArr;Введение</a></p>
        <h1>ТЕРМИНОЛОГИЯ</h1>
        <h2>Терминология</h2>
        <hr>
        <div>
            <p>Существует небольшой словарик C++, которым должен владеть каждый программист. Следующие термины достаточно важны, поэтому имеет смысл убедиться, что мы понимаем их одинаково.</p>
            <p><span style="font-weight:bold">Объявление</span> (declaration) сообщает компилятору имя и тип чего-либо, опуская некоторые детали. Объявления выглядят так:</p>
            <p>extern int x; // объявление объекта</p>
            <p>std::size_t numDigits(int number); // объявление функции</p>
            <p>class Widget; // объявление класса</p>
            <p>template&lt;typename T&gt; // объявление шаблона</p>
            <p>class GraphNode; // (см. правило 42 о том, что такое «typename»</p>
            <p>Заметьте, что я называю целое число x «объектом», несмотря на то что это переменная встроенного типа. Некоторые люди под «объектами» понимают только переменные пользовательских типов, но я не принадлежу к их числу. Также отметим, что функция
                numDigits() возвращает тип std::size_t, то есть тип size_t из пространства имен std. Это то пространство имен, в котором находится почти все из стандартной библиотеки C++. Однако, поскольку стандартная библиотека C (точнее говоря, С89)
                также может быть использована в программе на C++, символы, унаследованные от C (такие как size_t), могут существовать в глобальном контексте, внутри std, либо в обоих местах, в зависимости от того, какие заголовочные файлы были включены
                директивой #include. В этой книге я предполагаю, что с помощью #include включаются заголовочные файлы C++. Вот почему я употребляю std::size_t, а не просто size_t. Когда я упоминаю компоненты стандартной библиотеки вне текста программы,
                то обычно опускаю ссылку на std, полагая, что вы знаете, что такие вещи, как size_t, vector и cout, находятся в пространстве имен std. В примерах же программ я всегда включаю std, потому что в противном случае код не скомпилируется.</p>
            <p>Кстати, size_t – это всего-навсего определенный директивой typedef синоним для некоторых беззнаковых типов, которые в C++ используются для разного рода счетчиков (например, количества символов в строках типа char*, количества элементов в контейнерах
                STL и т. п.). Это также тип, принимаемый функциями operator[] в векторах (vector), деках (deque) и строках (string). Этому соглашению мы будем следовать и при определении наших собственных функций operator[] в правиле 3.</p>
            <p>В любом объявлении функции указывается ее <span style="font-weight:bold">сигнатура</span>, то есть типы параметров и возвращаемого значения. Можно сказать, что сигнатура функции – это ее тип. Так, сигнатурой функции numDigits является std::size_t(int),
                иными словами, это «функция, принимающая int и возвращающая std::size_t». Официальное определение «сигнатуры» в C++ не включает тип возвращаемого функцией значения, но в этой книге нам будет удобно считать, что он все же является частью
                сигнатуры.
            </p>
            <p><span style="font-weight:bold">Определение</span> (definition) сообщает компилятору детали, которые опущены в объявлении. Для объекта определение – это то место, где компилятор выделяет для него память. Для функции или шаблона функции определение
                содержит тело функции. В определении класса или шаблона класса перечисляются его члены:</p>
            <p>int x; // определение объекта</p>
            <p>std::size_t numDigits(int number) // определение функции </p>
            <p>{ // (эта функция возвращает количество </p>
            <p>std::size_t digitsSoFar = 1; // десятичных знаков в своем параметре) </p>
            <p>while((number /= 10) != 0) ++digitsSoFar; </p>
            <p>return digitsSoFar; </p>
            <p>} </p>
            <p>class Widget { // определение класса </p>
            <p>public: </p>
            <p>Widget(); </p>
            <p>~Widget(); </p>
            <p>... </p>
            <p>}; </p>
            <p>template&lt;typename T&gt; // определение шаблона</p>
            <p>class GraphNode {</p>
            <p>public:</p>
            <p>GraphNode();</p>
            <p>~GraphNode();</p>
            <p>...</p>
            <p>};</p>
            <p><span style="font-weight:bold">Инициализация</span> (initialization) – это процесс присваивания объекту начального значения. Для объектов пользовательских типов инициализация выполняется конструкторами. <span style="font-weight:bold">Конструктор по умолчанию</span>                (default constructor) – это конструктор, который может быть вызван без аргументов. Такой конструктор либо не имеет параметров вовсе, либо имеет значение по умолчанию для каждого параметра:</p>
            <p>class A {</p>
            <p>public:</p>
            <p>A(); // конструктор по умолчанию</p>
            <p>};</p>
            <p>class B {</p>
            <p>public:</p>
            <p>explicit B(int x = 0; bool b = true); // конструктор по умолчанию,</p>
            <p>}; // см. далее объяснение</p>
            <p>// ключевого слова “explicit”</p>
            <p>class C {</p>
            <p>public:</p>
            <p>explicit C(int x); // это не конструктор по</p>
            <p>// умолчанию</p>
            <p>};</p>
            <p>Конструкторы классов B и C объявлены в ключевым словом explicit (явный). Это предотвращает их использование для неявных преобразований типов, хотя не запрещает применения, если преобразование указано явно:</p>
            <p>void doSomething(B bObject); // функция принимает объект типа B</p>
            <p>B bObj1; // объект типа B</p>
            <p>doSomething(bObj1); // нормально, B передается doSomething</p>
            <p>B bObj(28); // нормально, создает B из целого 28</p>
            <p>// (параметр bool по умолчанию true)</p>
            <p>doSomething(28); // ошибка! doSomething принимает B,</p>
            <p>// а не int, и не существует неявного</p>
            <p>// преобразования из int в B</p>
            <p>doSomething(B(28)); // нормально, используется конструктор</p>
            <p>// B для явного преобразования (приведения)</p>
            <p>// int в B (см. в правиле 27 информацию</p>
            <p>// о приведении типов)</p>
            <p>Конструкторы, объявленные как explicit, обычно более предпочтительны, потому что предотвращают выполнение компиляторами неявных преобразований типа (часто нежелательных). Если нет основательной причины для использования конструкторов в неявных
                преобразованиях типов, я всегда объявляю их explicit. Советую и вам придерживаться того же принципа.</p>
            <p>Обратите внимание, что в предшествующем примере приведение выделено. Я и дальше буду использовать такое выделение, чтобы подчеркнуть важность излагаемого материала. (Также я выделяю номера глав, но это только потому, что мне кажется, это выглядит
                симпатично.)
            </p>
            <p>Конструктор копирования (copy constructor) используется для инициализации объекта значением другого объекта того же самого типа, а копирующий оператор присваивания (copy assignment operator) применяется для копирования значения одного объекта
                в другой – того же типа:</p>
            <p>class Widget {</p>
            <p>public:</p>
            <p>Widget(); // конструктор по умолчанию</p>
            <p>Widget(const Widget& rhs); // конструктор копирования</p>
            <p> Widget& operator=(const Widget& rhs); // копирующий оператор присваивания</p>
            <p>...</p>
            <p>};</p>
            <p>Widget w1; // вызов конструктора по умолчанию</p>
            <p>Widget w2(w1); // вызов конструктора копирования</p>
            <p>w1 = w2; // вызов оператора присваивания</p>
            <p>// копированием</p>
            <p>Будьте внимательны, когда видите конструкцию, похожую на присваивание, потому что синтаксис «=» также может быть использован для вызова конструктора копирования:</p>
            <p>Widget w3 = w2; // вызов конструктора копирования!</p>
            <p>К счастью, конструктор копирования легко отличить от присваивания. Если новый объект определяется (как w3 в последнем предложении), то должен вызываться конструктор, это не может быть присваивание. Если же никакого нового объекта не создается
                (как в «w1=w2»), то конструктор не применяется и это – присваивание.</p>
            <p>Конструктор копирования – особенно важная функция, потому что она определяет, как объект передается по значению. Например, рассмотрим следующий фрагмент:</p>
            <p>bool hasAcceptableQuality(Widget w);</p>
            <p>...</p>
            <p>Widget aWidget;</p>
            <p>if (hasAcceptableQuality(aWidget)) ...</p>
            <p>Параметр w передается функции hasAcceptableQuality по значению, поэтому в приведенном примере вызова aWidget копируется в w. Копирование осуществляется конструктором копирования из класса Widget. Вообще передача по значению означает вызов
                конструктора копирования. (Но, строго говоря, передавать пользовательские типы по значению – плохая идея. Обычно лучший вариант – передача по ссылке на константу, подробности см. в правиле 20.)</p>
            <p><span style="font-weight:bold">STL</span> – стандартная библиотека шаблонов (Standard Template Library) – это часть стандартной библиотеки, касающаяся контейнеров (то есть vector, list, set, map и т. д.), итераторов (то есть vector
                <int>::iterator, set
                    <string>::iterator и т. д.), алгоритмов (то есть for_each, find, sort и т. д.) и всей связанной с этим функциональности. В ней очень широко используются объекты-функции (function objects), то есть объекты, ведущие себя подобно функциям. Такие
                        объекты представлены классами, в которых перегружен оператор вызова operator(). Если вы не знакомы с STL, вам понадобится, помимо настоящей книги, какое-нибудь достойное руководство, посвященное этой теме, ведь библиотека STL настолько
                        удобна, что не воспользоваться ее преимуществами было бы непростительно. Стоит лишь начать работать с ней, и вы сами это почувствуете.</p>
            <p>Программистам, пришедшим к C++ от языков вроде Java или C#, может показаться странным понятие неопределенного поведения. По различным причинам поведение некоторых конструкций в C++ действительно не определено: вы не можете уверенно предсказать,
                что произойдет во время исполнения. Вот два примера такого рода:</p>
            <p>int *p = 0; // p – нулевой указатель</p>
            <p>std::cout
                << *p; // разыменование нулевого указателя</p>
                    <p>char name[] = “Daria” // name – массив длины 6 (не забудьте про</p>
                    <p>// завершающий нуль!)</p>
                    <p>char c = name[10]; // указание неправильного индекса массива</p>
                    <p>// порождает неопределенное поведение</p>
                    <p>Дабы подчеркнуть, что результаты неопределенного поведения невозможно предсказать и что они могут быть весьма неприятны, опытные программисты на C++ часто говорят, что программы с неопределенным поведением могут стереть содержимое
                        жесткого диска. Это правда: такая программа может стереть ваш жесткий диск, но может этого и не сделать. Более вероятно, что она будет вести себя по-разному: иногда нормально, иногда аварийно завершаться, а иногда – просто выдавать
                        неправильные результаты. Мудрые программисты на C++ придерживаются правила – избегать неопределенного поведения. В этой книге во многих местах я указываю, как это сделать.</p>
                    <p>Иной термин, который может смутить программистов, пришедших из других языков, – это интерфейс. В Java и. NET-совместимых языках интерфейсы являются частью языка, но в C++ ничего подобного нет, хотя в правиле 31 рассматривается некоторое
                        приближение. Когда я использую термин «интерфейс», то обычно имею в виду сигнатуры функций, доступные члены класса («открытый интерфейс», «защищенный интерфейс», «закрытый интерфейс») или выражения, допустимые в качестве параметров
                        типа для шаблонов (см. правило 41). То есть под интерфейсом я понимаю общую концепцию проектирования.</p>
                    <p>Понятие клиент – это нечто или некто, использующий написанный вами код (обычно через интерфейсы). Так, например, клиентами функции являются ее пользователи: части кода, которые вызывают функцию (или берут ее адрес), а также люди, которые
                        пишут и сопровождают такой код. Клиентами класса или шаблона являются части программы, использующие этот класс или шаблон, а равно программисты, которые пишут или сопровождают эти части. Когда речь заходит о клиентах, я обычно
                        имею в виду программистов, поскольку именно они могут быть введены в заблуждение или недовольство плохо разработанным интерфейсом. Коду, который они пишут, такие эмоции недоступны.</p>
                    <p>Возможно, вы не привыкли думать о клиентах, но я постараюсь убедить вас в необходимости облегчить им жизнь, насколько это возможно. В конце концов, вы сами – клиент программного обеспечения, которое разрабатывал кто-то другой. Ведь
                        вы хотели бы, чтоб его авторы облегчили вам работу? Помимо того, рано или поздно вы окажетесь в положении, когда сами станете клиентом собственного кода (то есть будете использовать код, написанный вами), и тогда оцените, что при
                        разработке интерфейсов нужно помнить об интересах клиентов.</p>
                    <p>В этой книге я часто обращаю внимание на различие между функциями и шаблонами функций, а также между классами и шаблонами классов. Это не случайно, ведь то, что справедливо для одного, часто справедливо и для другого. В ситуациях,
                        когда это не так, я делаю различие между классами, функциями и шаблонами, из которых порождаются классы и функции.</p>
        </div>
        <p><a href="./0_04.html">Соглашения об именах&rArr;</a></p>
    </div>
</body>