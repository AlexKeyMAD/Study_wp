<head>
    <link rel="stylesheet" href="../../css/books_style.css">
</head>

<body>
    <div class="book-title">
        <p><a href="./1_01.html">&lArr;Правило 2: Предпочитайте const, enum и inline использованию #define</a></p>
        <h1>Глава 1</h1>
        <h2>Правило 3: Везде, где только можно используйте const</h2>
        <hr>
        <div>
            <p>Замечательное свойство модификатора const состоит в том, что он накладывает определенное семантическое ограничение: данный объект не должен модифицироваться, - и компилятор будет проводить это ограничение н жизнь, const позволяет указать компилятору
                и программистам, что определенная величина должна оставаться неизменной. Во всех подобных случаях вы должны обозначить это явным образом, призывая себе на помощь компилятор и гарантируя тем самым, что ограничение не будет нарушено.</p>
            <p>Ключевое слово const удивительно многосторонне. Вне классов вы можете использовать его для определения констант в глобальной области или в пространстве имен (см. правило 2). а также для статических объектов (внутри файла, функции или блока).
                Внутри классов допустимо применять его как для статических, так и для нестатических данных-членов. Для указателей можно специфицировать. должен ли быть константным сам указатель, данные, на которые он указывает, либо и то, и другое (или
                ни то, ни другое):</p>
            <img src="1_03_01.png" alt="">
            <p>Этот синтаксис не так страшен, как может показаться. Если слово const появляется слева от звездочки, константным является то, на что указывает указатель; если справа, то сам указатель является константным. Наконец, если же слово const появляется
                с обеих сторон, то константно и то. и другое.</p>
            <p>Когда то, на что указывается, константа, некоторые программисты ставят const перед идентификатором типа. Другие - после идентификатора типа, но перед звездочкой. Семантической разницы здесь нет, поэтому следующие функции принимают параметр
                одного и того же тина:</p>
            <img src="1_03_02.png" alt="">
            <p>Поскольку в реальном коде встречаются обе формы, следует привыкать и к той, и к другой.</p>
            <p>Итераторы STL смоделированы на основе указателей, поэтому iterator ведет себя почти как указатель Т*. Объявление const-итератора подобно объявлению const-указателя (то есть записи Т* const): итератор не может начать указывать на что-то другое,
                но то, на что он указывает, может быть модифицировано. Если вы хотите иметь итератор, который указывал бы на нечто, что запрещено модифицировать (то есть STL-аналог указателя const Т*). то вам понадобится константный итератор:</p>
            <img src="1_03_03.png" alt="">
            <p>Некоторые из наиболее интересных применений const связаны с объявлениями функций. В этом случае const может относиться к возвращаемому функцией значению, к отдельным параметрам, а для функций-членов - еще и к функции в целом.</p>
            <p>Если указать в объявлении функции, что она возвращает константное значение, то можно уменьшить количество ошибок в клиентских программах, не снижая уровня безопасности и эффективности. Например, рассмотрим объявление функции operator* для
                рациональных чисел, введенное в правиле 24:</p>
            <img src="1_03_04.png" alt="">
            <p>Многие программисты удивятся, впервые увидев такое объявление. Почему результат функции operator* должен быть константным объектом? Потому что в противном случае пользователь получил бы возможность делать вещи, которые иначе как надругательством
                над здравым смыслом не назовешь</p>
            <img src="1_03_05.png" alt="">
            <p>Я не знаю, с какой стати программисту пришло бы в голову присваивать значение произведению двух чисел, но могу точно сказать, что иногда такое может случиться по недосмотру. Достаточно простой опечатки (при условии, что тип может быть преобразован
                к bool):</p>
            <img src="1_03_06.png" alt="">
            <p>Такой код был бы совершенно некорректным, если бы а и Ь имели встроенный тин. Одним из критериев качества пользовательских типов является совместимость со встроенными (см. также правило 18). а возможность присваивания значения результату произведения
                двух объектов представляется мне весьма далекой от совместимости. Если же объявить, что operator* возвращает константное значение, то такая ситуация станет невозможной. Вот почему Так Следует Поступать.</p>
            <p>В отношении аргументов с модификатором const трудно сказать что-то новое; они ведут себя как локальные константные const-объекты. Всюду, где возможно, добавляйте этот модификатор. Если модифицировать аргумент или локальный объект нет необходимости,
                объявите его как const. Вам всего-то придется набрать шесть символов, зато это предотвратит досадные ошибки типа «хотел напечатать — .а нечаянно напечатал -* (к чему это приводит, мы только что видели).</p>
            <h3>Константные функции-члены</h3>
            <p>Назначение модификатора const в объявлении функций-членов определить, какие из них можно вызывать для константных объектов. Такие функции-члены важны но двум причинам. Во-первых, они облегчают понимание интерфейса класса, ведь полезно сразу
                видеть, какие функции могут модифицировать объект, а какие нет. Во-вторых, они обеспечивают возможность работать с константными объектами. Это очень важно для написания эффективного кода, потому что, как объясняется в правиле 20. один
                из основных способов повысить производительность программ на C++ - передавать объекты по ссылке на константу. Но эта техника будет работать только в случае, когда функции-члены для манипулирования константными объектами объявлены с модификатором
                const.
            </p>
            <p>Многие упускают из виду, что функции, отличающиеся только наличием const в объявлении, могут быть перегружены. Это. однако, важное свойство C++. Рассмотрим класс, представляющий блок текста:</p>
            <img src="1_03_07.png" alt="">
            <p>Функцию operator[] в классе TextBlock можно использовать следующим образом:</p>
            <img src="1_03_08.png" alt="">
            <p>Кстати, константные объекты чаще всего встречаются в реальных программах в результате передачи но указателю или ссылке на константу. Приведенный выше пример ctb является довольно искусственным. По вот вам более реалистичный:</p>
            <img src="1_03_09.png" alt="">
            <p>Перегружая operator[] и создавая различные версии е разными возвращаемыми типами, вы можете по-разному обрабатывать константные и неконстантные объекты TextBlock:</p>
            <img src="1_03_10.png" alt="">
            <p>Отметим, что ошибка здесь связана только с типом значения, возвращаемого operator[]; сам вызов operator[] проходит нормально. Причина ошибки - в попытке присвоить значение объекту типа const сһаг&, потому что это именно такой тип возвращается
                константной версией operator[].</p>
            <p>Отметим также, что тип, возвращаемый неконстантной версией operator[]. - это ссылка на char, а не сам char. Если бы operator[] возвращал просто char, то следующее предложение не скомпилировалось бы:</p>
            <p> tb(0) - 'х';</p>
            <p>Это объясняется тем, что возвращаемое функцией значение встроенного типа модифицировать некорректно. Даже если бы это было допустимо, тот факт, что C++ возвращает объекты но значению (см. правило 20), означал бы следующее: модифицировалась
                копия tb.text|0), а не само значение tb.text[0]. Вряд ли это то, чего вы ожидаете.</p>
        </div>
        <div class="remember">
            <h3>Что следует помнить</h3>
            <li>Для простых констант директиве #define следует предпочесть константные объекты и перечисления (enum).</li>
            <li>Вместо имитирующих функции макросов, определенных через #define, лучше применять встроенные функции.</li>
        </div>
        <p><a href="./1_03.html">Правило 3: Везде, где только можно используйте const&rArr;</a></p>
    </div>
</body>