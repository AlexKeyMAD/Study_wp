<head>
    <link rel="stylesheet" href="../../../css/books_style.css">
</head>

<body>
    <div>
        <p><a href="./01_02.html">&lArr;Потоки</a></p>
        <h1>Потоки пользовательских данных</h1>
        <hr>
        <h2>Вступление</h2>
        <p>SFML имеет несколько классов ресурсов: изображения, шрифты, звуки и т. д. В большинстве программ эти ресурсы будут загружаться из файлов с помощью их функции loadFromFile. В некоторых других ситуациях ресурсы будут упакованы непосредственно в
            исполняемый файл или в файл больших данных и загружены из памяти с помощью loadFromMemory. Эти функции охватывают почти все возможные варианты использования, но не все.</p>
        <p>Иногда вам нужно загрузить файлы из необычных мест, например, из сжатого/зашифрованного архива или из удаленного сетевого расположения. Для этих особых ситуаций SFML предоставляет третью функцию загрузки: loadFromStream. Эта функция считывает
            данные с помощью абстрактного интерфейса sf::InputStream, который позволяет вам предоставить собственную реализацию класса потока, работающего с SFML.</p>
        <p>В этом руководстве вы узнаете, как написать и использовать собственный производный входной поток.</p>
        <hr>
        <h2>А стандартные потоки?</h2>
        <p>Как и во многих других языках, в C++ уже есть класс для потоков входных данных: std::istream. На самом деле их два: std::istream — это только внешний интерфейс, абстрактный интерфейс к пользовательским данным — std::streambuf.</p>
        <p>К сожалению, эти классы не очень удобны для пользователя и могут стать очень сложными, если вы хотите реализовать нетривиальные вещи. Библиотека Boost.Iostreams пытается предоставить более простой интерфейс для стандартных потоков, но Boost —
            это большая зависимость, и SFML не может зависеть от него.</p>
        <p>Вот почему SFML предоставляет собственный потоковый интерфейс, который, как мы надеемся, намного проще и быстрее.</p>
        <hr>
        <h2>InputStream</h2>
        <p>Класс sf::InputStream объявляет четыре виртуальные функции:</p>
        <code>
            <p class="cpp_code">class InputStream</p>
            <p class="cpp_code">{</p>
            <p class="cpp_code">public :</p>
            <p class="cpp_code_1t">virtual ~InputStream() {}</p>
            <br>
            <p class="cpp_code_1t">virtual Int64 read(void* data, Int64 size) = 0;</p>
            <br>
            <p class="cpp_code_1t">virtual Int64 seek(Int64 position) = 0;</p>
            <br>
            <p class="cpp_code_1t">virtual Int64 tell() = 0;</p>
            <br>
            <p class="cpp_code_1t">virtual Int64 getSize() = 0;</p>
            <p class="cpp_code">}</p>
        </code>
        <p><span class="font-bold">read</span> должен извлечь размер байтов данных из потока и скопировать их по указанному адресу данных. Он возвращает количество прочитанных байтов или -1 в случае ошибки.</p>
        <p><span class="font-bold">seek</span> должен изменить текущую позицию чтения в потоке. Его аргумент позиции — это абсолютное смещение в байтах для перехода (поэтому оно относится к началу данных, а не к текущей позиции). Он возвращает новую позицию
            или -1 в случае ошибки.</p>
        <p><span class="font-bold">tell</span> должен возвращать текущую позицию чтения (в байтах) в потоке или -1 в случае ошибки.</p>
        <p><span class="font-bold">getSize</span> должен возвращать общий размер (в байтах) данных, содержащихся в потоке, или -1 в случае ошибки.</p>
        <p>Чтобы создать свой собственный рабочий поток, вы должны реализовать каждую из этих четырех функций в соответствии с их требованиями.</p>
        <p><a href="./02_01.html">&rArr;</a></p>
    </div>
</body>