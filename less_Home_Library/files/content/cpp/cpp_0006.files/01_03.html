<head>
    <link rel="stylesheet" href="../../../css/books_style.css">
</head>

<body>
    <div>
        <p><a href="./01_02.html">&lArr;Потоки</a></p>
        <h1>Потоки пользовательских данных</h1>
        <hr>
        <h2>Вступление</h2>
        <p>SFML имеет несколько классов ресурсов: изображения, шрифты, звуки и т. д. В большинстве программ эти ресурсы будут загружаться из файлов с помощью их функции loadFromFile. В некоторых других ситуациях ресурсы будут упакованы непосредственно в
            исполняемый файл или в файл больших данных и загружены из памяти с помощью loadFromMemory. Эти функции охватывают почти все возможные варианты использования, но не все.</p>
        <p>Иногда вам нужно загрузить файлы из необычных мест, например, из сжатого/зашифрованного архива или из удаленного сетевого расположения. Для этих особых ситуаций SFML предоставляет третью функцию загрузки: loadFromStream. Эта функция считывает
            данные с помощью абстрактного интерфейса sf::InputStream, который позволяет вам предоставить собственную реализацию класса потока, работающего с SFML.</p>
        <p>В этом руководстве вы узнаете, как написать и использовать собственный производный входной поток.</p>
        <hr>
        <h2>А стандартные потоки?</h2>
        <p>Как и во многих других языках, в C++ уже есть класс для потоков входных данных: std::istream. На самом деле их два: std::istream — это только внешний интерфейс, абстрактный интерфейс к пользовательским данным — std::streambuf.</p>
        <p>К сожалению, эти классы не очень удобны для пользователя и могут стать очень сложными, если вы хотите реализовать нетривиальные вещи. Библиотека Boost.Iostreams пытается предоставить более простой интерфейс для стандартных потоков, но Boost —
            это большая зависимость, и SFML не может зависеть от него.</p>
        <p>Вот почему SFML предоставляет собственный потоковый интерфейс, который, как мы надеемся, намного проще и быстрее.</p>
        <hr>
        <h2>InputStream</h2>
        <p>Класс sf::InputStream объявляет четыре виртуальные функции:</p>
        <code>
            <p class="cpp_code">class InputStream</p>
            <p class="cpp_code">{</p>
            <p class="cpp_code">public :</p>
            <p class="cpp_code_1t">virtual ~InputStream() {}</p>
            <br>
            <p class="cpp_code_1t">virtual Int64 read(void* data, Int64 size) = 0;</p>
            <br>
            <p class="cpp_code_1t">virtual Int64 seek(Int64 position) = 0;</p>
            <br>
            <p class="cpp_code_1t">virtual Int64 tell() = 0;</p>
            <br>
            <p class="cpp_code_1t">virtual Int64 getSize() = 0;</p>
            <p class="cpp_code">}</p>
        </code>
        <p><span class="font-bold">read</span> должен извлечь размер байтов данных из потока и скопировать их по указанному адресу данных. Он возвращает количество прочитанных байтов или -1 в случае ошибки.</p>
        <p><span class="font-bold">seek</span> должен изменить текущую позицию чтения в потоке. Его аргумент позиции — это абсолютное смещение в байтах для перехода (поэтому оно относится к началу данных, а не к текущей позиции). Он возвращает новую позицию
            или -1 в случае ошибки.</p>
        <p><span class="font-bold">tell</span> должен возвращать текущую позицию чтения (в байтах) в потоке или -1 в случае ошибки.</p>
        <p><span class="font-bold">getSize</span> должен возвращать общий размер (в байтах) данных, содержащихся в потоке, или -1 в случае ошибки.</p>
        <p>Чтобы создать свой собственный рабочий поток, вы должны реализовать каждую из этих четырех функций в соответствии с их требованиями.</p>
        <hr>
        <h2>FileInputStream и MemoryInputStream</h2>
        <p>Начиная с SFML 2.3, были созданы два новых класса для предоставления потоков для нового внутреннего управления звуком. sf::FileInputStream предоставляет доступный только для чтения поток данных файла, а sf::MemoryInputStream обслуживает доступный
            только для чтения поток из памяти. Оба являются производными от sf::InputStream и поэтому могут использоваться полиморфно.</p>
        <hr>
        <h2>Использование InputStream</h2>
        <p>Использовать пользовательский класс потока просто: создайте его экземпляр и передайте его функции loadFromStream (или openFromStream) объекта, который вы хотите загрузить.</p>
        <code>
            <p class="cpp_code">sf::FileStream stream;</p>
            <p class="cpp_code">stream.open("image.png");</p>
            <br>
            <p class="cpp_code">sf::Texture texture;</p>
            <p class="cpp_code">texture.loadFromStream(stream);</p>
        </code>
        <hr>
        <h2>Примеры</h2>
        <p>Если вам нужна демонстрация, которая поможет вам сосредоточиться на том, как работает код, и не потеряться в деталях реализации, вы можете взглянуть на реализацию sf::FileInputStream или sf::MemoryInputStream.</p>
        <p>Не забудьте проверить форум и вики. Скорее всего, другой пользователь уже написал класс sf::InputStream, который соответствует вашим потребностям. И если вы напишете новый и почувствуете, что он может быть полезен и другим людям, не стесняйтесь
            поделиться!
        </p>
        <hr>
        <h2>Распространенные ошибки</h2>
        <p>Некоторые классы ресурсов загружаются не полностью после вызова loadFromStream. Вместо этого они продолжают читать из своего источника данных, пока используются. Так обстоит дело с sf::Music, который транслирует аудиосэмплы по мере их воспроизведения,
            и с sf::Font, который загружает глифы на лету в зависимости от отображаемого текста.</p>
        <p>Как следствие, экземпляр потока, который вы использовали для загрузки музыки или шрифта, а также его источник данных, должны оставаться активными до тех пор, пока ресурс их использует. Если он уничтожается во время использования, это приводит
            к неопределенному поведению (может быть сбой, поврежденные данные или ничего не видно).</p>
        <p>Другой распространенной ошибкой является возврат того, что внутренние функции возвращают напрямую, но иногда это не соответствует тому, что ожидает SFML. Например, в коде sf::FileInputStream может возникнуть соблазн написать функцию поиска следующим
            образом:
        </p>
        <code>
            <p class="cpp_code">sf::Int64 FileInputStream::seek(sf::Int64 position)</p>
            <p class="cpp_code">{</p>
            <p class="cpp_code_1t">return std::fseek(m_file, position, SEEK_SET);</p>
            <p class="cpp_code">}</p>
        </code>
        <p>Этот код неверен, потому что std::fseek возвращает ноль в случае успеха, тогда как SFML ожидает, что будет возвращена новая позиция.</p>
        <p><a href="./02_01.html">Открытие и управление окном в SFML&rArr;</a></p>
    </div>
</body>