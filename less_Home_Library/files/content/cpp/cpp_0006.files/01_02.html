<head>
    <link rel="stylesheet" href="../../../css/books_style.css">
</head>

<body>
    <div>
        <p><a href="./01_01.html">&lArr;Обработка времени</a></p>
        <h1>Потоки</h1>
        <hr>
        <h2>Что такое поток?</h2>
        <p>Большинство из вас уже должны знать, что такое поток, однако вот небольшое пояснение для тех, кто действительно плохо знаком с этой концепцией.</p>
        <p>Поток — это в основном последовательность инструкций, которые выполняются параллельно с другими потоками. Каждая программа состоит как минимум из одного потока: основного, который запускает вашу функцию main(). Программы, которые используют только
            основной поток, являются однопоточными, если вы добавите один или несколько потоков, они станут многопоточными.</p>
        <p>Короче говоря, потоки — это способ делать несколько вещей одновременно. Это может быть полезно, например, для отображения анимации и реагирования на действия пользователя при загрузке изображений или звуков. Потоки также широко используются в
            сетевом программировании для ожидания получения данных, продолжая обновлять и рисовать приложение.</p>
        <hr>
        <h2>Потоки SFML или std::thread?</h2>
        <p>В своей новейшей версии (2011 г.) стандартная библиотека C++ предоставляет набор классов для многопоточности. В то время, когда был написан SFML, стандарт C++11 еще не был написан, и не было стандартного способа создания потоков. Когда был выпущен
            SFML 2.0, многие компиляторы еще не поддерживали этот новый стандарт.</p>
        <p>Если вы работаете с компиляторами, поддерживающими новый стандарт и его заголовок &lt;thread&gt;, забудьте о классах потоков SFML и используйте вместо них его — так будет намного лучше. Но если вы работаете с компилятором, выпущенным до 2011 года,
            или планируете распространять свой код и хотите, чтобы он был полностью переносимым, классы потоков SFML — хорошее решение.</p>
        <hr>
        <h2>Создание потока с помощью SFML</h2>
        <p>Хватит разговоров, давайте посмотрим код. Класс, позволяющий создавать потоки в SFML, называется sf::Thread, и вот как он выглядит в действии:</p>
        <code>
            <p class="cpp_code">#include &lt;SFML/System.hpp&gt;</p>
            <p class="cpp_code">#include &lt;iostream&gt;</p>
            <br>
            <p class="cpp_code">void func()</p>
            <p class="cpp_code">{</p>
            <p class="cpp_code_1t">// this function is started when thread.launch() is called</p>
            <br>
            <p class="cpp_code_1t">for (int i = 0; i &lt; 10; ++i)</p>
            <p class="cpp_code_2t">std::cout &lt;&lt; "I'm thread number one" &lt;&lt; std::endl;</p>
            <br>
            <p class="cpp_code">}</p>
            <br>
            <p class="cpp_code">int main()</p>
            <p class="cpp_code">{</p>
            <p class="cpp_code_1t">// create a thread with func() as entry point</p>
            <p class="cpp_code_1t">sf::Thread thread(&func);</p>
            <br>
            <p class="cpp_code_1t">// run it</p>
            <p class="cpp_code_1t">thread.launch();</p>
            <br>
            <p class="cpp_code_1t">// the main thread continues to run...</p>
            <p class="cpp_code_1t">for (int i = 0; i &lt; 10; ++i)</p>
            <p class="cpp_code_2t">std::cout &lt;&lt; "I'm the main thread" &lt;&lt; std::endl;</p>
            <br>
            <p class="cpp_code_1t">return 0;</p>
            <p class="cpp_code">}</p>
        </code>
        <p>В этом коде и main, и func запускаются параллельно после вызова thread.launch(). В результате текст из обеих функций должен смешиваться в консоли.</p>
        <img src="./01_02_01.png" alt="">
        <p>Точка входа потока, т.е. функция, которая будет выполняться при запуске потока, должна быть передана конструктору sf::Thread. sf::Thread старается быть гибким и принимает широкий спектр точек входа: функции, не являющиеся членами, или функции-члены,
            с аргументами или без них, функторы и т. д. В приведенном выше примере показано, как использовать функцию, не являющуюся членом, вот некоторые из них. другие примеры.</p>
        <p>-Функция, не являющаяся членом, с одним аргументом:</p>
        <code>
            <p class="cpp_code">void func(int x)</p>
            <p class="cpp_code">{</p>
            <p class="cpp_code">}</p>
            <br>
            <p class="cpp_code">sf::Thread thread(&func, 5);</p>
        </code>
        <p>-Функция члена:</p>
        <code>
            <p class="cpp_code">class MyClass</p>
            <p class="cpp_code">{</p>
            <p class="cpp_code">public:</p>
            <br>
            <p class="cpp_code_1t">void func()</p>
            <p class="cpp_code_1t">{</p>
            <p class="cpp_code_1t">}</p>
            <p class="cpp_code">};</p>
            <br>
            <p class="cpp_code">MyClass object;</p>
            <p class="cpp_code">sf::Thread thread(&MyClass::func, &object);</p>
        </code>
        <p>-Функтор (функция-объект):</p>
        <code>
            <p class="cpp_code">struct MyFunctor</p>
            <p class="cpp_code">{</p>
            <p class="cpp_code_1t">void operator()()</p>
            <p class="cpp_code_1t">{</p>
            <p class="cpp_code_1t">}</p>
            <p class="cpp_code">};</p>
            <br>
            <p class="cpp_code">sf::Thread thread(MyFunctor());</p>
        </code>
        <p>Последний пример, в котором используются функторы, является наиболее мощным, поскольку он может принимать функторы любого типа и, следовательно, делает sf::Thread совместимым со многими типами функций, которые напрямую не поддерживаются. Эта функция
            особенно интересна для лямбда-выражений C++11 или std::bind.</p>
        <code>
            <p class="cpp_code">// with lambdas</p>
            <p class="cpp_code">sf::Thread thread([](){</p>
            <p class="cpp_code_1t">std::cout &lt;&lt; "I am in thread!" &lt;&lt; std::endl;</p>
            <p class="cpp_code">});</p>
        </code>
        <code>
            <p class="cpp_code">// with std::bind</p>
            <p class="cpp_code">void func(std::string, int, double)</p>
            <p class="cpp_code">{</p>
            <p class="cpp_code">}</p>
            <br>
            <p class="cpp_code">sf::Thread thread(std::bind(&func, "hello", 24, 0.5));</p>
        </code>
        <p>Если вы хотите использовать sf::Thread внутри класса, не забывайте, что у него нет конструктора по умолчанию. Поэтому вы должны инициализировать его непосредственно в списке инициализации конструктора:</p>
        <code>
            <p class="cpp_code">class ClassWithThread</p>
            <p class="cpp_code">{</p>
            <p class="cpp_code">public:</p>
            <br>
            <p class="cpp_code_1t">ClassWithThread():m_thread(&ClassWithThread::f, this)</p>
            <p class="cpp_code_1t">{</p>
            <p class="cpp_code_1t">}</p>
            <br>
            <p class="cpp_code">private:</p>
            <br>
            <p class="cpp_code_1t">void f()</p>
            <p class="cpp_code_1t">{</p>
            <p class="cpp_code_2t">...</p>
            <p class="cpp_code_1t">}</p>
            <br>
            <p class="cpp_code_1t">sf::Thread m_thread;</p>
            <p class="cpp_code">};</p>
        </code>
        <p>Если вам действительно нужно создать экземпляр sf::Thread после создания объекта-владельца, вы также можете отложить его создание, динамически выделив его в куче.</p>
        <hr>
        <h2>Начало потоков</h2>
        <p>После того, как вы создали экземпляр sf::Thread, вы должны запустить его с помощью функции запуска.</p>
        <code>
            <p class="cpp_code">sf::Thread thread(&func);</p>
            <p class="cpp_code">thread.launch();</p>
        </code>
        <p>launch вызывает функцию, которую вы передали конструктору в новом потоке, и немедленно возвращает значение, чтобы вызывающий поток мог продолжить работу.</p>
        <hr>
        <h2>Остановка потоков</h2>
        <p>Поток автоматически останавливается, когда его функция точки входа возвращается. Если вы хотите дождаться завершения потока из другого потока, вы можете вызвать его функцию ожидания.</p>
        <code>
            <p class="cpp_code">sf::Thread thread(&func);</p>
            <br>
            <p class="cpp_code">// start the thread</p>
            <p class="cpp_code">thread.launch();</p>
            <br>
            <p class="cpp_code">...</p>
            <br>
            <p class="cpp_code">// block execution until the thread is finished</p>
            <p class="cpp_code">thread.wait();</p>
        </code>
        <p>Функция ожидания также неявно вызывается деструктором sf::Thread, так что поток не может оставаться в живых (и выйти из-под контроля) после уничтожения экземпляра его владельца sf::Thread. Помните об этом, когда будете управлять своими потоками
            (см. последний раздел этого руководства).</p>
        <hr>
        <h2>Приостановка потоков</h2>
        <p>В sf::Thread нет функции, позволяющей другому потоку приостановить его, единственный способ приостановить поток — сделать это из кода, который он выполняет. Другими словами, вы можете только приостановить текущий поток. Для этого вы можете вызвать
            функцию sf::sleep:</p>
        <code>
            <p class="cpp_code">void func()</p>
            <p class="cpp_code">{</p>
            <p class="cpp_code_1t">...</p>
            <p class="cpp_code_1t">sf::sleep(sf::milliseconds(10));</p>
            <p class="cpp_code_1t">...</p>
            <p class="cpp_code">}</p>
        </code>
        <p>sf::sleep имеет один аргумент — время сна. Эта продолжительность может быть задана с любой единицей измерения/точностью.</p>
        <p>Обратите внимание, что с помощью этой функции вы можете перевести в спящий режим любой поток, даже основной.</p>
        <p>sf::sleep — самый эффективный способ приостановить поток: пока поток спит, он не требует ЦП. Паузы, основанные на активном ожидании, такие как пустые циклы while, будут потреблять 100% ЦП только для того, чтобы делать... ничего. Однако имейте
            в виду, что продолжительность сна — это всего лишь подсказка, в зависимости от ОС она будет более или менее точной. Так что не полагайтесь на него для очень точного времени.</p>
        <hr>
        <h2>Защита общих данных</h2>
        <p>Все потоки в программе используют одну и ту же память, они имеют доступ ко всем переменным в той области видимости, в которой они находятся. Это очень удобно, но и опасно: поскольку потоки выполняются параллельно, это означает, что переменная
            или функция могут использоваться одновременно из несколько потоков одновременно. Если операция не является потокобезопасной, она может привести к неопределенному поведению (т. е. к сбою или повреждению данных).</p>
        <p>Существует несколько инструментов программирования, помогающих защитить общие данные и сделать ваш код потокобезопасным. Они называются примитивами синхронизации. Распространенными являются мьютексы, семафоры, условные переменные и спин-блокировки.
            Все они являются вариантами одной и той же концепции: они защищают фрагмент кода, разрешая доступ к нему только определенным потокам и блокируя другие.</p>
        <p>Самым основным (и используемым) примитивом является мьютекс. Мьютекс означает «ВЗАИМНОЕ ИСКЛЮЧЕНИЕ»: он гарантирует, что только один поток сможет запустить код, который он охраняет. Давайте посмотрим, как они могут навести порядок в примере выше:</p>
        <code>
            <p class="cpp_code">#include &lt;SFML/System.hpp&gt;</p>
            <p class="cpp_code">#include &lt;iostream&gt;</p>
            <br>
            <p class="cpp_code">sf::Mutex mutex;</p>
            <br>
            <p class="cpp_code">void func()</p>
            <p class="cpp_code">{</p>
            <p class="cpp_code_1t">mutex.lock();</p>
            <br>
            <p class="cpp_code_1t">for (int i = 0; i &lt; 10; ++i)</p>
            <p class="cpp_code_2t">std::cout &lt;&lt; "I'm thread number one" &lt;&lt; std::endl;</p>
            <br>
            <p class="cpp_code_1t">mutex.unlock();</p>
            <p class="cpp_code">}</p>
            <br>
            <p class="cpp_code">int main()</p>
            <p class="cpp_code">{</p>
            <p class="cpp_code_1t">sf::Thread thread(&func);</p>
            <p class="cpp_code_1t">thread.launch();</p>
            <br>
            <p class="cpp_code_1t">mutex.lock();</p>
            <br>
            <p class="cpp_code_1t">for (int i = 0; i &lt; 10; ++i)</p>
            <p class="cpp_code_2t">std::cout &lt;&lt; "I'm the main thread" &lt;&lt; std::endl;</p>
            <br>
            <p class="cpp_code_1t">mutex.unlock();</p>
            <br>
            <p class="cpp_code_1t">return 0;</p>
            <p class="cpp_code">}</p>            
        </code>
        <p>Этот код использует общий ресурс (std::cout) и, как мы видели, приводит к нежелательным результатам — в консоли все смешано. Чтобы убедиться, что полные строки печатаются правильно, а не смешиваются случайным образом, мы защищаем соответствующую
            область кода с помощью мьютекса.</p>
        <p>Первый поток, который достигает своей строки mutex.lock(), успешно блокирует мьютекс, напрямую получает доступ к следующему коду и печатает его текст. Когда другой поток достигает своей строки mutex.lock(), мьютекс уже заблокирован, и, таким образом,
            поток переходит в спящий режим (подобно sf::sleep, спящий поток не потребляет процессорное время). Когда первый поток, наконец, разблокирует мьютекс, пробуждается второй поток, которому разрешается заблокировать мьютекс и также распечатать
            его текстовый блок. Это приводит к тому, что строки текста отображаются в консоли последовательно, а не смешиваются.</p>
        <img src="./01_02_02.png" alt="">
        <p>Мьютексы — не единственный примитив, который можно использовать для защиты общих переменных, но в большинстве случаев этого должно быть достаточно. Однако, если ваше приложение делает сложные вещи с потоками, и вам кажется, что этого недостаточно,
            не стесняйтесь искать настоящую библиотеку потоков с большим количеством функций.</p>
        <hr>
        <h2>Защита мьютексов</h2>
        <p>Не беспокойтесь: мьютексы уже потокобезопасны, их не нужно защищать. Но они не безопасны для исключений! Что произойдет, если возникнет исключение, когда мьютекс заблокирован? У него никогда не будет шанса быть разблокированным, и он останется
            заблокированным навсегда. Все потоки, которые попытаются заблокировать его в будущем, будут заблокированы навсегда, а в некоторых случаях все ваше приложение может зависнуть. Довольно плохой результат.</p>
        <p>Чтобы убедиться, что мьютексы всегда разблокированы в среде, где могут быть выброшены исключения, SFML предоставляет класс RAII для их обертывания: sf::Lock. Он блокирует мьютекс в своем конструкторе и разблокирует его в своем деструкторе. Просто
            и эффективно.</p>
        <code>
            <p class="cpp_code">sf::Mutex mutex;</p>
            <br>
            <p class="cpp_code">void func()</p>
            <p class="cpp_code">{</p>
            <p class="cpp_code_1t">sf::Lock lock(mutex); // mutex.lock()</p>
            <br>
            <p class="cpp_code_1t">functionThatMightThrowAnException(); // mutex.unlock() if this function throws</p>
            <br>
            <p class="cpp_code">} // mutex.unlock()</p>
        </code>
        <p>Обратите внимание, что sf::Lock также может быть полезен в функции с несколькими операторами возврата.</p>
        <code>
            <p class="cpp_code">sf::Mutex mutex;</p>
            <br>
            <p class="cpp_code">bool func()</p>
            <p class="cpp_code">{</p>
            <p class="cpp_code_1t">sf::Lock lock(mutex); // mutex.lock()</p>
            <br>
            <p class="cpp_code_1t">if (!image1.loadFromFile("..."))</p>
            <p class="cpp_code_2t">return false; // mutex.unlock()</p>
            <br>
            <p class="cpp_code_1t">if (!image2.loadFromFile("..."))</p>
            <p class="cpp_code_2t">return false; // mutex.unlock()</p>
            <br>
            <p class="cpp_code_1t">if (!image3.loadFromFile("..."))</p>
            <p class="cpp_code_2t">return false; // mutex.unlock()</p>
            <br>
            <p class="cpp_code_1t">return true;</p>
            <p class="cpp_code">} // mutex.unlock()</p>
        </code>
        <hr>
        <h2>Распространенные ошибки</h2>
        <p>Одна вещь, которую часто упускают из виду программисты, заключается в том, что поток не может существовать без соответствующего экземпляра sf::Thread. На форумах часто можно увидеть следующий код:</p>
        <code>
            <p class="cpp_code">void startThread()</p>
            <p class="cpp_code">{</p>
            <p class="cpp_code_1t">sf::Thread thread(&funcToRunInThread);</p>
            <p class="cpp_code_1t">thread.launch();</p>
            <p class="cpp_code">}</p>
            <br>
            <p class="cpp_code"></p>
            <p class="cpp_code">{</p>
            <p class="cpp_code_1t">startThread();</p>
            <p class="cpp_code_1t">// ...</p>
            <p class="cpp_code_1t">return 0;</p>
            <p class="cpp_code">}</p>
        </code>
        <p>Программисты, которые пишут код такого типа, ожидают, что функция startThread() запустит поток, который будет жить сам по себе и будет уничтожен, когда функция с потоком завершится. Это не то, что происходит. Потоковая функция блокирует основной
            поток, как будто этот поток не работает.</p>
        <p>Какова причина этого? Экземпляр sf::Thread является локальным для функции startThread() и поэтому немедленно уничтожается, когда функция возвращается. Вызывается деструктор sf::Thread, который вызывает функцию wait(), как мы узнали выше, и в результате
            основной поток блокируется и ожидает завершения потоковой функции вместо того, чтобы продолжать выполняться параллельно.</p>
        <p>Так что не забывайте: вы должны управлять своим экземпляром sf::Thread так, чтобы он существовал до тех пор, пока должна выполняться потоковая функция.</p>
        <hr>
        <p><a href="./01_03.html">Потоки пользовательских данных&rArr;</a></p>
    </div>
</body>