<head>
    <link rel="stylesheet" href="../../../css/books_style.css">
</head>

<body>
    <div>
        <p><a href="./02_01.html">&lArr;Открытие и управление окном в SFML</a></p>
        <h1>Обработчики событий</h1>
        <hr>
        <h2>Вступление</h2>
        <p>Этот учебник представляет собой подробный список оконных событий. Он описывает их и показывает, как (и как не следует) их использовать.</p>
        <hr>
        <h2>Тип sf::Event</h2>
        <p>Прежде чем иметь дело с событиями, важно понять, что такое тип sf::Event и как его правильно использовать. sf::Event является объединением, что означает, что только один из его членов является действительным в каждый момент времени (вспомните
            свой урок C++: все члены объединения совместно используют одно и то же пространство памяти). Допустимым членом является тот, который соответствует типу события, например, event.key для события KeyPressed. Попытка прочитать любой другой член
            приведет к неопределенному поведению (скорее всего: случайные или недопустимые значения). Важно никогда не пытаться использовать элемент события, который не соответствует его типу.</p>
        <p>Экземпляры sf::Event заполняются функцией pollEvent (или waitEvent) класса sf::Window. Только эти две функции могут создавать действительные события, любая попытка использовать sf::Event, который не был возвращен успешным вызовом pollEvent (или
            waitEvent), приведет к тому же неопределенному поведению, которое было упомянуто выше.</p>
        <p>Чтобы было понятно, вот как выглядит типичный цикл обработки событий:</p>
        <code>
            <p class="cpp_code">sf::Event event;</p>
            <br>
            <p class="cpp_code">// while there are pending events...</p>
            <p class="cpp_code">while (window.pollEvent(event))</p>
            <p class="cpp_code">{</p>
            <p class="cpp_code_1t">// check the type of the event...</p>
            <p class="cpp_code_1t">switch (event.type)</p>
            <p class="cpp_code_1t">{</p>
            <p class="cpp_code_2t">// window closed</p>
            <p class="cpp_code_2t">case sf::Event::Closed:</p>
            <p class="cpp_code_3t">window.close();</p>
            <p class="cpp_code_3t">break;</p>
            <br>
            <p class="cpp_code_2t">// key pressed</p>
            <p class="cpp_code_2t">case sf::Event::KeyPressed:</p>
            <p class="cpp_code_3t">...</p>
            <p class="cpp_code_3t">break;</p>
            <br>
            <p class="cpp_code_2t">// we don't process other types of events</p>
            <p class="cpp_code_2t">default:</p>
            <p class="cpp_code_3t">break;</p>
            <p class="cpp_code_1t">}</p>
            <p class="cpp_code">}</p>
        </code>
        <div class="atention">
            <p>Прочтите вышеприведенный абзац еще раз и убедитесь, что вы полностью его понимаете, объединение sf::Event является причиной многих проблем для неопытных программистов.</p>
        </div>
        <p>Хорошо, теперь мы можем увидеть, какие события поддерживает SFML, что они означают и как их правильно использовать.</p>
        <hr>
        <h2>Событие закрытия</h2>
        <p>Событие sf::Event::Closed запускается, когда пользователь хочет закрыть окно любым из возможных методов, предоставляемых оконным менеджером (кнопка «закрыть», сочетание клавиш и т. д.). Это событие представляет собой только запрос на закрытие,
            окно еще не закрыто, когда получено событие.</p>
        <p>Типичный код просто вызывает window.close() в ответ на это событие, чтобы фактически закрыть окно. Однако вы также можете сначала сделать что-то еще, например сохранить текущее состояние приложения или спросить пользователя, что делать. Если ничего
            не делать, окно остается открытым.</p>
        <p>В классе sf::Event нет члена, связанного с этим событием.</p>
        <code>
            <p class="cpp_code">if (event.type == sf::Event::Closed)</p>
            <p class="cpp_code_1t">window.close();</p>
        </code>
        <hr>
        <h2>Изменение размера</h2>
        <p>Событие sf::Event::Resized запускается, когда размер окна изменяется либо в результате действий пользователя, либо программно путем вызова window.setSize.</p>
        <p>Вы можете использовать это событие для настройки параметров рендеринга: области просмотра, если вы используете OpenGL напрямую, или текущего вида, если вы используете sfml-графику.</p>
        <p>Элемент, связанный с этим событием, — event.size, он содержит новый размер окна.</p>
        <code>
            <p class="cpp_code">if (event.type == sf::Event::Resized)</p>
            <p class="cpp_code">{</p>
            <p class="cpp_code_1t">std::cout &lt;&lt; "new width: " &lt;&lt; event.size.width &lt;&lt; std::endl;</p>
            <p class="cpp_code_1t">std::cout &lt;&lt; "new height: " &lt;&lt; event.size.height &lt;&lt; std::endl;</p>
            <p class="cpp_code">}</p>
        </code>
        <hr>
        <h2>Событие LostFocus и GainedFocus (потеря фокуса и обретение фокуса)</h2>
        <p>События sf::Event::LostFocus и sf::Event::GainedFocus запускаются, когда окно теряет/приобретает фокус, что происходит, когда пользователь переключает текущее активное окно. Когда окно не в фокусе, оно не получает события клавиатуры.</p>
        <p>Это событие можно использовать, например. если вы хотите приостановить игру, когда окно неактивно.</p>
        <p>В объединении sf::Event нет члена, связанного с этими событиями.</p>
        <code>
            <p class="cpp_code">if (event.type == sf::Event::LostFocus)</p>
            <p class="cpp_code_1t">myGame.pause();</p>
            <br>
            <p class="cpp_code">if (event.type == sf::Event::GainedFocus)</p>
            <p class="cpp_code_1t">myGame.resume();</p>
        </code>
        <hr>
        <h2>Событие TextEntered (ввод текста)</h2>
        <p>Событие sf::Event::TextEntered запускается при вводе символа. Это не следует путать с событием KeyPressed: TextEntered интерпретирует пользовательский ввод и создает соответствующий печатный символ. Например, нажатие «^», а затем «e» на французской
            клавиатуре создаст два события KeyPressed, но одно событие TextEntered, содержащее символ «ê». Он работает со всеми методами ввода, предоставляемыми операционной системой, даже с самыми специфическими или сложными.</p>
        <p>Это событие обычно используется для перехвата пользовательского ввода в текстовом поле.</p>
        <p>Элемент, связанный с этим событием, — это event.text, он содержит значение Unicode введенного символа. Вы можете либо поместить его непосредственно в sf::String, либо преобразовать в char, убедившись, что он находится в диапазоне ASCII (0–127).</p>
        <p><a href="./02_03.html">&rArr;</a></p>
    </div>
</body>