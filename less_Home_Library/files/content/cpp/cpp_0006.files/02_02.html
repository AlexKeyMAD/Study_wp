<head>
    <link rel="stylesheet" href="../../../css/books_style.css">
</head>

<body>
    <div>
        <p><a href="./02_01.html">&lArr;Открытие и управление окном в SFML</a></p>
        <h1>Обработчики событий</h1>
        <hr>
        <h2>Вступление</h2>
        <p>Этот учебник представляет собой подробный список оконных событий. Он описывает их и показывает, как (и как не следует) их использовать.</p>
        <hr>
        <h2>Тип sf::Event</h2>
        <p>Прежде чем иметь дело с событиями, важно понять, что такое тип sf::Event и как его правильно использовать. sf::Event является объединением, что означает, что только один из его членов является действительным в каждый момент времени (вспомните
            свой урок C++: все члены объединения совместно используют одно и то же пространство памяти). Допустимым членом является тот, который соответствует типу события, например, event.key для события KeyPressed. Попытка прочитать любой другой член
            приведет к неопределенному поведению (скорее всего: случайные или недопустимые значения). Важно никогда не пытаться использовать элемент события, который не соответствует его типу.</p>
        <p>Экземпляры sf::Event заполняются функцией pollEvent (или waitEvent) класса sf::Window. Только эти две функции могут создавать действительные события, любая попытка использовать sf::Event, который не был возвращен успешным вызовом pollEvent (или
            waitEvent), приведет к тому же неопределенному поведению, которое было упомянуто выше.</p>
        <p>Чтобы было понятно, вот как выглядит типичный цикл обработки событий:</p>
        <code>
            <p class="cpp_code">sf::Event event;</p>
            <br>
            <p class="cpp_code">// while there are pending events...</p>
            <p class="cpp_code">while (window.pollEvent(event))</p>
            <p class="cpp_code">{</p>
            <p class="cpp_code_1t">// check the type of the event...</p>
            <p class="cpp_code_1t">switch (event.type)</p>
            <p class="cpp_code_1t">{</p>
            <p class="cpp_code_2t">// window closed</p>
            <p class="cpp_code_2t">case sf::Event::Closed:</p>
            <p class="cpp_code_3t">window.close();</p>
            <p class="cpp_code_3t">break;</p>
            <br>
            <p class="cpp_code_2t">// key pressed</p>
            <p class="cpp_code_2t">case sf::Event::KeyPressed:</p>
            <p class="cpp_code_3t">...</p>
            <p class="cpp_code_3t">break;</p>
            <br>
            <p class="cpp_code_2t">// we don't process other types of events</p>
            <p class="cpp_code_2t">default:</p>
            <p class="cpp_code_3t">break;</p>
            <p class="cpp_code_1t">}</p>
            <p class="cpp_code">}</p>
        </code>
        <div class="atention">
            <p>Прочтите вышеприведенный абзац еще раз и убедитесь, что вы полностью его понимаете, объединение sf::Event является причиной многих проблем для неопытных программистов.</p>
        </div>
        <p>Хорошо, теперь мы можем увидеть, какие события поддерживает SFML, что они означают и как их правильно использовать.</p>
        <hr>
        <h2>Событие закрытия</h2>
        <p>Событие sf::Event::Closed запускается, когда пользователь хочет закрыть окно любым из возможных методов, предоставляемых оконным менеджером (кнопка «закрыть», сочетание клавиш и т. д.). Это событие представляет собой только запрос на закрытие,
            окно еще не закрыто, когда получено событие.</p>
        <p>Типичный код просто вызывает window.close() в ответ на это событие, чтобы фактически закрыть окно. Однако вы также можете сначала сделать что-то еще, например сохранить текущее состояние приложения или спросить пользователя, что делать. Если ничего
            не делать, окно остается открытым.</p>
        <p>В классе sf::Event нет члена, связанного с этим событием.</p>
        <code>
            <p class="cpp_code">if (event.type == sf::Event::Closed)</p>
            <p class="cpp_code_1t">window.close();</p>
        </code>
        <hr>
        <h2>Изменение размера</h2>
        <p>Событие sf::Event::Resized запускается, когда размер окна изменяется либо в результате действий пользователя, либо программно путем вызова window.setSize.</p>
        <p>Вы можете использовать это событие для настройки параметров рендеринга: области просмотра, если вы используете OpenGL напрямую, или текущего вида, если вы используете sfml-графику.</p>
        <p>Элемент, связанный с этим событием, — event.size, он содержит новый размер окна.</p>
        <code>
            <p class="cpp_code">if (event.type == sf::Event::Resized)</p>
            <p class="cpp_code">{</p>
            <p class="cpp_code_1t">std::cout &lt;&lt; "new width: " &lt;&lt; event.size.width &lt;&lt; std::endl;</p>
            <p class="cpp_code_1t">std::cout &lt;&lt; "new height: " &lt;&lt; event.size.height &lt;&lt; std::endl;</p>
            <p class="cpp_code">}</p>
        </code>
        <hr>
        <h2>Событие LostFocus и GainedFocus (потеря фокуса и обретение фокуса)</h2>
        <p>События sf::Event::LostFocus и sf::Event::GainedFocus запускаются, когда окно теряет/приобретает фокус, что происходит, когда пользователь переключает текущее активное окно. Когда окно не в фокусе, оно не получает события клавиатуры.</p>
        <p>Это событие можно использовать, например. если вы хотите приостановить игру, когда окно неактивно.</p>
        <p>В объединении sf::Event нет члена, связанного с этими событиями.</p>
        <code>
            <p class="cpp_code">if (event.type == sf::Event::LostFocus)</p>
            <p class="cpp_code_1t">myGame.pause();</p>
            <br>
            <p class="cpp_code">if (event.type == sf::Event::GainedFocus)</p>
            <p class="cpp_code_1t">myGame.resume();</p>
        </code>
        <hr>
        <h2>Событие TextEntered (ввод текста)</h2>
        <p>Событие sf::Event::TextEntered запускается при вводе символа. Это не следует путать с событием KeyPressed: TextEntered интерпретирует пользовательский ввод и создает соответствующий печатный символ. Например, нажатие «^», а затем «e» на французской
            клавиатуре создаст два события KeyPressed, но одно событие TextEntered, содержащее символ «ê». Он работает со всеми методами ввода, предоставляемыми операционной системой, даже с самыми специфическими или сложными.</p>
        <p>Это событие обычно используется для перехвата пользовательского ввода в текстовом поле.</p>
        <p>Элемент, связанный с этим событием, — это event.text, он содержит значение Unicode введенного символа. Вы можете либо поместить его непосредственно в sf::String, либо преобразовать в char, убедившись, что он находится в диапазоне ASCII (0–127).</p>
        <code>
            <p class="cpp_code">if (event.type == sf::Event::TextEntered)</p>
            <p class="cpp_code">{</p>
            <p class="cpp_code_1t">if (event.text.unicode &lt; 128)</p>
            <p class="cpp_code_2t">std::cout &lt;&lt; "ASCII character typed: " &lt;&lt; static_cast<char>(event.text.unicode) &lt;&lt; std::endl;</p>
            <p class="cpp_code">}</p>
        </code>
        <p>Обратите внимание, что, поскольку они являются частью стандарта Unicode, некоторые непечатаемые символы, такие как backspace, генерируются этим событием. В большинстве случаев вам нужно будет отфильтровать их.</p>
        <div class="atention">
            <p>Многие программисты используют событие KeyPressed для получения пользовательского ввода и начинают реализовывать сумасшедшие алгоритмы, которые пытаются интерпретировать все возможные комбинации клавиш для получения правильных символов. Не
                делай этого!</p>
        </div>
        <hr>
        <h2>События KeyPressed и KeyReleased (нажатие и отжатие клавиши)</h2>
        <p>События sf::Event::KeyPressed и sf::Event::KeyReleased запускаются при нажатии/отпускании клавиши клавиатуры.</p>
        <p>Если клавиша удерживается, будет сгенерировано несколько событий KeyPressed с задержкой операционной системы по умолчанию (т. е. той же задержкой, которая применяется, когда вы удерживаете букву в текстовом редакторе). Чтобы отключить повторяющиеся
            события KeyPressed, вы можете вызвать window.setKeyRepeatEnabled(false). С другой стороны, очевидно, что события KeyReleased никогда не могут повторяться.</p>
        <p>Это событие следует использовать, если вы хотите инициировать действие ровно один раз при нажатии или отпускании клавиши, например, прыжок персонажа с пробелом или выход из чего-либо с помощью escape.</p>
        <div class="atention">
            <p>Иногда люди пытаются реагировать на события KeyPressed напрямую, чтобы реализовать плавное движение. Это не даст ожидаемого эффекта, потому что, когда вы удерживаете клавишу, вы получаете только несколько событий (помните, задержка повтора).
                Чтобы добиться плавного перемещения событий, вы должны использовать логическое значение, которое вы устанавливаете для KeyPressed и очищаете для KeyReleased; затем вы можете перемещаться (независимо от событий), пока установлено логическое
                значение.
            </p>
            <p>Другое (более простое) решение для создания плавного движения — использовать ввод с клавиатуры в реальном времени с помощью sf::Keyboard (см. специальный учебник).</p>
        </div>
        <p>Элемент, связанный с этими событиями, — это event.key, он содержит код нажатой/отпущенной клавиши, а также текущее состояние клавиш-модификаторов (alt, control, shift, system).</p>
        <code>
            <p class="cpp_code">if (event.type == sf::Event::KeyPressed)</p>
            <p class="cpp_code">{</p>
            <p class="cpp_code_1t">if (event.key.code == sf::Keyboard::Escape)</p>
            <p class="cpp_code_1t">{</p>
            <p class="cpp_code_2t">std::cout &lt;&lt; "the escape key was pressed" &lt;&lt; std::endl;</p>
            <p class="cpp_code_2t">std::cout &lt;&lt; "control:" &lt;&lt; event.key.control &lt;&lt; std::endl;</p>
            <p class="cpp_code_2t">std::cout &lt;&lt; "alt:" &lt;&lt; event.key.alt &lt;&lt; std::endl;</p>
            <p class="cpp_code_2t">std::cout &lt;&lt; "shift:" &lt;&lt; event.key.shift &lt;&lt; std::endl;</p>
            <p class="cpp_code_2t">std::cout &lt;&lt; "system:" &lt;&lt; event.key.system &lt;&lt; std::endl;</p>
            <p class="cpp_code_1t">}</p>
            <p class="cpp_code">}</p>
        </code>
        <p>Обратите внимание, что некоторые клавиши имеют особое значение для операционной системы и могут привести к неожиданному поведению. Примером может служить клавиша F10 в Windows, которая «крадет» фокус, или клавиша F12, которая запускает отладчик
            при использовании Visual Studio. Вероятно, это будет решено в будущей версии SFML.</p>
        <hr>
        <h2>Событие MouseWheelMoved (Перемещение колесиком мыши)</h2>
        <p>Событие sf::Event::MouseWheelMoved устарело, начиная с SFML 2.3, вместо этого используйте событие MouseWheelScrolled.</p>
        <hr>
        <h2>Событие MouseWheelScrolled (Прокрутка колеса мыши)</h2>
        <p>Событие sf::Event::MouseWheelScrolled запускается, когда колесико мыши перемещается вверх или вниз, а также в боковом направлении, если мышь это поддерживает.</p>
        <p>Элемент, связанный с этим событием, — event.mouseWheelScroll, он содержит количество тиков, на которые переместилось колесо, ориентацию колеса и текущую позицию курсора мыши.</p>
        <code>
            <p class="cpp_code">if (event.type == sf::Event::MouseWheelScrolled)</p>
            <p class="cpp_code">{</p>
            <p class="cpp_code_1t">if (event.mouseWheelScroll.wheel == sf::Mouse::VerticalWheel)</p>
            <p class="cpp_code_2t">std::cout &lt;&lt; "wheel type: vertical" &lt;&lt; std::endl;</p>
            <p class="cpp_code_1t">else if (event.mouseWheelScroll.wheel == sf::Mouse::HorizontalWheel)</p>
            <p class="cpp_code_2t">std::cout &lt;&lt; "wheel type: horizontal" &lt;&lt; std::endl;</p>
            <p class="cpp_code_1t">else</p>
            <p class="cpp_code_2t">std::cout &lt;&lt; "wheel type: unknown" &lt;&lt; std::endl;</p>
            <p class="cpp_code_1t">std::cout &lt;&lt; "wheel movement: " &lt;&lt; event.mouseWheelScroll.delta &lt;&lt; std::endl;</p>
            <p class="cpp_code_1t">std::cout &lt;&lt; "mouse x: " &lt;&lt; event.mouseWheelScroll.x &lt;&lt; std::endl;</p>
            <p class="cpp_code_1t">std::cout &lt;&lt; "mouse y: " &lt;&lt; event.mouseWheelScroll.y &lt;&lt; std::endl;</p>
            <p class="cpp_code">}</p>
        </code>
        <hr>
        <h2>События MouseButtonPressed и MouseButtonReleased (Нажате и отпуск кнопки мыши)</h2>
        <p>События sf::Event::MouseButtonPressed и sf::Event::MouseButtonReleased запускаются при нажатии/отпускании кнопки мыши.</p>
        <p>SFML поддерживает 5 кнопок мыши: левую, правую, среднюю (колесико), дополнительную №1 и дополнительную №2 (боковые кнопки).</p>
        <p>Элемент, связанный с этими событиями, — это event.mouseButton, он содержит код нажатой/отпущенной кнопки, а также текущую позицию курсора мыши.</p>
        <code>
            <p class="cpp_code">if (event.type == sf::Event::MouseButtonPressed)</p>
            <p class="cpp_code">{</p>
            <p class="cpp_code_1t">if (event.mouseButton.button == sf::Mouse::Right)</p>
            <p class="cpp_code_1t">{</p>
            <p class="cpp_code_2t">std::cout &lt;&lt; "the right button was pressed" &lt;&lt; std::endl;</p>
            <p class="cpp_code_2t">std::cout &lt;&lt; "mouse x: " &lt;&lt; event.mouseButton.x &lt;&lt; std::endl;</p>
            <p class="cpp_code_2t">std::cout &lt;&lt; "mouse y: " &lt;&lt; event.mouseButton.y &lt;&lt; std::endl;</p>
            <p class="cpp_code_1t">}</p>
            <p class="cpp_code">}</p>
        </code>
        <hr>
        <h2>События MouseMoved (Перемещение мыши)</h2>
        <p>Событие sf::Event::MouseMoved запускается, когда мышь перемещается в пределах окна.</p>
        <p>Это событие запускается, даже если окно не сфокусировано. Однако он срабатывает только тогда, когда мышь перемещается во внутренней области окна, а не когда она перемещается по строке заголовка или границам.</p>
        <p>Член, связанный с этим событием, — event.mouseMove, он содержит текущую позицию курсора мыши относительно окна.</p>
        <code>
            <p class="cpp_code">if (event.type == sf::Event::MouseMoved)</p>
            <p class="cpp_code">{</p>
            <p class="cpp_code_1t">std::cout &lt;&lt; "new mouse x: " &lt;&lt; event.mouseMove.x &lt;&lt; std::endl;</p>
            <p class="cpp_code_1t">std::cout &lt;&lt; "new mouse y: " &lt;&lt; event.mouseMove.y &lt;&lt; std::endl;</p>
            <p class="cpp_code">}</p>
        </code>
        <hr>
        <h2>События MouseEntered и MouseLeft</h2>
        <p>События sf::Event::MouseEntered и sf::Event::MouseLeft запускаются, когда курсор мыши входит в окно или покидает его.</p>
        <p>В объединении sf::Event нет члена, связанного с этими событиями.</p>
        <code>
            <p class="cpp_code">if (event.type == sf::Event::MouseEntered)</p>
            <p class="cpp_code_1t">std::cout &lt;&lt; "the mouse cursor has entered the window" &lt;&lt; std::endl;</p>
            <br>
            <p class="cpp_code">if (event.type == sf::Event::MouseLeft)</p>
            <p class="cpp_code_1t">std::cout &lt;&lt; "the mouse cursor has left the window" &lt;&lt; std::endl;</p>
        </code>
        <hr>
        <h2>События JoystickButtonPressed и JoystickButtonReleased (Джойстик нажатие и отпуск кнопки)</h2>
        <p>События sf::Event::JoystickButtonPressed и sf::Event::JoystickButtonReleased запускаются при нажатии/отпускании кнопки джойстика.</p>
        <p>SFML поддерживает до 8 джойстиков и 32 кнопки.</p>
        <p>Элемент, связанный с этими событиями, — это event.joystickButton, он содержит идентификатор джойстика и индекс нажатой/отпущенной кнопки.</p>
        <code>
            <p class="cpp_code">if (event.type == sf::Event::JoystickButtonPressed)</p>
            <p class="cpp_code">{</p>
            <p class="cpp_code_1t">std::cout &lt;&lt; "joystick button pressed!" &lt;&lt; std::endl;</p>
            <p class="cpp_code_1t">std::cout &lt;&lt; "joystick id: " &lt;&lt; event.joystickButton.joystickId &lt;&lt; std::endl;</p>
            <p class="cpp_code_1t">std::cout &lt;&lt; "button: " &lt;&lt; event.joystickButton.button &lt;&lt; std::endl;</p>
            <p class="cpp_code">}</p>
        </code>
        <hr>
        <h2>Событие JoystickMoved (Перемещение джойстика)</h2>
        <p>Событие sf::Event::JoystickMoved запускается при перемещении оси джойстика.</p>
        <p>Оси джойстика, как правило, очень чувствительны, поэтому SFML использует порог обнаружения, чтобы избежать спама в вашем цикле событий тоннами событий JoystickMoved. Этот порог можно изменить с помощью функции Window::setJoystickThreshold, если
            вы хотите получать больше или меньше событий перемещения джойстика.</p>
        <p>SFML поддерживает 8 осей джойстика: X, Y, Z, R, U, V, POV X и POV Y. Как они соотносятся с вашим джойстиком, зависит от его драйвера.</p>
        <p>Член, связанный с этим событием, — event.joystickMove, он содержит идентификатор джойстика, имя оси и ее текущую позицию (в диапазоне [-100, 100]).</p>
        <code>
            <p class="cpp_code">if (event.type == sf::Event::JoystickMoved)</p>
            <p class="cpp_code">{</p>
            <p class="cpp_code_1t">if (event.joystickMove.axis == sf::Joystick::X)</p>
            <p class="cpp_code_1t">{</p>
            <p class="cpp_code_2t">std::cout &lt;&lt; "X axis moved!" &lt;&lt; std::endl;</p>
            <p class="cpp_code_2t">std::cout &lt;&lt; "joystick id: " &lt;&lt; event.joystickMove.joystickId &lt;&lt; std::endl;</p>
            <p class="cpp_code_2t">std::cout &lt;&lt; "new position: " &lt;&lt; event.joystickMove.position &lt;&lt; std::endl;</p>
            <p class="cpp_code_1t">}</p>
            <p class="cpp_code">}</p>
        </code>
        <hr>
        <h2>События JoystickConnected и JoystickDisconnected (Подключение и отключение джойстика)</h2>
        <p>События sf::Event::JoystickConnected и sf::Event::JoystickDisconnected запускаются при подключении/отключении джойстика.</p>
        <p>Элемент, связанный с этим событием, — event.joystickConnect, он содержит идентификатор подключенного/отключенного джойстика.</p>
        <code>
            <p class="cpp_code">if (event.type == sf::Event::JoystickConnected)</p>
            <p class="cpp_code_1t">std::cout &lt;&lt; "joystick connected: " &lt;&lt; event.joystickConnect.joystickId &lt;&lt; std::endl;</p>
            <br>
            <p class="cpp_code">if (event.type == sf::Event::JoystickDisconnected)</p>
            <p class="cpp_code_1t">std::cout &lt;&lt; "joystick disconnected: " &lt;&lt; event.joystickConnect.joystickId &lt;&lt; std::endl;</p>
        </code>
        <hr>
        <p><a href="./02_03.html">Клавиатура, мышь и джойстик&rArr;</a></p>
    </div>
</body>