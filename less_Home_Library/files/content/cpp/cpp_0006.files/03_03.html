<head>
    <link rel="stylesheet" href="../../../css/books_style.css">
</head>

<body>
    <div>
        <p><a href="./03_02.html">&lArr;Спрайты и текстуры</a></p>
        <h1>Текст и шрифты</h1>
        <hr>
        <h2>Загрузка шрифта</h2>
        <p>Прежде чем рисовать какой-либо текст, вам нужно иметь доступный шрифт, как и в любой другой программе, которая печатает текст. Шрифты инкапсулированы в класс sf::Font, который обеспечивает три основные функции: загрузку шрифта, получение от него
            глифов (то есть визуальных символов) и чтение его атрибутов. В типичной программе вам нужно будет использовать только первую функцию, загрузку шрифта, поэтому давайте сначала сосредоточимся на ней.</p>
        <p>Самый распространенный способ загрузки шрифта — из файла на диске, который выполняется с помощью функции loadFromFile.</p>
        <img src="./03_03_01.png" alt="">
        <p>Обратите внимание, что SFML не будет автоматически загружать ваши системные шрифты, т. е. font.loadFromFile("Courier New") не будет работать. Во-первых, потому что SFML требует имен файлов, а не имен шрифтов, и, во-вторых, потому что SFML не имеет
            волшебного доступа к папке шрифтов вашей системы. Если вы хотите загрузить шрифт, вам нужно будет включить файл шрифта в ваше приложение, как и любой другой ресурс (изображения, звуки и т. д.).</p>
        <div class="atention">
            <p>Иногда функция loadFromFile может дать сбой без видимой причины. Сначала проверьте сообщение об ошибке, которое SFML выводит на стандартный вывод (проверьте консоль). Если в сообщении не удается открыть файл, убедитесь, что рабочий каталог
                (который является каталогом, относительно которого будет интерпретироваться любой путь к файлу) является тем, что вы думаете: когда вы запускаете приложение из среды рабочего стола, рабочий каталог это исполняемая папка. Однако, когда
                вы запускаете свою программу из IDE (Visual Studio, Code::Blocks,...), рабочий каталог иногда может быть установлен вместо каталога проекта. Обычно это можно легко изменить в настройках проекта.</p>
        </div>
        <p>Вы также можете загрузить файл шрифта из памяти (loadFromMemory) или из пользовательского потока ввода (loadFromStream).</p>
        <p>SFML поддерживает большинство распространенных форматов шрифтов. Полный список доступен в документации по API.</p>
        <p>Это все, что вам нужно сделать. Как только ваш шрифт загружен, вы можете начать рисовать текст.</p>
        <hr>
        <h2>Рисование текста</h2>
        <p>Для рисования текста вы будете использовать класс sf::Text. Его очень просто использовать:</p>
        <img src="./03_03_02.png" alt="">
        <img src="./03_03_03.png" alt="" class="border-none">
        <p>Текст также можно трансформировать: у него есть положение, ориентация и масштаб. Задействованные функции такие же, как для класса sf::Sprite и других сущностей SFML. Они объясняются в учебнике по преобразованию объектов.</p>
        <hr>
        <h2>Как избежать проблем с символами, отличными от ASCII?</h2>
        <p>Правильная обработка символов, отличных от ASCII (таких как акцентированные европейские, арабские или китайские символы), может быть сложной задачей. Это требует хорошего понимания различных кодировок, используемых в процессе интерпретации и рисования
            вашего текста. Чтобы не возиться с этими кодировками, есть простое решение: использовать широкие литеральные строки.</p>
        <img src="./03_03_04.png" alt="">
        <p>Именно этот простой префикс «L» перед строкой заставляет его работать, сообщая компилятору о необходимости создания широкой строки. Широкие строки — странный зверь в C++: в стандарте ничего не сказано ни об их размере (16-разрядные? 32-разрядные?),
            ни о кодировке, которую они используют (UTF-16? UTF-32?). Однако мы знаем, что на большинстве платформ, если не на всех, они будут создавать строки Unicode, и SFML знает, как правильно их обрабатывать.</p>
        <p>Обратите внимание, что стандарт C++11 поддерживает новые типы символов и префиксы для создания строковых литералов UTF-8, UTF-16 и UTF-32, но SFML пока их не поддерживает.</p>
        <p>Это может показаться очевидным, но вы также должны убедиться, что используемый вами шрифт содержит символы, которые вы хотите нарисовать. Действительно, шрифты не содержат глифы для всех возможных символов (в стандарте Unicode их более 100 000!),
            а арабский шрифт, например, не сможет отображать японский текст.</p>
        <hr>
        <h2>Создание собственного текстового класса</h2>
        <p>Если sf::Text слишком ограничен или вы хотите сделать что-то еще с предварительно обработанными глифами, sf::Font предоставит все, что вам нужно. Вы можете получить текстуру, содержащую все предварительно обработанные глифы определенного размера:</p>
        <img src="./03_03_05.png" alt="">
        <p>Важно отметить, что глифы добавляются в текстуру по запросу. Символов так много (напомню, более 100 000), что все они не могут быть сгенерированы при загрузке шрифта. Вместо этого они отображаются на лету, когда вы вызываете функцию getGlyph (см.
            ниже).
        </p>
        <p>Чтобы сделать что-то значимое с текстурой шрифта, вы должны получить текстурные координаты глифов, которые в нем содержатся:</p>
        <img src="./03_03_06.png" alt="">
        <p>символ — это код UTF-32 символа, глиф которого вы хотите получить. Вы также должны указать размер символа и хотите ли вы полужирную или обычную версию глифа.</p>
        <p>Структура sf::Glyph содержит три члена:</p>
        <ul>
            <li><span class="font-bold">textureRect</span> содержит текстурные координаты глифа внутри текстуры.</li>
            <li><span class="font-bold">bounds</span> содержит ограничивающий прямоугольник глифа, который помогает расположить его относительно базовой линии текста.</li>
            <li><span class="font-bold">advance</span> — смещение по горизонтали, применяемое для получения начальной позиции следующего глифа в тексте.</li>
        </ul>
        <p>Вы также можете получить некоторые другие показатели шрифта, такие как кернинг между двумя символами или межстрочный интервал (всегда для определенного размера символов):</p>
        <img src="./03_03_07.png" alt="">
        <p><a href="./03_04.html">Формы&rArr;</a></p>
    </div>
</body>