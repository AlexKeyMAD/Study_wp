<head>
    <link rel="stylesheet" href="../../../css/books_style.css">
</head>

<body>
    <div>
        <p><a href="./03_07.html">&lArr;Добавление спецэффектов с помощью шейдеров</a></p>
        <h1>Управление 2D-камерой с видами</h1>
        <hr>
        <h2>Что такое представление?</h2>
        <p>В играх нередко бывают уровни, которые намного больше, чем само окно. Вы видите только малую их часть. Это типично для ролевых игр, платформеров и многих других жанров. Что разработчики могут забыть, так это то, что они определяют объекты в 2D-мире,
            а не непосредственно в окне. Окно — это просто вид, оно показывает конкретную область всего мира. Совершенно нормально рисовать несколько видов одного и того же мира параллельно или рисовать мир текстурой, а не окном. Сам мир остается неизменным,
            меняется только то, как его видят.</p>
        <p>Поскольку то, что видно в окне, является лишь небольшой частью всего 2D-мира, вам нужен способ указать, какая часть мира отображается в окне. Кроме того, вы также можете определить, где и как эта область будет отображаться в окне. Это две основные
            особенности представлений SFML.</p>
        <p>Подводя итог, представления — это то, что вам нужно, если вы хотите прокручивать, вращать или масштабировать свой мир. Они также являются ключом к созданию разделенных экранов и мини-карт.</p>
        <hr>
        <h2>Определение того, что просматривает представление</h2>
        <p>Класс, который инкапсулирует представления в SFML, называется sf::View. Его можно построить непосредственно с определением области просмотра:</p>
        <img src="./03_08_01.png" alt="">
        <p>Эти два определения эквивалентны: оба представления будут отображать одну и ту же область 2D-мира, прямоугольник 300x200 с центром в точке (350, 300).</p>
        <img src="./03_08_02.png" alt="" class="border-none">
        <p>Если вы не хотите определять представление при построении или хотите изменить его позже, вы можете использовать эквивалентные сеттеры:</p>
        <img src="./03_08_03.png" alt="">
        <p>Как только ваш вид определен, вы можете преобразовать его, чтобы он отображал переведенную/повернутую/масштабированную версию вашего 2D-мира.</p>
        <h4>Перемещение (прокрутка) вида</h4>
        <p>В отличие от рисуемых сущностей, таких как спрайты или фигуры, положение которых определяется их левым верхним углом (и может быть изменено на любую другую точку), представления всегда управляются их центром — это просто более удобно. Вот почему
            функция для изменения положения представления называется setCenter, а не setPosition.</p>
        <img src="./03_08_04.png" alt="">
        <img src="./03_08_05.png" alt="" class="border-none">
        <h4>Вращение вида</h4>
        <p>Чтобы повернуть вид, используйте функцию setRotation.</p>
        <img src="./03_08_06.png" alt="">
        <img src="./03_08_07.png" alt="" class="border-none">
        <h4>Масштабирование вида</h4>
        <p>Увеличение (или уменьшение) представления выполняется посредством изменения его размера, поэтому используемая функция — setSize.</p>
        <img src="./03_08_08.png" alt="">
        <img src="./03_08_09.png" alt="" class="border-none">
        <hr>
        <h2>Определение способа просмотра представления</h2>
        <p>Теперь, когда вы определили, какая часть 2D-мира видна в окне, давайте определим, где она отображается. По умолчанию просматриваемое содержимое занимает все окно. Если представление имеет тот же размер, что и окно, все отображается в масштабе
            1:1. Если представление меньше или больше окна, все масштабируется, чтобы соответствовать окну.</p>
        <p>Это поведение по умолчанию подходит для большинства ситуаций, но иногда его может потребоваться изменить. Например, чтобы разделить экран в многопользовательской игре, вы можете использовать два вида, каждый из которых занимает только половину
            окна. Вы также можете реализовать мини-карту, нарисовав весь мир в виде, который отображается в небольшой области в углу окна. Область, в которой отображается содержимое представления, называется окном просмотра.</p>
        <p>Чтобы установить область просмотра представления, вы можете использовать функцию setViewport.</p>
        <img src="./03_08_10.png" alt="">
        <img src="./03_08_11.png" alt="" class="border-none">
        <p>Возможно, вы заметили нечто очень важное: область просмотра определяется не в пикселях, а как отношение размера окна. Это более удобно: позволяет не отслеживать события изменения размера, чтобы обновлять размер области просмотра каждый раз, когда
            изменяется размер окна. Это также более интуитивно понятно: вы, вероятно, в любом случае определили бы область просмотра как часть всей площади окна, а не как прямоугольник фиксированного размера.</p>
        <p>Используя окно просмотра, легко разделить экран для многопользовательских игр:</p>
        <img src="./03_08_12.png" alt="">
        <img src="./03_08_13.png" alt="" class="border-none">
        <p>... или мини-карта:</p>
        <img src="./03_08_14.png" alt="">
        <img src="./03_08_15.png" alt="" class="border-none">
        <hr>
        <h2>Использование представления</h2>
        <p>Чтобы нарисовать что-то с помощью представления, вы должны нарисовать это после вызова функции setView цели, к которой вы рисуете (sf::RenderWindow или sf::RenderTexture).</p>
        <img src="./03_08_16.png" alt="">
        <p>Вид остается активным, пока вы не установите другой. Это означает, что всегда есть вид, который определяет, что появляется в мишени и где это нарисовано. Если вы явно не задали какое-либо представление, цель рендеринга использует собственное представление
            по умолчанию, которое соответствует его размеру 1:1. Вы можете получить вид цели рендеринга по умолчанию с помощью функции getDefaultView. Это может быть полезно, если вы хотите определить свой собственный вид на его основе или восстановить
            его для рисования фиксированных объектов (например, GUI) поверх вашей сцены.</p>
        <img src="./03_08_17.png" alt="">
        <div class="atention">
            <p>Когда вы вызываете setView, цель рендеринга создает копию представления и не сохраняет указатель на тот, который был передан. Это означает, что всякий раз, когда вы обновляете свое представление, вам нужно снова вызывать setView, чтобы применить
                изменения.
            </p>
            <p>Не бойтесь копировать представления или создавать их на лету, это не дорогие объекты (они просто содержат несколько значений с плавающей запятой).</p>
        </div>
        <hr>
        <h2>Отображение дополнительных сведений при изменении размера окна</h2>
        <p>Поскольку вид по умолчанию никогда не меняется после создания окна, просматриваемое содержимое всегда остается одним и тем же. Поэтому, когда размер окна изменяется, все сжимается/растягивается до нового размера.</p>
        <p>Если вместо этого поведения по умолчанию вы хотите показывать больше/меньше вещей в зависимости от нового размера окна, все, что вам нужно сделать, это обновить размер представления с размером окна.</p>
        <img src="./03_08_18.png" alt="">
        <hr>
        <h2>Преобразования координат</h2>
        <p>Когда вы используете пользовательский вид или когда вы изменяете размер окна без использования приведенного выше кода, пиксели, отображаемые на цели, больше не соответствуют единицам измерения в 2D-мире. Например, нажатие на пиксель (10, 50) может
            попасть в точку (26,5, -84) вашего мира. В конечном итоге вам придется использовать функцию преобразования для сопоставления ваших пиксельных координат с мировыми координатами: mapPixelToCoords.</p>
        <img src="./03_08_19.png" alt="">
        <p>По умолчанию mapPixelToCoords использует текущее представление. Если вы хотите преобразовать координаты, используя представление, которое не является активным, вы можете передать его в качестве дополнительного аргумента функции.</p>
        <p>Обратное преобразование мировых координат в пиксельные координаты также возможно с помощью функции mapCoordsToPixel.</p>
        <hr>
        <p><a href="./04_01.html">Воспроизведение звуков и музыки&rArr;</a></p>
    </div>
</body>