<head>
    <link rel="stylesheet" href="../../../css/books_style.css">
</head>

<body>
    <div>
        <p><a href="./04_01.html">&lArr;Воспроизведение звуков и музыки</a></p>
        <h1>Запись аудио</h1>
        <hr>
        <h2>Запись в звуковой буфер</h2>
        <p>Чаще всего захваченные аудиоданные используются для их сохранения в звуковой буфер (sf::SoundBuffer), чтобы их можно было либо воспроизвести, либо сохранить в файл.</p>
        <p>Этого можно добиться с помощью очень простого интерфейса класса sf::SoundBufferRecorder:</p>
        <img src="./04_02_01.png" alt="">
        <p>Статическая функция SoundBufferRecorder::isAvailable проверяет, поддерживается ли системой запись звука. Если он возвращает false, вы вообще не сможете использовать класс sf::SoundBufferRecorder.</p>
        <p>Функции запуска и остановки говорят сами за себя. Захват выполняется в собственном потоке, что означает, что вы можете делать все, что хотите, между запуском и остановкой. После окончания захвата записанные аудиоданные доступны в звуковом буфере,
            который можно получить с помощью функции getBuffer.</p>
        <p>С записанными данными вы можете:</p>
        <ul>
            <li>
                <p>Сохраните его в файл</p>
                <img src="./04_02_02.png" alt="">
            </li>
            <li>
                <p>Играть напрямую</p>
                <img src="./04_02_03.png" alt="">
            </li>
            <li>
                <p>Получите доступ к необработанным аудиоданным и проанализируйте их, преобразуйте и т. д.</p>
                <img src="./04_02_04.png" alt="">
            </li>
        </ul>
        <div class="atention">
            <p>Если вы хотите использовать захваченные аудиоданные после уничтожения или перезапуска диктофона, не забудьте сделать копию буфера.</p>
        </div>
        <hr>
        <h2>Выбор устройства ввода</h2>
        <p>Если к вашему компьютеру подключено несколько устройств ввода звука (например, микрофон, звуковой интерфейс (внешняя звуковая карта) или микрофон веб-камеры), вы можете указать устройство, которое используется для записи. Устройство ввода звука
            идентифицируется по его имени. std::vector&lt;std::string&gt;, содержащий имена всех подключенных устройств, доступен через статическую функцию SoundBufferRecorder::getAvailableDevices(). Затем вы можете выбрать устройство из списка для записи,
            передав имя выбранного устройства методу setDevice(). Возможна даже смена устройства на лету (т.е. во время записи).</p>
        <p>Имя используемого в данный момент устройства можно получить, вызвав getDevice(). Если вы не выберете устройство самостоятельно, будет использоваться устройство по умолчанию. Его имя можно получить с помощью статической функции SoundBufferRecorder::getDefaultDevice().</p>
        <p>Вот небольшой пример того, как установить устройство ввода:</p>
        <img src="./04_02_05.png" alt="">
        <hr>
        <h2>Пользовательская запись</h2>
        <p>Если хранение захваченных данных в звуковом буфере вас не устраивает, вы можете написать свой собственный рекордер. Это позволит вам обрабатывать аудиоданные во время их захвата (почти) непосредственно с записывающего устройства. Таким образом,
            вы можете, например, транслировать захваченный звук по сети, выполнять его анализ в реальном времени и т. д.</p>
        <p>Чтобы написать свой собственный рекордер, вы должны наследовать его от абстрактного базового класса sf::SoundRecorder. На самом деле sf::SoundBufferRecorder — это просто встроенная специализация этого класса.</p>
        <p>У вас есть только одна виртуальная функция для переопределения в производном классе: onProcessSamples. Он вызывается каждый раз, когда захватывается новый кусок аудиосэмпла, так что именно здесь вы реализуете свои конкретные вещи.</p>
        <p>По умолчанию образцы аудио предоставляются методу onProcessSamples каждые 100 мс. Вы можете изменить интервал, используя метод setProcessingInterval. Вы можете использовать меньший интервал, например, если хотите обрабатывать записанные данные
            в режиме реального времени. Обратите внимание, что это всего лишь подсказка, а фактический период может отличаться, поэтому не полагайтесь на него для точного определения времени.</p>
        <p>Есть также две дополнительные виртуальные функции, которые вы можете переопределить: onStart и onStop. Они вызываются при запуске/остановке захвата соответственно. Они полезны для задач инициализации/очистки.</p>
        <p>Вот скелет полного производного класса:</p>
        <img src="./04_02_06.png" alt="">
        <p>Функции isAvailable/start/stop определены в базе sf::SoundRecorder и, таким образом, наследуются во всех производных классах. Это означает, что вы можете использовать любой класс рекордера точно так же, как класс sf::SoundBufferRecorder выше.</p>
        <img src="./04_02_07.png" alt="">
        <hr>
        <h2>Проблемы с потоками</h2>
        <p>Поскольку запись ведется в отдельном потоке, важно знать, что именно происходит и где.</p>
        <p>onStart будет вызываться непосредственно функцией запуска, поэтому она выполняется в том же потоке, который ее вызвал. Однако onProcessSample и onStop всегда будут вызываться из внутреннего потока записи, который создает SFML.</p>
        <p>Если ваш рекордер использует данные, которые могут быть доступны одновременно как в вызывающем потоке, так и в потоке записи, вы должны защитить их (например, с помощью мьютекса), чтобы избежать одновременного доступа, который может привести к
            неопределенному поведению — поврежденные данные записано, сбои и т.д.</p>
        <p>Если вы недостаточно знакомы с многопоточностью, вы можете обратиться к <span><a href="./01_02.html">соответствующему руководству</a></span> для получения дополнительной информации.</p>
        <hr>
        <p><a href="./04_03.html">Пользовательские аудиопотоки&rArr;</a></p>
    </div>
</body>