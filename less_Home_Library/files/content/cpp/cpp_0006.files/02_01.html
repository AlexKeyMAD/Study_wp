<head>
    <link rel="stylesheet" href="../../../css/books_style.css">
</head>

<body>
    <div>
        <p><a href="./01_03.html">&lArr;Потоки пользовательских данных</a></p>
        <h1>Открытие и управление окном в SFML</h1>
        <hr>
        <h2>Вступление</h2>
        <p>В этом руководстве объясняется только, как открыть окно и управлять им. Рисование выходит за рамки модуля sfml-window: этим занимается модуль sfml-graphics. Однако управление окнами остается точно таким же, поэтому чтение этого руководства важно
            в любом случае.</p>
        <hr>
        <h2>Открытие окна</h2>
        <p>Окна в SFML определяются классом sf::Window. Окно может быть создано и открыто непосредственно при построении:</p>
        <code>
            <p class="cpp_code">#include &lt;SFML/Window.hpp&gt;</p>
            <br>
            <p class="cpp_code">int main()</p>
            <p class="cpp_code">{</p>
            <p class="cpp_code_1t">sf::Window window(sf::VideoMode(800, 600), "My window");</p>
            <br>        
            <p class="cpp_code_1t">...</p>
            <br>        
            <p class="cpp_code_1t">return 0;</p>
            <p class="cpp_code">}</p>
        </code>
        <p>Первый аргумент, видеорежим, определяет размер окна (внутренний размер, без заголовка и границ). Здесь мы создаем окно размером 800x600 пикселей.</p>
        <p>Класс sf::VideoMode имеет несколько интересных статических функций для получения разрешения рабочего стола или списка допустимых видеорежимов для полноэкранного режима. Не стесняйтесь взглянуть на его документацию.</p>
        <p>Второй аргумент — это просто заголовок окна.</p>
        <p>Этот конструктор принимает третий необязательный аргумент: стиль, который позволяет вам выбирать, какие украшения и функции вам нужны. Вы можете использовать любую комбинацию следующих стилей:</p>
        <table class="table-td-left">
            <tr>
                <td>sf::Style::None</td>
                <td>Никакого оформления (полезно, например, для заставок); этот стиль нельзя сочетать с другими</td>
            </tr>
            <tr>
                <td>sf::Style::Titlebar</td>
                <td>Окно имеет заголовок</td>
            </tr>
            <tr>
                <td>sf::Style::Resize</td>
                <td>Окно может быть изменено в размере и имеет кнопку максимизации</td>
            </tr>
            <tr>
                <td>sf::Style::Close</td>
                <td>Окно имеет кнопку закрытия</td>
            </tr>
            <tr>
                <td>sf::Style::Fullscreen</td>
                <td>Окно отображается в полноэкранном режиме; этот стиль нельзя комбинировать с другими, и для него требуется действующий видеорежим.</td>
            </tr>
            <tr>
                <td>sf::Style::Default</td>
                <td>Стиль по умолчанию, который является ярлыком для заголовка | Изменить размер | Закрывать</td>
            </tr>
        </table>
        <p>Существует также четвертый необязательный аргумент, который определяет специальные параметры OpenGL, которые объясняются в специальном руководстве по OpenGL.</p>
        <p>Если вы хотите создать окно после построения экземпляра sf::Window или воссоздать его с другим видеорежимом или заголовком, вместо этого вы можете использовать функцию создания. Он принимает те же аргументы, что и конструктор.</p>
        <code>
            <p class="cpp_code">#include &lt;SFML/Window.hpp&gt;</p>
            <br>
            <p class="cpp_code">int main()</p>
            <p class="cpp_code">{</p>
            <p class="cpp_code_1t">sf::Window window;</p>
            <p class="cpp_code_1t">window.create(sf::VideoMode(800, 600), "My window");</p>
            <br>
            <p class="cpp_code_1t">...</p>
            <br>            
            <p class="cpp_code_1t">return 0;</p>
            <p class="cpp_code">}</p>
        </code>
        <hr>
        <h2>Оживление окна</h2>
        <p>Если вы попытаетесь выполнить приведенный выше код, ничего не заменив "...", вы вряд ли что-то увидите. Во-первых, потому что программа сразу же завершается. Во-вторых, потому что нет обработки событий, поэтому, даже если вы добавите бесконечный
            цикл в этот код, вы увидите мертвое окно, которое нельзя переместить, изменить размер или закрыть.</p>
        <p>Давайте добавим немного кода, чтобы сделать эту программу немного интереснее:</p>
        <code>
            <p class="cpp_code">#include &lt;SFML/Window.hpp&gt;</p>
            <br>
            <p class="cpp_code">int main()</p>
            <p class="cpp_code">{</p>
            <p class="cpp_code_1t">sf::Window window(sf::VideoMode(800, 600), "My window");</p>
            <br>            
            <p class="cpp_code_1t">// run the program as long as the window is open</p>
            <p class="cpp_code_1t">while (window.isOpen())</p>
            <p class="cpp_code_1t">{</p>
            <p class="cpp_code_2t">// check all the window's events that were triggered since the last iteration of the loop</p>
            <p class="cpp_code_2t">sf::Event event;</p>
            <p class="cpp_code_2t">while (window.pollEvent(event))</p>
            <p class="cpp_code_2t">{</p>
            <p class="cpp_code_3t">// "close requested" event: we close the window</p>
            <p class="cpp_code_3t">if (event.type == sf::Event::Closed)</p>
            <p class="cpp_code_4t">window.close();</p>
            <p class="cpp_code_2t">}</p>
            <p class="cpp_code_1t">}</p>
            <br>
            <p class="cpp_code_1t">return 0;</p>
            <p class="cpp_code">}</p>
        </code>
        <p>Приведенный выше код открывает окно и завершает работу, когда пользователь его закрывает. Давайте посмотрим, как это работает в деталях.</p>
        <p>Во-первых, мы добавили цикл, который гарантирует, что приложение будет обновлено/обновлено, пока окно не будет закрыто. Большинство (если не все) программ SFML имеют такой цикл, который иногда называют основным циклом или игровым циклом.</p>
        <p>Затем первое, что мы хотим сделать в нашем игровом цикле, — это проверить все произошедшие события. Обратите внимание, что мы используем цикл while, чтобы обрабатывались все ожидающие события, если их было несколько. Функция pollEvent возвращает
            значение true, если событие ожидалось, или значение false, если его не было.</p>
        <p>Всякий раз, когда мы получаем событие, мы должны проверять его тип (окно закрыто? клавиша нажата? мышь перемещена? джойстик подключен?...) и реагировать соответствующим образом, если оно нас интересует. В данном случае нас интересует только событие
            Event::Closed, которое срабатывает, когда пользователь хочет закрыть окно. В этот момент окно все еще открыто, и мы должны явно закрыть его с помощью функции закрытия. Это позволяет вам сделать что-то до закрытия окна, например сохранить текущее
            состояние приложения или отобразить сообщение.</p>
        <div class="atention">
            <p>Ошибка, которую часто совершают люди, заключается в том, что они забывают о цикле обработки событий просто потому, что они еще не заботятся об обработке событий (вместо этого они используют ввод данных в реальном времени). Без цикла событий
                окно перестанет отвечать на запросы. Важно отметить, что цикл обработки событий имеет две роли: помимо предоставления событий пользователю, он также дает окну возможность обрабатывать свои внутренние события, что необходимо для того, чтобы
                оно могло реагировать на перемещение или изменение размера действий пользователя.</p>
        </div>
        <p>После закрытия окна основной цикл завершается, и программа завершается.</p>
        <p>На данный момент вы, вероятно, заметили, что мы еще не говорили о рисовании чего-либо в окне. Как сказано во введении, это не работа модуля sfml-window, и вам придется перейти к учебникам по sfml-graphics, если вы хотите рисовать такие вещи, как
            спрайты, текст или фигуры.</p>
        <p>Для рисования вы также можете напрямую использовать OpenGL и полностью игнорировать модуль sfml-graphics. sf::Window внутри создает контекст OpenGL и готов принимать ваши вызовы OpenGL. Подробнее об этом можно узнать в соответствующем туториале.</p>
        <p>Не ожидайте увидеть в этом окне что-то интересное: вы можете увидеть однородный цвет (черный или белый), или последнее содержимое предыдущего приложения, которое использовало OpenGL, или... что-то еще.</p>
        <hr>
        <h2>Игра с окном</h2>
        <p>Конечно, SFML позволяет вам немного поиграть с вашими окнами. Основные операции с окном, такие как изменение размера, положения, заголовка или значка, поддерживаются, но в отличие от специализированных библиотек графического интерфейса (Qt, wxWidgets)
            SFML не предоставляет дополнительных функций. Окна SFML предназначены только для предоставления среды для рисования OpenGL или SFML.</p>
        <code>
            <p class="cpp_code">// change the position of the window (relatively to the desktop)</p>
            <p class="cpp_code">window.setPosition(sf::Vector2i(10, 50));</p>
            <br>
            <p class="cpp_code">// change the size of the window</p>
            <p class="cpp_code">window.setSize(sf::Vector2u(640, 480));</p>
            <br>
            <p class="cpp_code">// change the title of the window</p>
            <p class="cpp_code">window.setTitle("SFML window");</p>
            <br>
            <p class="cpp_code">// get the size of the window</p>
            <p class="cpp_code">sf::Vector2u size = window.getSize();</p>
            <p class="cpp_code">unsigned int width = size.x;</p>
            <p class="cpp_code">unsigned int height = size.y;</p>
            <br>
            <p class="cpp_code">// check whether the window has the focus</p>
            <p class="cpp_code">bool focus = window.hasFocus();</p>
            <br>
            <p class="cpp_code">...</p>
        </code>
        <p>Полный список функций sf::Window можно найти в документации по API.</p>
        <p>Если вам действительно нужны расширенные функции для вашего окна, вы можете создать его (или даже полный графический интерфейс) с другой библиотекой и встроить в него SFML. Для этого вы можете использовать другой конструктор или функцию create
            sf::Window, которая принимает специфичный для ОС дескриптор существующего окна. В этом случае SFML создаст контекст рисования внутри данного окна и перехватит все его события, не мешая управлению родительским окном.</p>
        <code>
            <p class="cpp_code">sf::WindowHandle handle = /* specific to what you're doing and the library you're using */;</p>
            <p class="cpp_code">sf::Window window(handle);</p>
        </code>
        <p>Если вам просто нужна дополнительная, очень специфическая функция, вы также можете сделать это наоборот: создать окно SFML и получить его специфичный для ОС дескриптор для реализации вещей, которые сам SFML не поддерживает.</p>
        <code>
            <p class="cpp_code">sf::Window window(sf::VideoMode(800, 600), "SFML window");</p>
            <p class="cpp_code">sf::WindowHandle handle = window.getSystemHandle();</p>
            <br>
            <p class="cpp_code">// you can now use the handle with OS specific functions</p>
        </code>
        <p>Интеграция SFML с другими библиотеками требует некоторой работы и не будет здесь описываться, но вы можете обратиться к специальным руководствам, примерам или сообщениям на форуме.</p>
        <hr>
        <h2>Управление частотой кадров</h2>
        <p>Иногда, когда ваше приложение работает быстро, вы можете заметить визуальные артефакты, такие как разрывы. Причина в том, что частота обновления вашего приложения не синхронизирована с вертикальной частотой монитора, и в результате низ предыдущего
            кадра смешивается с верхом следующего.</p>
        <p>Решение этой проблемы — активация вертикальной синхронизации. Он автоматически обрабатывается видеокартой и может легко включаться и выключаться с помощью функции setVerticalSyncEnabled:</p>
        <code>
            <p class="cpp_code">window.setVerticalSyncEnabled(true); // call it once, after creating the window</p>
        </code>
        <p>После этого вызова ваше приложение будет работать с той же частотой, что и частота обновления монитора.</p>
        <div class="atention">
            <p>Иногда setVerticalSyncEnabled не будет иметь никакого эффекта: скорее всего, это связано с тем, что вертикальная синхронизация принудительно отключена в настройках вашего графического драйвера. Вместо этого следует установить «управляется
                приложением».
            </p>
        </div>
        <p>В других ситуациях вы также можете захотеть, чтобы ваше приложение работало с заданной частотой кадров, а не с частотой монитора. Это можно сделать, вызвав setFramerateLimit:</p>
        <code>
            <p class="cpp_code">window.setFramerateLimit(60); // call it once, after creating the window</p>
        </code>
        <p>В отличие от setVerticalSyncEnabled, эта функция реализована самим SFML с использованием комбинации sf::Clock и sf::sleep. Важным последствием является то, что он не надежен на 100%, особенно для высокой частоты кадров: разрешение sf::sleep зависит
            от базовой операционной системы и оборудования и может достигать 10 или 15 миллисекунд. Не полагайтесь на эту функцию для реализации точного времени.</p>
        <div class="atention">
            <p>Никогда не используйте setVerticalSyncEnabled и setFramerateLimit одновременно! Они бы плохо смешались и усугубили бы ситуацию.</p>
        </div>
        <hr>
        <h2>Что нужно знать об окнах</h2>
        <p>Вот краткий список того, что вы можете и чего не можете делать с окнами SFML.</p>
        <p class="font-bold">Вы можете создать несколько окон</p>
        <p>SFML позволяет создавать несколько окон и обрабатывать их либо все в основном потоке, либо каждое в своем собственном потоке (но... см. ниже). В этом случае не забудьте про цикл обработки событий для каждого окна.</p>
        <p class="font-bold">Несколько мониторов пока не поддерживаются должным образом</p>
        <p>SFML не управляет несколькими мониторами явно. Как следствие, вы не сможете выбрать, на каком мониторе будет отображаться окно, и вы не сможете создать более одного полноэкранного окна. Это должно быть улучшено в будущей версии.</p>
        <p class="font-bold">События должны опрашиваться в потоке окна</p>
        <p>Это важное ограничение большинства операционных систем: цикл обработки событий (точнее, функция pollEvent или waitEvent) должен вызываться в том же потоке, который создал окно. Это означает, что если вы хотите создать выделенный поток для обработки
            событий, вам нужно убедиться, что окно также создается в этом потоке. Если вы действительно хотите разделить вещи между потоками, удобнее оставить обработку событий в основном потоке, а вместо этого перенести все остальное (рендеринг, физику,
            логику и т. д.) в отдельный поток. Эта конфигурация также будет совместима с другим ограничением, описанным ниже.</p>
        <p class="font-bold">В macOS окна и события должны управляться в основном потоке.</p>
        <p>Да, это правда; macOS просто не согласится, если вы попытаетесь создать окно или обработать события в потоке, отличном от основного.</p>
        <p class="font-bold">В Windows окно, которое больше рабочего стола, не будет вести себя правильно.</p>
        <p>По какой-то причине Windows не любит окна, которые больше рабочего стола. Сюда входят окна, созданные с помощью VideoMode::getDesktopMode(): с добавленными декорациями окна (границами и заголовком) вы получите окно, которое немного больше рабочего
            стола.
        </p>
        <p><a href="./02_02.html">Обработчики событий&rArr;</a></p>
    </div>
</body>