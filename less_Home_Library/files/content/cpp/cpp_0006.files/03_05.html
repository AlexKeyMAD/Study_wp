<head>
    <link rel="stylesheet" href="../../../css/books_style.css">
</head>

<body>
    <div>
        <p><a href="./03_04.html">&lArr;Формы</a></p>
        <h1>Создание собственных сущностей с массивами вершин</h1>
        <hr>
        <h2>Вступление</h2>
        <p>SFML предоставляет простые классы для наиболее распространенных 2D-объектов. И хотя из этих стандартных блоков можно легко создавать более сложные объекты, это не всегда самое эффективное решение. Например, вы очень быстро достигнете предела возможностей
            вашей видеокарты, если будете рисовать большое количество спрайтов. Причина в том, что производительность в значительной степени зависит от количества вызовов функции рисования. Действительно, каждый вызов включает в себя установку набора
            состояний OpenGL, сброс матриц, смену текстур и т. д. Все это требуется даже при простом рисовании двух треугольников (спрайта). Это далеко не оптимально для вашей видеокарты: современные графические процессоры предназначены для обработки
            больших пакетов треугольников, обычно от нескольких тысяч до миллионов.</p>
        <p>Чтобы заполнить этот пробел, SFML предоставляет механизм более низкого уровня для рисования: массивы вершин. На самом деле массивы вершин используются внутри всех остальных классов SFML. Они позволяют более гибко определять 2D-объекты, содержащие
            столько треугольников, сколько вам нужно. Они даже позволяют рисовать точки или линии.</p>
        <hr>
        <h2>Что такое вершина и почему они всегда в массивах?</h2>
        <p>Вершина — это наименьший графический объект, которым вы можете манипулировать. Короче говоря, это графическая точка: естественно, у нее есть 2D-позиция (x, y), а также цвет и пара текстурных координат. Мы рассмотрим роли этих атрибутов позже.</p>
        <p>Вершины (множественное число от вершины) сами по себе мало что делают. Они всегда группируются в примитивы: точки (1 вершина), линии (2 вершины), треугольники (3 вершины) или четырехугольники (4 вершины). Затем вы можете объединить несколько примитивов
            вместе, чтобы создать окончательную геометрию объекта.</p>
        <p>Теперь вы понимаете, почему мы всегда говорим о массивах вершин, а не только о вершинах.</p>
        <hr>
        <h2>Простой массив вершин</h2>
        <p>Давайте теперь посмотрим на класс sf::Vertex. Это просто контейнер, который содержит три общедоступных члена и никаких функций, кроме его конструкторов. Эти конструкторы позволяют вам создавать вершины из набора необходимых вам атрибутов — вам
            не всегда нужно окрашивать или текстурировать вашу сущность.</p>
        <img src="./03_05_01.png" alt="">
        <p>... или, используя правильный конструктор:</p>
        <img src="./03_05_02.png" alt="">
        <p>Теперь давайте определим примитив. Помните, примитив состоит из нескольких вершин, поэтому нам нужен массив вершин. SFML предоставляет для этого простую оболочку: sf::VertexArray. Он обеспечивает семантику массива (аналогично std::vector), а также
            хранит тип примитива, определяемого его вершинами.</p>
        <img src="./03_05_03.png" alt="">
        <p>Ваш треугольник готов, и теперь вы можете его нарисовать. Рисование массива вершин можно выполнить аналогично рисованию любого другого объекта SFML с помощью функции рисования:</p>
        <img src="./03_05_04.png" alt="">
        <img src="./03_05_05.png" alt="" class="border-none">
        <p>Вы можете видеть, что цвет вершин интерполирован для заполнения примитива. Это хороший способ создания градиентов.</p>
        <p>Обратите внимание, что вам не обязательно использовать класс sf::VertexArray. Он просто определен для удобства, это не что иное, как std::vector&lt;sf::Vertex&gt; вместе с sf::PrimitiveType. Если вам нужна большая гибкость или статический массив,
            вы можете использовать собственное хранилище. Затем вы должны использовать перегрузку функции рисования, которая принимает указатель на вершины, количество вершин и тип примитива.</p>
        <img src="./03_05_06.png" alt="">
        <p></p>
        <img src="./03_05_07.png" alt="">
        <hr>
        <h2>Примитивные типы</h2>
        <p>Давайте ненадолго остановимся и посмотрим, какие примитивы вы можете создать. Как объяснялось выше, вы можете определить самые основные 2D-примитивы: точку, линию, треугольник и четырехугольник (четырехугольник существует только для удобства,
            внутренне графическая карта разбивает его на два треугольника). Существуют также «цепочечные» варианты этих типов примитивов, которые позволяют совместно использовать вершины между двумя последовательными примитивами. Это может быть полезно,
            потому что последовательные примитивы часто каким-то образом связаны.</p>
        <p>Давайте посмотрим на полный список:</p>
        <table>
            <tr>
                <th>Примитивный тип</th>
                <th>Описание</th>
                <th>Пример</th>
            </tr>
            <tr>
                <td>sf::Points</td>
                <td>Набор несвязанных точек. У этих точек нет толщины: они всегда будут занимать один пиксель, независимо от текущего преобразования и вида.</td>
                <td><img src="./03_05_08.png" alt="" class="border-none"></td>
            </tr>
            <tr>
                <td>sf::Lines</td>
                <td>Набор несоединенных линий. У этих линий нет толщины: они всегда будут шириной в один пиксель, независимо от текущего преобразования и вида.</td>
                <td><img src="./03_05_09.png" alt="" class="border-none"></td>
            </tr>
            <tr>
                <td>sf::LineStrip</td>
                <td>Набор связанных линий. Конечная вершина одной линии используется как начальная вершина следующей.</td>
                <td><img src="./03_05_10.png" alt="" class="border-none"></td>
            </tr>
            <tr>
                <td>sf::Triangles</td>
                <td>Набор несоединенных треугольников.</td>
                <td><img src="./03_05_11.png" alt="" class="border-none"></td>
            </tr>
            <tr>
                <td>sf::TriangleStrip</td>
                <td>Набор соединенных треугольников. Каждый треугольник имеет общие две последние вершины со следующим.</td>
                <td><img src="./03_05_12.png" alt="" class="border-none"></td>
            </tr>
            <tr>
                <td>sf::TriangleFan</td>
                <td>Набор треугольников, соединенных с центральной точкой. Первая вершина является центром, затем каждая новая вершина определяет новый треугольник, используя центр и предыдущую вершину.</td>
                <td><img src="./03_05_13.png" alt="" class="border-none"></td>
            </tr>
            <tr>
                <td>sf::Quads</td>
                <td>Набор несвязанных квадов. 4 точки каждого квадроцикла должны быть определены последовательно, либо по часовой стрелке, либо против часовой стрелки.</td>
                <td><img src="./03_05_14.png" alt="" class="border-none"></td>
            </tr>
        </table>
        <hr>
        <h2>Текстурирование</h2>
        <p>Как и другие объекты SFML, массивы вершин также могут быть текстурированы. Для этого вам нужно манипулировать атрибутом texCoords вершин. Этот атрибут определяет, какой пиксель текстуры сопоставляется с вершиной.</p>
        <img src="./03_05_15.png" alt="">
        <div class="atention">
            <p>Координаты текстуры определяются в пикселях (как и textureRect спрайтов и фигур). Они не нормализованы (между 0 и 1), как могут ожидать люди, привыкшие к программированию на OpenGL.</p>
        </div>
        <p>Массивы вершин — низкоуровневые объекты, они имеют дело только с геометрией и не хранят дополнительные атрибуты, такие как текстура. Чтобы нарисовать массив вершин с текстурой, вы должны передать его непосредственно в функцию рисования:</p>
        <img src="./03_05_16.png" alt="">
        <p>Это короткая версия, если вам нужно передать другие состояния рендеринга (например, режим наложения или преобразование), вы можете использовать явную версию, которая принимает объект sf::RenderStates:</p>
        <img src="./03_05_17.png" alt="">
        <hr>
        <h2>Преобразование массива вершин</h2>
        <p>Преобразование похоже на текстурирование. Преобразование не сохраняется в массиве вершин, вы должны передать его функции рисования.</p>
        <img src="./03_05_18.png" alt="">
        <p>Или, если вам нужно передать другие состояния рендеринга:</p>
        <img src="./03_05_19.png" alt="">
        <p>Чтобы узнать больше о преобразованиях и классе sf::Transform, вы можете прочитать <span><a href="./03_06.html">руководство по преобразованию сущностей</a></span>.</p>
        <hr>
        <h2>Создание сущности, подобной SFML</h2>
        <p><a href="./03_06.html">Положение, вращение, масштаб: преобразование объектов&rArr;</a></p>
    </div>
</body>